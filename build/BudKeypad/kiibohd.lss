
kiibohd.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000063cc  00001000  00001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .usbdescriptortable 00000120  1fffe000  1fffe000  00016000  2**2
                  ALLOC
  2 .dmabuffers   00000000  1fffe120  1fffe120  0000efcc  2**0
                  CONTENTS
  3 .usbbuffers   00000870  1fffe120  1fffe120  00016000  2**0
                  ALLOC
  4 .data         0000063c  1fffe990  000073cc  0000e990  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000c80  1fffefcc  00007a08  0000efcc  2**2
                  ALLOC
  6 .debug_info   0000abb4  00000000  00000000  0000efcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001ea4  00000000  00000000  00019b80  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000005d0  00000000  00000000  0001ba24  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000820  00000000  00000000  0001bff4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  00009101  00000000  00000000  0001c814  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000036ce  00000000  00000000  00025915  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0001eac6  00000000  00000000  00028fe3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      00000020  00000000  00000000  00047aa9  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000033  00000000  00000000  00047ac9  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00000e70  00000000  00000000  00047afc  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000517a  00000000  00000000  0004896c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00001000 <gVectors>:
    1000:	00 20 00 20 f9 10 00 00 45 12 00 00 51 12 00 00     . . ....E...Q...
    1010:	85 12 00 00 c5 12 00 00 05 13 00 00 01 12 00 00     ................
    1020:	01 12 00 00 01 12 00 00 01 12 00 00 3d 12 00 00     ............=...
    1030:	3d 12 00 00 01 12 00 00 3d 12 00 00 f1 11 00 00     =.......=.......
    1040:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    1050:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    1060:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    1070:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    1080:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    1090:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    10a0:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    10b0:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    10c0:	3d 12 00 00 3d 12 00 00 3d 12 00 00 35 31 00 00     =...=...=...51..
    10d0:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    10e0:	3d 12 00 00 3d 12 00 00 3d 12 00 00 3d 12 00 00     =...=...=...=...
    10f0:	3d 12 00 00 3d 12 00 00                             =...=...

000010f8 <ResetHandler>:

// ----- Chip Entry Point -----

__attribute__ ((section(".startup")))
void ResetHandler()
{
    10f8:	b508      	push	{r3, lr}
		SCB_VTOR = addr; // relocate vector table
		jump_to_app( addr );
	}
#endif
	// Disable Watchdog
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
    10fa:	4b26      	ldr	r3, [pc, #152]	; (1194 <ResetHandler+0x9c>)
    10fc:	f24c 5220 	movw	r2, #50464	; 0xc520
    1100:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
    1102:	f64d 1228 	movw	r2, #55592	; 0xd928
    1106:	801a      	strh	r2, [r3, #0]
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    1108:	2210      	movs	r2, #16
    110a:	f823 2c0e 	strh.w	r2, [r3, #-14]

	uint32_t *src = (uint32_t*)&_etext;
	uint32_t *dest = (uint32_t*)&_sdata;

	// Enable clocks to always-used peripherals
	SIM_SCGC5 = 0x00043F82; // Clocks active to all GPIO
    110e:	f5a3 431f 	sub.w	r3, r3, #40704	; 0x9f00
    1112:	3bd6      	subs	r3, #214	; 0xd6
    1114:	4a20      	ldr	r2, [pc, #128]	; (1198 <ResetHandler+0xa0>)
    1116:	601a      	str	r2, [r3, #0]
	SIM_SCGC6 = SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
    1118:	4a20      	ldr	r2, [pc, #128]	; (119c <ResetHandler+0xa4>)
    111a:	605a      	str	r2, [r3, #4]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// release I/O pins hold, if we woke up from VLLS mode
	if ( PMC_REGSC & PMC_REGSC_ACKISO )
    111c:	f503 3353 	add.w	r3, r3, #216064	; 0x34c00
    1120:	f203 33ca 	addw	r3, r3, #970	; 0x3ca
    1124:	781a      	ldrb	r2, [r3, #0]
    1126:	0710      	lsls	r0, r2, #28
    1128:	d503      	bpl.n	1132 <ResetHandler+0x3a>
	{
		PMC_REGSC |= PMC_REGSC_ACKISO;
    112a:	781a      	ldrb	r2, [r3, #0]
    112c:	f042 0208 	orr.w	r2, r2, #8
    1130:	701a      	strb	r2, [r3, #0]

// ----- Chip Entry Point -----

__attribute__ ((section(".startup")))
void ResetHandler()
{
    1132:	2300      	movs	r3, #0
    1134:	4a1a      	ldr	r2, [pc, #104]	; (11a0 <ResetHandler+0xa8>)
	{
		PMC_REGSC |= PMC_REGSC_ACKISO;
	}

	// Prepare RAM
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    1136:	491b      	ldr	r1, [pc, #108]	; (11a4 <ResetHandler+0xac>)
    1138:	1898      	adds	r0, r3, r2
    113a:	4288      	cmp	r0, r1
    113c:	d204      	bcs.n	1148 <ResetHandler+0x50>
    113e:	491a      	ldr	r1, [pc, #104]	; (11a8 <ResetHandler+0xb0>)
    1140:	5859      	ldr	r1, [r3, r1]
    1142:	5099      	str	r1, [r3, r2]
    1144:	3304      	adds	r3, #4
    1146:	e7f5      	b.n	1134 <ResetHandler+0x3c>
    1148:	4b18      	ldr	r3, [pc, #96]	; (11ac <ResetHandler+0xb4>)
	dest = (uint32_t*)&_sbss;
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    114a:	4a19      	ldr	r2, [pc, #100]	; (11b0 <ResetHandler+0xb8>)
    114c:	4293      	cmp	r3, r2
    114e:	d203      	bcs.n	1158 <ResetHandler+0x60>
    1150:	2200      	movs	r2, #0
    1152:	f843 2b04 	str.w	r2, [r3], #4
    1156:	e7f8      	b.n	114a <ResetHandler+0x52>
    1158:	4b16      	ldr	r3, [pc, #88]	; (11b4 <ResetHandler+0xbc>)
// MCHCK / Kiibohd-dfu
#if defined(_mk20dx128vlf5_)
	// Default all interrupts to medium priority level
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
	{
		NVIC_SET_PRIORITY( i, 128 );
    115a:	2280      	movs	r2, #128	; 0x80
    115c:	f803 2b01 	strb.w	r2, [r3], #1
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;

// MCHCK / Kiibohd-dfu
#if defined(_mk20dx128vlf5_)
	// Default all interrupts to medium priority level
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    1160:	4a15      	ldr	r2, [pc, #84]	; (11b8 <ResetHandler+0xc0>)
    1162:	4293      	cmp	r3, r2
    1164:	d1f9      	bne.n	115a <ResetHandler+0x62>
	{
		NVIC_SET_PRIORITY( i, 128 );
	}

	// FLL at 48MHz
	MCG_C4 = MCG_C4_DMX32 | MCG_C4_DRST_DRS( 1 );
    1166:	4b15      	ldr	r3, [pc, #84]	; (11bc <ResetHandler+0xc4>)
    1168:	22a0      	movs	r2, #160	; 0xa0
    116a:	701a      	strb	r2, [r3, #0]

	// USB Clock and FLL select
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_TRACECLKSEL;
    116c:	f46f 71ff 	mvn.w	r1, #510	; 0x1fe
    1170:	f5a3 33df 	sub.w	r3, r3, #114176	; 0x1be00
    1174:	440b      	add	r3, r1
    1176:	f44f 2282 	mov.w	r2, #266240	; 0x41000
    117a:	601a      	str	r2, [r3, #0]

#endif

#if !defined(_bootloader_)
	// Initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
    117c:	4b10      	ldr	r3, [pc, #64]	; (11c0 <ResetHandler+0xc8>)
    117e:	f64b 327f 	movw	r2, #47999	; 0xbb7f
    1182:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
    1184:	2207      	movs	r2, #7
    1186:	f843 2c04 	str.w	r2, [r3, #-4]

	__enable_irq();
    118a:	b662      	cpsie	i
#else
	// Disable Watchdog for bootloader
	WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN;
#endif

	main();
    118c:	f000 f81a 	bl	11c4 <main>
    1190:	e7fe      	b.n	1190 <ResetHandler+0x98>
    1192:	bf00      	nop
    1194:	4005200e 	.word	0x4005200e
    1198:	00043f82 	.word	0x00043f82
    119c:	0b000001 	.word	0x0b000001
    11a0:	1fffe990 	.word	0x1fffe990
    11a4:	1fffefcc 	.word	0x1fffefcc
    11a8:	000073cc 	.word	0x000073cc
    11ac:	1fffefcc 	.word	0x1fffefcc
    11b0:	1ffffc4c 	.word	0x1ffffc4c
    11b4:	e000e400 	.word	0xe000e400
    11b8:	e000e42e 	.word	0xe000e42e
    11bc:	40064003 	.word	0x40064003
    11c0:	e000e014 	.word	0xe000e014

000011c4 <main>:


// ----- Functions -----

int main()
{
    11c4:	b508      	push	{r3, lr}
	CLKPR = 0x80;
	CLKPR = 0x00;
#endif

	// Enable CLI
	CLI_init();
    11c6:	f002 ffb7 	bl	4138 <CLI_init>

	// Setup Modules
	Output_setup();
    11ca:	f001 fe7f 	bl	2ecc <Output_setup>
	Macro_setup();
    11ce:	f001 fac5 	bl	275c <Macro_setup>
	Scan_setup();
    11d2:	f000 fb49 	bl	1868 <Scan_setup>

	// Main Detection Loop
	while ( 1 )
	{
		// Process CLI
		CLI_process();
    11d6:	f003 f891 	bl	42fc <CLI_process>

		// Acquire Key Indices
		// Loop continuously until scan_loop returns 0
		cli();
    11da:	b672      	cpsid	i
		while ( Scan_loop() );
    11dc:	f000 fb56 	bl	188c <Scan_loop>
    11e0:	2800      	cmp	r0, #0
    11e2:	d1fb      	bne.n	11dc <main+0x18>
		sei();
    11e4:	b662      	cpsie	i

		// Run Macros over Key Indices and convert to USB Keys
		Macro_process();
    11e6:	f001 f933 	bl	2450 <Macro_process>

		// Sends USB data only if changed
		Output_send();
    11ea:	f001 fe7f 	bl	2eec <Output_send>
	}
    11ee:	e7f2      	b.n	11d6 <main+0x12>

000011f0 <systick_default_isr>:

// NVIC - SysTick ISR
extern volatile uint32_t systick_millis_count;
void systick_default_isr()
{
	systick_millis_count++;
    11f0:	4b02      	ldr	r3, [pc, #8]	; (11fc <systick_default_isr+0xc>)
    11f2:	681a      	ldr	r2, [r3, #0]
    11f4:	3201      	adds	r2, #1
    11f6:	601a      	str	r2, [r3, #0]
    11f8:	4770      	bx	lr
    11fa:	bf00      	nop
    11fc:	1fffefcc 	.word	0x1fffefcc

00001200 <fault_isr>:

// ----- Interrupts -----

// NVIC - Default ISR
void fault_isr()
{
    1200:	b508      	push	{r3, lr}
	print("Fault!" NL );
    1202:	480c      	ldr	r0, [pc, #48]	; (1234 <fault_isr+0x34>)
    1204:	f003 f9bc 	bl	4580 <_print>
	while ( 1 )
	{
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    1208:	4c0b      	ldr	r4, [pc, #44]	; (1238 <fault_isr+0x38>)
    120a:	6823      	ldr	r3, [r4, #0]
    120c:	0358      	lsls	r0, r3, #13
    120e:	d501      	bpl.n	1214 <fault_isr+0x14>
    1210:	f001 ff90 	bl	3134 <usb_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART0 )  uart0_status_isr();
    1214:	6823      	ldr	r3, [r4, #0]
    1216:	0559      	lsls	r1, r3, #21
    1218:	d501      	bpl.n	121e <fault_isr+0x1e>
    121a:	f000 f80f 	bl	123c <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART1 )  uart1_status_isr();
    121e:	6823      	ldr	r3, [r4, #0]
    1220:	051a      	lsls	r2, r3, #20
    1222:	d501      	bpl.n	1228 <fault_isr+0x28>
    1224:	f000 f80a 	bl	123c <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART2 )  uart2_status_isr();
    1228:	6823      	ldr	r3, [r4, #0]
    122a:	04db      	lsls	r3, r3, #19
    122c:	d5ec      	bpl.n	1208 <fault_isr+0x8>
    122e:	f000 f805 	bl	123c <unused_isr>
    1232:	e7e9      	b.n	1208 <fault_isr+0x8>
    1234:	000047c6 	.word	0x000047c6
    1238:	40048034 	.word	0x40048034

0000123c <unused_isr>:
	}
}

void unused_isr()
{
    123c:	b508      	push	{r3, lr}
	fault_isr();
    123e:	f7ff ffdf 	bl	1200 <fault_isr>
    1242:	0000      	movs	r0, r0

00001244 <nmi_default_isr>:


// NVIC - Non-Maskable Interrupt ISR
void nmi_default_isr()
{
	print("NMI!" NL );
    1244:	4801      	ldr	r0, [pc, #4]	; (124c <nmi_default_isr+0x8>)
    1246:	f003 b99b 	b.w	4580 <_print>
    124a:	bf00      	nop
    124c:	000047cf 	.word	0x000047cf

00001250 <hard_fault_default_isr>:
}


// NVIC - Hard Fault ISR
void hard_fault_default_isr()
{
    1250:	b508      	push	{r3, lr}
	print("Hard Fault! SCB_HFSR: ");
    1252:	4807      	ldr	r0, [pc, #28]	; (1270 <hard_fault_default_isr+0x20>)
    1254:	f003 f994 	bl	4580 <_print>
	printHex32( SCB_HFSR );
    1258:	4b06      	ldr	r3, [pc, #24]	; (1274 <hard_fault_default_isr+0x24>)
    125a:	2101      	movs	r1, #1
    125c:	6818      	ldr	r0, [r3, #0]
    125e:	f003 fa4d 	bl	46fc <printHex32_op>
	print( NL );
    1262:	4805      	ldr	r0, [pc, #20]	; (1278 <hard_fault_default_isr+0x28>)
    1264:	f003 f98c 	bl	4580 <_print>
	SOFTWARE_RESET();
    1268:	4b04      	ldr	r3, [pc, #16]	; (127c <hard_fault_default_isr+0x2c>)
    126a:	4a05      	ldr	r2, [pc, #20]	; (1280 <hard_fault_default_isr+0x30>)
    126c:	601a      	str	r2, [r3, #0]
    126e:	bd08      	pop	{r3, pc}
    1270:	000047d6 	.word	0x000047d6
    1274:	e000ed2c 	.word	0xe000ed2c
    1278:	00006caf 	.word	0x00006caf
    127c:	e000ed0c 	.word	0xe000ed0c
    1280:	05fa0004 	.word	0x05fa0004

00001284 <memmanage_fault_default_isr>:
}


// NVIC - Memory Manager Fault ISR
void memmanage_fault_default_isr()
{
    1284:	b508      	push	{r3, lr}
	print("Memory Manager Fault! SCB_CFSR: ");
    1286:	480a      	ldr	r0, [pc, #40]	; (12b0 <memmanage_fault_default_isr+0x2c>)
    1288:	f003 f97a 	bl	4580 <_print>
	printHex32( SCB_CFSR );
    128c:	4b09      	ldr	r3, [pc, #36]	; (12b4 <memmanage_fault_default_isr+0x30>)
    128e:	2101      	movs	r1, #1
    1290:	6818      	ldr	r0, [r3, #0]
    1292:	f003 fa33 	bl	46fc <printHex32_op>
	print(" SCB_MMAR: ");
    1296:	4808      	ldr	r0, [pc, #32]	; (12b8 <memmanage_fault_default_isr+0x34>)
    1298:	f003 f972 	bl	4580 <_print>
	printHex32( SCB_MMAR );
    129c:	4b07      	ldr	r3, [pc, #28]	; (12bc <memmanage_fault_default_isr+0x38>)
    129e:	2101      	movs	r1, #1
    12a0:	6818      	ldr	r0, [r3, #0]
    12a2:	f003 fa2b 	bl	46fc <printHex32_op>
	print( NL );
    12a6:	4806      	ldr	r0, [pc, #24]	; (12c0 <memmanage_fault_default_isr+0x3c>)
}
    12a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	print("Memory Manager Fault! SCB_CFSR: ");
	printHex32( SCB_CFSR );
	print(" SCB_MMAR: ");
	printHex32( SCB_MMAR );
	print( NL );
    12ac:	f003 b968 	b.w	4580 <_print>
    12b0:	000047ed 	.word	0x000047ed
    12b4:	e000ed28 	.word	0xe000ed28
    12b8:	0000480e 	.word	0x0000480e
    12bc:	e000ed34 	.word	0xe000ed34
    12c0:	00006caf 	.word	0x00006caf

000012c4 <bus_fault_default_isr>:
}


// NVIC - Bus Fault ISR
void bus_fault_default_isr()
{
    12c4:	b508      	push	{r3, lr}
	print("Bus Fault! SCB_CFSR: ");
    12c6:	480a      	ldr	r0, [pc, #40]	; (12f0 <bus_fault_default_isr+0x2c>)
    12c8:	f003 f95a 	bl	4580 <_print>
	printHex32( SCB_CFSR );
    12cc:	4b09      	ldr	r3, [pc, #36]	; (12f4 <bus_fault_default_isr+0x30>)
    12ce:	2101      	movs	r1, #1
    12d0:	6818      	ldr	r0, [r3, #0]
    12d2:	f003 fa13 	bl	46fc <printHex32_op>
	print(" SCB_BFAR: ");
    12d6:	4808      	ldr	r0, [pc, #32]	; (12f8 <bus_fault_default_isr+0x34>)
    12d8:	f003 f952 	bl	4580 <_print>
	printHex32( SCB_BFAR );
    12dc:	4b07      	ldr	r3, [pc, #28]	; (12fc <bus_fault_default_isr+0x38>)
    12de:	2101      	movs	r1, #1
    12e0:	6818      	ldr	r0, [r3, #0]
    12e2:	f003 fa0b 	bl	46fc <printHex32_op>
	print( NL );
    12e6:	4806      	ldr	r0, [pc, #24]	; (1300 <bus_fault_default_isr+0x3c>)
}
    12e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	print("Bus Fault! SCB_CFSR: ");
	printHex32( SCB_CFSR );
	print(" SCB_BFAR: ");
	printHex32( SCB_BFAR );
	print( NL );
    12ec:	f003 b948 	b.w	4580 <_print>
    12f0:	0000481a 	.word	0x0000481a
    12f4:	e000ed28 	.word	0xe000ed28
    12f8:	00004830 	.word	0x00004830
    12fc:	e000ed38 	.word	0xe000ed38
    1300:	00006caf 	.word	0x00006caf

00001304 <usage_fault_default_isr>:
}


// NVIC - Usage Fault ISR
void usage_fault_default_isr()
{
    1304:	b508      	push	{r3, lr}
	print("Usage Fault! SCB_CFSR: ");
    1306:	4806      	ldr	r0, [pc, #24]	; (1320 <usage_fault_default_isr+0x1c>)
    1308:	f003 f93a 	bl	4580 <_print>
	printHex32( SCB_CFSR );
    130c:	4b05      	ldr	r3, [pc, #20]	; (1324 <usage_fault_default_isr+0x20>)
    130e:	2101      	movs	r1, #1
    1310:	6818      	ldr	r0, [r3, #0]
    1312:	f003 f9f3 	bl	46fc <printHex32_op>
	print( NL );
    1316:	4804      	ldr	r0, [pc, #16]	; (1328 <usage_fault_default_isr+0x24>)
}
    1318:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
// NVIC - Usage Fault ISR
void usage_fault_default_isr()
{
	print("Usage Fault! SCB_CFSR: ");
	printHex32( SCB_CFSR );
	print( NL );
    131c:	f003 b930 	b.w	4580 <_print>
    1320:	0000483c 	.word	0x0000483c
    1324:	e000ed28 	.word	0xe000ed28
    1328:	00006caf 	.word	0x00006caf

0000132c <memcpy>:
		/* NOTHING */;
	return (val);
}

void *memcpy( void *dst, const void *src, unsigned int len )
{
    132c:	b510      	push	{r4, lr}
	char *dstbuf = dst;
	const char *srcbuf = src;

	for (; len > 0; --len, ++dstbuf, ++srcbuf)
    132e:	2300      	movs	r3, #0
    1330:	4293      	cmp	r3, r2
    1332:	d003      	beq.n	133c <memcpy+0x10>
		*dstbuf = *srcbuf;
    1334:	5ccc      	ldrb	r4, [r1, r3]
    1336:	54c4      	strb	r4, [r0, r3]
    1338:	3301      	adds	r3, #1
    133a:	e7f9      	b.n	1330 <memcpy+0x4>
	return (dst);
}
    133c:	bd10      	pop	{r4, pc}

0000133e <yield>:



// ----- Functions -----

void yield(void) {};
    133e:	4770      	bx	lr

00001340 <cliFunc_matrixState>:
	info_msg("Matrix Debug Mode: ");
	printInt8( matrixDebugMode );
}

void cliFunc_matrixState ( char* args )
{
    1340:	b513      	push	{r0, r1, r4, lr}
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    1342:	4c07      	ldr	r4, [pc, #28]	; (1360 <cliFunc_matrixState+0x20>)
{
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    1344:	4669      	mov	r1, sp
    1346:	aa01      	add	r2, sp, #4
    1348:	f002 fe64 	bl	4014 <CLI_argumentIsolation>

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    134c:	2301      	movs	r3, #1

	if ( arg1Ptr[0] != '\0' )
    134e:	9800      	ldr	r0, [sp, #0]
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    1350:	8023      	strh	r3, [r4, #0]

	if ( arg1Ptr[0] != '\0' )
    1352:	7803      	ldrb	r3, [r0, #0]
    1354:	b113      	cbz	r3, 135c <cliFunc_matrixState+0x1c>
	{
		matrixDebugStateCounter = (uint16_t)numToInt( arg1Ptr );
    1356:	f003 f9f1 	bl	473c <numToInt>
    135a:	8020      	strh	r0, [r4, #0]
	}
}
    135c:	b002      	add	sp, #8
    135e:	bd10      	pop	{r4, pc}
    1360:	1fffefd8 	.word	0x1fffefd8

00001364 <cliFunc_matrixDebug>:


// ----- CLI Command Functions -----

void cliFunc_matrixDebug ( char* args )
{
    1364:	b507      	push	{r0, r1, r2, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    1366:	4669      	mov	r1, sp
    1368:	aa01      	add	r2, sp, #4
    136a:	f002 fe53 	bl	4014 <CLI_argumentIsolation>

	// Set the matrix debug flag depending on the argument
	// If no argument, set to scan code only
	// If set to T, set to state transition
	switch ( arg1Ptr[0] )
    136e:	9b00      	ldr	r3, [sp, #0]
    1370:	781b      	ldrb	r3, [r3, #0]
    1372:	2b54      	cmp	r3, #84	; 0x54
    1374:	d009      	beq.n	138a <cliFunc_matrixDebug+0x26>
    1376:	2b74      	cmp	r3, #116	; 0x74
    1378:	d007      	beq.n	138a <cliFunc_matrixDebug+0x26>
    137a:	b9bb      	cbnz	r3, 13ac <cliFunc_matrixDebug+0x48>
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
		break;

	// No argument
	case '\0':
		matrixDebugMode = matrixDebugMode != 1 ? 1 : 0;
    137c:	4b0d      	ldr	r3, [pc, #52]	; (13b4 <cliFunc_matrixDebug+0x50>)
    137e:	781a      	ldrb	r2, [r3, #0]
    1380:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
    1384:	bf18      	it	ne
    1386:	2201      	movne	r2, #1
    1388:	e005      	b.n	1396 <cliFunc_matrixDebug+0x32>
	switch ( arg1Ptr[0] )
	{
	// T as argument
	case 'T':
	case 't':
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
    138a:	4b0a      	ldr	r3, [pc, #40]	; (13b4 <cliFunc_matrixDebug+0x50>)
    138c:	781a      	ldrb	r2, [r3, #0]
    138e:	2a02      	cmp	r2, #2
    1390:	bf0c      	ite	eq
    1392:	2200      	moveq	r2, #0
    1394:	2202      	movne	r2, #2
	// Invalid argument
	default:
		return;
	}

	print( NL );
    1396:	4808      	ldr	r0, [pc, #32]	; (13b8 <cliFunc_matrixDebug+0x54>)
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
		break;

	// No argument
	case '\0':
		matrixDebugMode = matrixDebugMode != 1 ? 1 : 0;
    1398:	701a      	strb	r2, [r3, #0]
	// Invalid argument
	default:
		return;
	}

	print( NL );
    139a:	f003 f8f1 	bl	4580 <_print>
	info_msg("Matrix Debug Mode: ");
    139e:	4807      	ldr	r0, [pc, #28]	; (13bc <cliFunc_matrixDebug+0x58>)
    13a0:	f003 f8ee 	bl	4580 <_print>
	printInt8( matrixDebugMode );
    13a4:	4b03      	ldr	r3, [pc, #12]	; (13b4 <cliFunc_matrixDebug+0x50>)
    13a6:	7818      	ldrb	r0, [r3, #0]
    13a8:	f003 f91c 	bl	45e4 <printInt8>
}
    13ac:	b003      	add	sp, #12
    13ae:	f85d fb04 	ldr.w	pc, [sp], #4
    13b2:	bf00      	nop
    13b4:	1fffefd6 	.word	0x1fffefd6
    13b8:	00006caf 	.word	0x00006caf
    13bc:	000048f0 	.word	0x000048f0

000013c0 <Matrix_pin>:

// Pin action (Strobe, Sense, Strobe Setup, Sense Setup)
// NOTE: This function is highly dependent upon the organization of the register map
//       Only guaranteed to work with Freescale MK20 series uCs
uint8_t Matrix_pin( GPIO_Pin gpio, Type type )
{
    13c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    13c2:	b2c3      	uxtb	r3, r0
    13c4:	f8ad 0004 	strh.w	r0, [sp, #4]
    13c8:	f3c0 2007 	ubfx	r0, r0, #8, #8
	// Register width is defined as size of a pointer
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
    13cc:	011a      	lsls	r2, r3, #4
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;
    13ce:	eb00 2383 	add.w	r3, r0, r3, lsl #10
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    13d2:	009b      	lsls	r3, r3, #2
    13d4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;

	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
    13d8:	4c28      	ldr	r4, [pc, #160]	; (147c <Matrix_pin+0xbc>)
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    13da:	f503 2392 	add.w	r3, r3, #299008	; 0x49000

	// Operation depends on Type
	switch ( type )
    13de:	2904      	cmp	r1, #4
    13e0:	d849      	bhi.n	1476 <Matrix_pin+0xb6>
    13e2:	e8df f001 	tbb	[pc, r1]
    13e6:	0503      	.short	0x0503
    13e8:	220f      	.short	0x220f
    13ea:	2d          	.byte	0x2d
    13eb:	00          	.byte	0x00
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;

	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
    13ec:	4b24      	ldr	r3, [pc, #144]	; (1480 <Matrix_pin+0xc0>)
    13ee:	e000      	b.n	13f2 <Matrix_pin+0x32>
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
    13f0:	4b24      	ldr	r3, [pc, #144]	; (1484 <Matrix_pin+0xc4>)
	case Type_StrobeOn:
		*GPIO_PSOR |= (1 << gpio.pin);
		break;

	case Type_StrobeOff:
		*GPIO_PCOR |= (1 << gpio.pin);
    13f2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    13f6:	2401      	movs	r4, #1
    13f8:	fa04 f000 	lsl.w	r0, r4, r0
    13fc:	4308      	orrs	r0, r1
    13fe:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
    1402:	e038      	b.n	1476 <Matrix_pin+0xb6>
		break;

	case Type_StrobeSetup:
		// Set as output pin
		*GPIO_PDDR |= (1 << gpio.pin);
    1404:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
    1408:	2501      	movs	r5, #1
    140a:	fa05 f000 	lsl.w	r0, r5, r0
    140e:	4308      	orrs	r0, r1
    1410:	f844 0022 	str.w	r0, [r4, r2, lsl #2]

		// Configure pin with slow slew, high drive strength and GPIO mux
		*PORT_PCR = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1414:	f44f 72a2 	mov.w	r2, #324	; 0x144
    1418:	601a      	str	r2, [r3, #0]

		// Enabling open-drain if specified
		switch ( Matrix_type )
    141a:	4a1b      	ldr	r2, [pc, #108]	; (1488 <Matrix_pin+0xc8>)
    141c:	7812      	ldrb	r2, [r2, #0]
    141e:	2a02      	cmp	r2, #2
    1420:	d129      	bne.n	1476 <Matrix_pin+0xb6>
		{
		case Config_Opendrain:
			*PORT_PCR |= PORT_PCR_ODE;
    1422:	681a      	ldr	r2, [r3, #0]
    1424:	f042 0220 	orr.w	r2, r2, #32
    1428:	e024      	b.n	1474 <Matrix_pin+0xb4>
	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/mk20dx.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
    142a:	4b18      	ldr	r3, [pc, #96]	; (148c <Matrix_pin+0xcc>)
			break;
		}
		break;

	case Type_Sense:
		return *GPIO_PDIR & (1 << gpio.pin) ? 1 : 0;
    142c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    1430:	2201      	movs	r2, #1
    1432:	fa02 f000 	lsl.w	r0, r2, r0
    1436:	4203      	tst	r3, r0
    1438:	bf0c      	ite	eq
    143a:	2000      	moveq	r0, #0
    143c:	2001      	movne	r0, #1
    143e:	e01b      	b.n	1478 <Matrix_pin+0xb8>

	case Type_SenseSetup:
		// Set as input pin
		*GPIO_PDDR &= ~(1 << gpio.pin);
    1440:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
    1444:	2501      	movs	r5, #1
    1446:	fa05 f000 	lsl.w	r0, r5, r0
    144a:	ea21 0000 	bic.w	r0, r1, r0
    144e:	f844 0022 	str.w	r0, [r4, r2, lsl #2]

		// Configure pin with passive filter and GPIO mux
		*PORT_PCR = PORT_PCR_PFE | PORT_PCR_MUX(1);
    1452:	f44f 7288 	mov.w	r2, #272	; 0x110
    1456:	601a      	str	r2, [r3, #0]

		// Pull resistor config
		switch ( Matrix_type )
    1458:	4a0b      	ldr	r2, [pc, #44]	; (1488 <Matrix_pin+0xc8>)
    145a:	7810      	ldrb	r0, [r2, #0]
    145c:	b128      	cbz	r0, 146a <Matrix_pin+0xaa>
    145e:	42a8      	cmp	r0, r5
    1460:	d109      	bne.n	1476 <Matrix_pin+0xb6>
		case Config_Pullup:
			*PORT_PCR |= PORT_PCR_PE | PORT_PCR_PS;
			break;

		case Config_Pulldown:
			*PORT_PCR |= PORT_PCR_PE;
    1462:	681a      	ldr	r2, [r3, #0]
    1464:	f042 0202 	orr.w	r2, r2, #2
    1468:	e004      	b.n	1474 <Matrix_pin+0xb4>

		// Pull resistor config
		switch ( Matrix_type )
		{
		case Config_Pullup:
			*PORT_PCR |= PORT_PCR_PE | PORT_PCR_PS;
    146a:	681a      	ldr	r2, [r3, #0]
    146c:	f042 0203 	orr.w	r2, r2, #3
    1470:	601a      	str	r2, [r3, #0]
			break;
    1472:	e001      	b.n	1478 <Matrix_pin+0xb8>

		case Config_Pulldown:
			*PORT_PCR |= PORT_PCR_PE;
    1474:	601a      	str	r2, [r3, #0]
			break;
		}
		break;
	}

	return 0;
    1476:	2000      	movs	r0, #0
}
    1478:	b003      	add	sp, #12
    147a:	bd30      	pop	{r4, r5, pc}
    147c:	400ff014 	.word	0x400ff014
    1480:	400ff004 	.word	0x400ff004
    1484:	400ff008 	.word	0x400ff008
    1488:	1fffe9b0 	.word	0x1fffe9b0
    148c:	400ff010 	.word	0x400ff010

00001490 <Matrix_setup>:

// Setup GPIO pins for matrix scanning
void Matrix_setup()
{
    1490:	b570      	push	{r4, r5, r6, lr}
	// Register Matrix CLI dictionary
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    1492:	492d      	ldr	r1, [pc, #180]	; (1548 <Matrix_setup+0xb8>)
    1494:	482d      	ldr	r0, [pc, #180]	; (154c <Matrix_setup+0xbc>)
    1496:	f002 fe33 	bl	4100 <CLI_registerDictionary>

	info_msg("Columns:  ");
    149a:	482d      	ldr	r0, [pc, #180]	; (1550 <Matrix_setup+0xc0>)
    149c:	f003 f870 	bl	4580 <_print>
	printHex( Matrix_colsNum );
    14a0:	2009      	movs	r0, #9
    14a2:	2101      	movs	r1, #1
    14a4:	f003 f8f5 	bl	4692 <printHex_op>
    14a8:	2400      	movs	r4, #0

	// Setup Strobe Pins
	for ( uint8_t pin = 0; pin < Matrix_colsNum; pin++ )
	{
		Matrix_pin( Matrix_cols[ pin ], Type_StrobeSetup );
    14aa:	4b2a      	ldr	r3, [pc, #168]	; (1554 <Matrix_setup+0xc4>)
    14ac:	f813 2014 	ldrb.w	r2, [r3, r4, lsl #1]
    14b0:	eb03 0344 	add.w	r3, r3, r4, lsl #1
    14b4:	2102      	movs	r1, #2
    14b6:	7858      	ldrb	r0, [r3, #1]
    14b8:	3401      	adds	r4, #1
    14ba:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    14be:	f7ff ff7f 	bl	13c0 <Matrix_pin>

	info_msg("Columns:  ");
	printHex( Matrix_colsNum );

	// Setup Strobe Pins
	for ( uint8_t pin = 0; pin < Matrix_colsNum; pin++ )
    14c2:	2c09      	cmp	r4, #9
    14c4:	d1f1      	bne.n	14aa <Matrix_setup+0x1a>
	{
		Matrix_pin( Matrix_cols[ pin ], Type_StrobeSetup );
	}

	print( NL );
    14c6:	4824      	ldr	r0, [pc, #144]	; (1558 <Matrix_setup+0xc8>)
    14c8:	f003 f85a 	bl	4580 <_print>
	info_msg("Rows:     ");
    14cc:	4823      	ldr	r0, [pc, #140]	; (155c <Matrix_setup+0xcc>)
    14ce:	f003 f857 	bl	4580 <_print>
	printHex( Matrix_rowsNum );
    14d2:	2007      	movs	r0, #7
    14d4:	2101      	movs	r1, #1
    14d6:	f003 f8dc 	bl	4692 <printHex_op>
    14da:	2400      	movs	r4, #0

	// Setup Sense Pins
	for ( uint8_t pin = 0; pin < Matrix_rowsNum; pin++ )
	{
		Matrix_pin( Matrix_rows[ pin ], Type_SenseSetup );
    14dc:	4b20      	ldr	r3, [pc, #128]	; (1560 <Matrix_setup+0xd0>)
    14de:	f813 2014 	ldrb.w	r2, [r3, r4, lsl #1]
    14e2:	eb03 0344 	add.w	r3, r3, r4, lsl #1
    14e6:	2104      	movs	r1, #4
    14e8:	7858      	ldrb	r0, [r3, #1]
    14ea:	3401      	adds	r4, #1
    14ec:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
    14f0:	f7ff ff66 	bl	13c0 <Matrix_pin>
	print( NL );
	info_msg("Rows:     ");
	printHex( Matrix_rowsNum );

	// Setup Sense Pins
	for ( uint8_t pin = 0; pin < Matrix_rowsNum; pin++ )
    14f4:	2c07      	cmp	r4, #7
    14f6:	d1f1      	bne.n	14dc <Matrix_setup+0x4c>
	{
		Matrix_pin( Matrix_rows[ pin ], Type_SenseSetup );
	}

	print( NL );
    14f8:	4817      	ldr	r0, [pc, #92]	; (1558 <Matrix_setup+0xc8>)
    14fa:	f003 f841 	bl	4580 <_print>
	info_msg("Max Keys: ");
    14fe:	4819      	ldr	r0, [pc, #100]	; (1564 <Matrix_setup+0xd4>)
    1500:	f003 f83e 	bl	4580 <_print>
	printHex( Matrix_maxKeys );
    1504:	2101      	movs	r1, #1
    1506:	203f      	movs	r0, #63	; 0x3f
    1508:	f003 f8c3 	bl	4692 <printHex_op>
	print( NL );
    150c:	4812      	ldr	r0, [pc, #72]	; (1558 <Matrix_setup+0xc8>)
    150e:	f003 f837 	bl	4580 <_print>
    1512:	2100      	movs	r1, #0
    1514:	460a      	mov	r2, r1
    1516:	4d14      	ldr	r5, [pc, #80]	; (1568 <Matrix_setup+0xd8>)
	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    1518:	ebc2 06c2 	rsb	r6, r2, r2, lsl #3
    151c:	1948      	adds	r0, r1, r5
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    151e:	2300      	movs	r3, #0
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    1520:	19ac      	adds	r4, r5, r6
    1522:	3201      	adds	r2, #1
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    1524:	7103      	strb	r3, [r0, #4]
		Matrix_scanArray[ item ].curState         = KeyState_Off;
    1526:	7143      	strb	r3, [r0, #5]
	info_msg("Max Keys: ");
	printHex( Matrix_maxKeys );
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    1528:	2a3f      	cmp	r2, #63	; 0x3f
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    152a:	55ab      	strb	r3, [r5, r6]
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold_define; // Start at 'off' steady state
    152c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
	{
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
		Matrix_scanArray[ item ].curState         = KeyState_Off;
		Matrix_scanArray[ item ].activeCount      = 0;
    1530:	7063      	strb	r3, [r4, #1]
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold_define; // Start at 'off' steady state
    1532:	70a5      	strb	r5, [r4, #2]
    1534:	70e5      	strb	r5, [r4, #3]
    1536:	f101 0107 	add.w	r1, r1, #7
		Matrix_scanArray[ item ].prevDecisionTime = 0;
    153a:	7183      	strb	r3, [r0, #6]
	info_msg("Max Keys: ");
	printHex( Matrix_maxKeys );
	print( NL );

	// Clear out Debounce Array
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    153c:	d1eb      	bne.n	1516 <Matrix_setup+0x86>
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold_define; // Start at 'off' steady state
		Matrix_scanArray[ item ].prevDecisionTime = 0;
	}

	// Clear scan stats counters
	matrixMaxScans  = 0;
    153e:	4a0b      	ldr	r2, [pc, #44]	; (156c <Matrix_setup+0xdc>)
    1540:	8013      	strh	r3, [r2, #0]
	matrixPrevScans = 0;
    1542:	4a0b      	ldr	r2, [pc, #44]	; (1570 <Matrix_setup+0xe0>)
    1544:	8013      	strh	r3, [r2, #0]
    1546:	bd70      	pop	{r4, r5, r6, pc}
    1548:	00004b4d 	.word	0x00004b4d
    154c:	00004b64 	.word	0x00004b64
    1550:	00004916 	.word	0x00004916
    1554:	1fffe990 	.word	0x1fffe990
    1558:	00006caf 	.word	0x00006caf
    155c:	00004933 	.word	0x00004933
    1560:	1fffe9a2 	.word	0x1fffe9a2
    1564:	00004950 	.word	0x00004950
    1568:	1ffff765 	.word	0x1ffff765
    156c:	1fffefd4 	.word	0x1fffefd4
    1570:	1fffefd2 	.word	0x1fffefd2

00001574 <Matrix_keyPositionDebug>:
}

void Matrix_keyPositionDebug( KeyPosition pos )
{
	// Depending on the state, use a different flag + color
	switch ( pos )
    1574:	2803      	cmp	r0, #3
    1576:	d80b      	bhi.n	1590 <Matrix_keyPositionDebug+0x1c>
    1578:	e8df f000 	tbb	[pc, r0]
    157c:	08060402 	.word	0x08060402
	{
	case KeyState_Off:
		print("\033[1mO\033[0m");
    1580:	4805      	ldr	r0, [pc, #20]	; (1598 <Matrix_keyPositionDebug+0x24>)
    1582:	e006      	b.n	1592 <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Press:
		print("\033[1;33mP\033[0m");
    1584:	4805      	ldr	r0, [pc, #20]	; (159c <Matrix_keyPositionDebug+0x28>)
    1586:	e004      	b.n	1592 <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Hold:
		print("\033[1;32mH\033[0m");
    1588:	4805      	ldr	r0, [pc, #20]	; (15a0 <Matrix_keyPositionDebug+0x2c>)
    158a:	e002      	b.n	1592 <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Release:
		print("\033[1;35mR\033[0m");
    158c:	4805      	ldr	r0, [pc, #20]	; (15a4 <Matrix_keyPositionDebug+0x30>)
    158e:	e000      	b.n	1592 <Matrix_keyPositionDebug+0x1e>
		break;

	case KeyState_Invalid:
	default:
		print("\033[1;31mI\033[0m");
    1590:	4805      	ldr	r0, [pc, #20]	; (15a8 <Matrix_keyPositionDebug+0x34>)
    1592:	f002 bff5 	b.w	4580 <_print>
    1596:	bf00      	nop
    1598:	0000496d 	.word	0x0000496d
    159c:	00004977 	.word	0x00004977
    15a0:	00004984 	.word	0x00004984
    15a4:	00004991 	.word	0x00004991
    15a8:	0000499e 	.word	0x0000499e

000015ac <Matrix_scan>:
	if ( !( Matrix_divCounter++ & (1 << ( DebounceThrottleDiv_define - 1 )) ) )
		return;
#endif

	// Increment stats counters
	if ( scanNum > matrixMaxScans ) matrixMaxScans = scanNum;
    15ac:	4b8f      	ldr	r3, [pc, #572]	; (17ec <Matrix_scan+0x240>)


// Scan the matrix for keypresses
// NOTE: scanNum should be reset to 0 after a USB send (to reset all the counters)
void Matrix_scan( uint16_t scanNum )
{
    15ae:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if ( !( Matrix_divCounter++ & (1 << ( DebounceThrottleDiv_define - 1 )) ) )
		return;
#endif

	// Increment stats counters
	if ( scanNum > matrixMaxScans ) matrixMaxScans = scanNum;
    15b2:	881a      	ldrh	r2, [r3, #0]
    15b4:	4282      	cmp	r2, r0
    15b6:	bf38      	it	cc
    15b8:	8018      	strhcc	r0, [r3, #0]


// Scan the matrix for keypresses
// NOTE: scanNum should be reset to 0 after a USB send (to reset all the counters)
void Matrix_scan( uint16_t scanNum )
{
    15ba:	4607      	mov	r7, r0
    15bc:	4b8c      	ldr	r3, [pc, #560]	; (17f0 <Matrix_scan+0x244>)
		return;
#endif

	// Increment stats counters
	if ( scanNum > matrixMaxScans ) matrixMaxScans = scanNum;
	if ( scanNum == 0 )
    15be:	b920      	cbnz	r0, 15ca <Matrix_scan+0x1e>
	{
		matrixPrevScans = matrixCurScans;
    15c0:	4a8c      	ldr	r2, [pc, #560]	; (17f4 <Matrix_scan+0x248>)
    15c2:	8819      	ldrh	r1, [r3, #0]
    15c4:	8011      	strh	r1, [r2, #0]
		matrixCurScans = 0;
    15c6:	8018      	strh	r0, [r3, #0]
    15c8:	e002      	b.n	15d0 <Matrix_scan+0x24>
	}
	else
	{
		matrixCurScans++;
    15ca:	881a      	ldrh	r2, [r3, #0]
    15cc:	3201      	adds	r2, #1
    15ce:	801a      	strh	r2, [r3, #0]
	}

	// Read systick for event scheduling
	uint8_t currentTime = (uint8_t)systick_millis_count;
    15d0:	4b89      	ldr	r3, [pc, #548]	; (17f8 <Matrix_scan+0x24c>)
    15d2:	681b      	ldr	r3, [r3, #0]
    15d4:	2500      	movs	r5, #0
    15d6:	fa5f fb83 	uxtb.w	fp, r3

	// For each strobe, scan each of the sense pins
	for ( uint8_t strobe = 0; strobe < Matrix_colsNum; strobe++ )
	{
		// Strobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOn );
    15da:	f8df 9234 	ldr.w	r9, [pc, #564]	; 1810 <Matrix_scan+0x264>
    15de:	ea4f 0a45 	mov.w	sl, r5, lsl #1
    15e2:	eb09 020a 	add.w	r2, r9, sl
    15e6:	f819 3015 	ldrb.w	r3, [r9, r5, lsl #1]
    15ea:	7850      	ldrb	r0, [r2, #1]
    15ec:	2100      	movs	r1, #0
    15ee:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    15f2:	f7ff fee5 	bl	13c0 <Matrix_pin>
    15f6:	b2ee      	uxtb	r6, r5
    15f8:	f04f 0800 	mov.w	r8, #0
		// Scan each of the sense pins
		for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
		{
			// Key position
			uint8_t key = Matrix_colsNum * sense + strobe;
			KeyState *state = &Matrix_scanArray[ key ];
    15fc:	4b7f      	ldr	r3, [pc, #508]	; (17fc <Matrix_scan+0x250>)
    15fe:	ebc6 02c6 	rsb	r2, r6, r6, lsl #3
    1602:	18d4      	adds	r4, r2, r3

			// If first scan, reset state
			if ( scanNum == 0 )
    1604:	b91f      	cbnz	r7, 160e <Matrix_scan+0x62>
			{
				// Set previous state, and reset current state
				state->prevState = state->curState;
    1606:	7961      	ldrb	r1, [r4, #5]
    1608:	7121      	strb	r1, [r4, #4]
				state->curState  = KeyState_Invalid;
    160a:	2104      	movs	r1, #4
    160c:	7161      	strb	r1, [r4, #5]
			// This means there is a maximum of scan 13 cycles on a perfect off to on transition
			//  (coming from a steady state 0xFFFF off scans)
			// Somewhat longer with switch bounciness
			// The advantage of this is that the count is ongoing and never needs to be reset
			// State still needs to be kept track of to deal with what to send to the Macro module
			if ( Matrix_pin( Matrix_rows[ sense ], Type_Sense ) )
    160e:	497c      	ldr	r1, [pc, #496]	; (1800 <Matrix_scan+0x254>)
    1610:	f811 0018 	ldrb.w	r0, [r1, r8, lsl #1]
    1614:	eb01 0148 	add.w	r1, r1, r8, lsl #1
    1618:	7849      	ldrb	r1, [r1, #1]
    161a:	9201      	str	r2, [sp, #4]
    161c:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
    1620:	2103      	movs	r1, #3
    1622:	9300      	str	r3, [sp, #0]
    1624:	f7ff fecc 	bl	13c0 <Matrix_pin>
    1628:	8821      	ldrh	r1, [r4, #0]
    162a:	f8b4 c002 	ldrh.w	ip, [r4, #2]
    162e:	9a01      	ldr	r2, [sp, #4]
    1630:	9b00      	ldr	r3, [sp, #0]
    1632:	f64f 7eff 	movw	lr, #65535	; 0xffff
    1636:	b148      	cbz	r0, 164c <Matrix_scan+0xa0>
			{
				// Only update if not going to wrap around
				if ( state->activeCount < DebounceDivThreshold_define ) state->activeCount += 1;
    1638:	4571      	cmp	r1, lr
    163a:	bf18      	it	ne
    163c:	3101      	addne	r1, #1
				state->inactiveCount >>= 1;
    163e:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
			// The advantage of this is that the count is ongoing and never needs to be reset
			// State still needs to be kept track of to deal with what to send to the Macro module
			if ( Matrix_pin( Matrix_rows[ sense ], Type_Sense ) )
			{
				// Only update if not going to wrap around
				if ( state->activeCount < DebounceDivThreshold_define ) state->activeCount += 1;
    1642:	bf18      	it	ne
    1644:	52d1      	strhne	r1, [r2, r3]
				state->inactiveCount >>= 1;
    1646:	f8a4 c002 	strh.w	ip, [r4, #2]
    164a:	e009      	b.n	1660 <Matrix_scan+0xb4>
			}
			// Signal Not Detected
			else
			{
				// Only update if not going to wrap around
				if ( state->inactiveCount < DebounceDivThreshold_define ) state->inactiveCount += 1;
    164c:	45f4      	cmp	ip, lr
    164e:	bf18      	it	ne
    1650:	f10c 0c01 	addne.w	ip, ip, #1
				state->activeCount >>= 1;
    1654:	ea4f 0151 	mov.w	r1, r1, lsr #1
			}
			// Signal Not Detected
			else
			{
				// Only update if not going to wrap around
				if ( state->inactiveCount < DebounceDivThreshold_define ) state->inactiveCount += 1;
    1658:	bf18      	it	ne
    165a:	f8a4 c002 	strhne.w	ip, [r4, #2]
				state->activeCount >>= 1;
    165e:	52d1      	strh	r1, [r2, r3]
			// Check for state change if it hasn't been set
			// But only if enough time has passed since last state change
			// Only check if the minimum number of scans has been met
			//   the current state is invalid
			//   and either active or inactive count is over the debounce threshold
			if ( state->curState == KeyState_Invalid )
    1660:	7963      	ldrb	r3, [r4, #5]
    1662:	2b04      	cmp	r3, #4
    1664:	d145      	bne.n	16f2 <Matrix_scan+0x146>
			{
				// Determine time since last decision
				uint8_t lastTransition = currentTime - state->prevDecisionTime;
    1666:	79a2      	ldrb	r2, [r4, #6]

				// Attempt state transition
				switch ( state->prevState )
    1668:	7923      	ldrb	r3, [r4, #4]
			//   the current state is invalid
			//   and either active or inactive count is over the debounce threshold
			if ( state->curState == KeyState_Invalid )
			{
				// Determine time since last decision
				uint8_t lastTransition = currentTime - state->prevDecisionTime;
    166a:	ebc2 020b 	rsb	r2, r2, fp
    166e:	b2d2      	uxtb	r2, r2

				// Attempt state transition
				switch ( state->prevState )
    1670:	2b03      	cmp	r3, #3
    1672:	d81a      	bhi.n	16aa <Matrix_scan+0xfe>
    1674:	e8df f003 	tbb	[pc, r3]
    1678:	0c02020c 	.word	0x0c02020c
				{
				case KeyState_Press:
				case KeyState_Hold:
					if ( state->activeCount > state->inactiveCount )
    167c:	8820      	ldrh	r0, [r4, #0]
    167e:	8861      	ldrh	r1, [r4, #2]
    1680:	4288      	cmp	r0, r1
    1682:	d901      	bls.n	1688 <Matrix_scan+0xdc>
					{
						state->curState = KeyState_Hold;
    1684:	2302      	movs	r3, #2
    1686:	e00c      	b.n	16a2 <Matrix_scan+0xf6>
					}
					else
					{
						// If not enough time has passed since Hold
						// Keep previous state
						if ( lastTransition < MinDebounceTime_define )
    1688:	2a04      	cmp	r2, #4
    168a:	d907      	bls.n	169c <Matrix_scan+0xf0>
							//warn_print("FAST Release stopped");
							state->curState = state->prevState;
							continue;
						}

						state->curState = KeyState_Release;
    168c:	2303      	movs	r3, #3
    168e:	e008      	b.n	16a2 <Matrix_scan+0xf6>
					}
					break;

				case KeyState_Release:
				case KeyState_Off:
					if ( state->activeCount > state->inactiveCount )
    1690:	8820      	ldrh	r0, [r4, #0]
    1692:	8861      	ldrh	r1, [r4, #2]
    1694:	4288      	cmp	r0, r1
    1696:	d906      	bls.n	16a6 <Matrix_scan+0xfa>
					{
						// If not enough time has passed since Hold
						// Keep previous state
						if ( lastTransition < MinDebounceTime_define )
    1698:	2a04      	cmp	r2, #4
    169a:	d801      	bhi.n	16a0 <Matrix_scan+0xf4>
						{
							//warn_print("FAST Press stopped");
							state->curState = state->prevState;
    169c:	7163      	strb	r3, [r4, #5]
							continue;
    169e:	e028      	b.n	16f2 <Matrix_scan+0x146>
						}

						state->curState = KeyState_Press;
    16a0:	2301      	movs	r3, #1
    16a2:	7163      	strb	r3, [r4, #5]
    16a4:	e004      	b.n	16b0 <Matrix_scan+0x104>
					}
					else
					{
						state->curState = KeyState_Off;
    16a6:	2300      	movs	r3, #0
    16a8:	e7fb      	b.n	16a2 <Matrix_scan+0xf6>
					}
					break;

				case KeyState_Invalid:
				default:
					erro_print("Matrix scan bug!! Report me!");
    16aa:	4856      	ldr	r0, [pc, #344]	; (1804 <Matrix_scan+0x258>)
    16ac:	f002 ff68 	bl	4580 <_print>
					break;
				}

				// Update decision time
				state->prevDecisionTime = currentTime;
    16b0:	f884 b006 	strb.w	fp, [r4, #6]

				// Send keystate to macro module
				Macro_keyState( key, state->curState );
    16b4:	4630      	mov	r0, r6
    16b6:	7961      	ldrb	r1, [r4, #5]
    16b8:	f000 fd3e 	bl	2138 <Macro_keyState>

				// Matrix Debug, only if there is a state change
				if ( matrixDebugMode && state->curState != state->prevState )
    16bc:	4b52      	ldr	r3, [pc, #328]	; (1808 <Matrix_scan+0x25c>)
    16be:	781b      	ldrb	r3, [r3, #0]
    16c0:	b1bb      	cbz	r3, 16f2 <Matrix_scan+0x146>
    16c2:	7961      	ldrb	r1, [r4, #5]
    16c4:	7922      	ldrb	r2, [r4, #4]
    16c6:	428a      	cmp	r2, r1
    16c8:	d013      	beq.n	16f2 <Matrix_scan+0x146>
				{
					// Basic debug output
					if ( matrixDebugMode == 1 && state->curState == KeyState_Press )
    16ca:	2b01      	cmp	r3, #1
    16cc:	d105      	bne.n	16da <Matrix_scan+0x12e>
    16ce:	2901      	cmp	r1, #1
    16d0:	d10f      	bne.n	16f2 <Matrix_scan+0x146>
					{
						printHex( key );
    16d2:	4630      	mov	r0, r6
    16d4:	f002 ffdd 	bl	4692 <printHex_op>
    16d8:	e008      	b.n	16ec <Matrix_scan+0x140>
						print(" ");
					}
					// State transition debug output
					else if ( matrixDebugMode == 2 )
    16da:	2b02      	cmp	r3, #2
    16dc:	d109      	bne.n	16f2 <Matrix_scan+0x146>
					{
						printHex( key );
    16de:	4630      	mov	r0, r6
    16e0:	2101      	movs	r1, #1
    16e2:	f002 ffd6 	bl	4692 <printHex_op>
						Matrix_keyPositionDebug( state->curState );
    16e6:	7960      	ldrb	r0, [r4, #5]
    16e8:	f7ff ff44 	bl	1574 <Matrix_keyPositionDebug>
						print(" ");
    16ec:	4847      	ldr	r0, [pc, #284]	; (180c <Matrix_scan+0x260>)
    16ee:	f002 ff47 	bl	4580 <_print>
    16f2:	f108 0801 	add.w	r8, r8, #1
    16f6:	3609      	adds	r6, #9
	{
		// Strobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOn );

		// Scan each of the sense pins
		for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
    16f8:	f1b8 0f07 	cmp.w	r8, #7
    16fc:	b2f6      	uxtb	r6, r6
    16fe:	f47f af7d 	bne.w	15fc <Matrix_scan+0x50>
				}
			}
		}

		// Unstrobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOff );
    1702:	4a43      	ldr	r2, [pc, #268]	; (1810 <Matrix_scan+0x264>)
    1704:	f819 3015 	ldrb.w	r3, [r9, r5, lsl #1]
    1708:	4452      	add	r2, sl
    170a:	2101      	movs	r1, #1
    170c:	7850      	ldrb	r0, [r2, #1]
    170e:	3501      	adds	r5, #1
    1710:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    1714:	f7ff fe54 	bl	13c0 <Matrix_pin>

	// Read systick for event scheduling
	uint8_t currentTime = (uint8_t)systick_millis_count;

	// For each strobe, scan each of the sense pins
	for ( uint8_t strobe = 0; strobe < Matrix_colsNum; strobe++ )
    1718:	2d09      	cmp	r5, #9
    171a:	f47f af5e 	bne.w	15da <Matrix_scan+0x2e>
		// Unstrobe Pin
		Matrix_pin( Matrix_cols[ strobe ], Type_StrobeOff );
	}

	// State Table Output Debug
	if ( matrixDebugStateCounter > 0 )
    171e:	4b3d      	ldr	r3, [pc, #244]	; (1814 <Matrix_scan+0x268>)
    1720:	881a      	ldrh	r2, [r3, #0]
    1722:	2a00      	cmp	r2, #0
    1724:	d05e      	beq.n	17e4 <Matrix_scan+0x238>
	{
		// Decrement counter
		matrixDebugStateCounter--;
    1726:	3a01      	subs	r2, #1

		// Output stats on number of scans being done per USB send
		print( NL );
    1728:	483b      	ldr	r0, [pc, #236]	; (1818 <Matrix_scan+0x26c>)

	// State Table Output Debug
	if ( matrixDebugStateCounter > 0 )
	{
		// Decrement counter
		matrixDebugStateCounter--;
    172a:	801a      	strh	r2, [r3, #0]

		// Output stats on number of scans being done per USB send
		print( NL );
    172c:	f002 ff28 	bl	4580 <_print>
		info_msg("Max scans:      ");
    1730:	483a      	ldr	r0, [pc, #232]	; (181c <Matrix_scan+0x270>)
    1732:	f002 ff25 	bl	4580 <_print>
		printHex( matrixMaxScans );
    1736:	4b2d      	ldr	r3, [pc, #180]	; (17ec <Matrix_scan+0x240>)
    1738:	2101      	movs	r1, #1
    173a:	8818      	ldrh	r0, [r3, #0]
    173c:	f002 ffa9 	bl	4692 <printHex_op>
		print( NL );
    1740:	4835      	ldr	r0, [pc, #212]	; (1818 <Matrix_scan+0x26c>)
    1742:	f002 ff1d 	bl	4580 <_print>
		info_msg("Previous scans: ");
    1746:	4836      	ldr	r0, [pc, #216]	; (1820 <Matrix_scan+0x274>)
    1748:	f002 ff1a 	bl	4580 <_print>
		printHex( matrixPrevScans );
    174c:	4b29      	ldr	r3, [pc, #164]	; (17f4 <Matrix_scan+0x248>)
    174e:	2101      	movs	r1, #1
    1750:	8818      	ldrh	r0, [r3, #0]
    1752:	f002 ff9e 	bl	4692 <printHex_op>
		print( NL );
    1756:	4830      	ldr	r0, [pc, #192]	; (1818 <Matrix_scan+0x26c>)
    1758:	f002 ff12 	bl	4580 <_print>

		// Output current scan number
		info_msg("Scan Number:    ");
    175c:	4831      	ldr	r0, [pc, #196]	; (1824 <Matrix_scan+0x278>)
    175e:	f002 ff0f 	bl	4580 <_print>
		printHex( scanNum );
    1762:	2101      	movs	r1, #1
    1764:	4638      	mov	r0, r7
    1766:	f002 ff94 	bl	4692 <printHex_op>
		print( NL );
    176a:	482b      	ldr	r0, [pc, #172]	; (1818 <Matrix_scan+0x26c>)
    176c:	f002 ff08 	bl	4580 <_print>

		// Display the state info for each key
		print("<key>:<previous state><current state> <active count> <inactive count>");
    1770:	482d      	ldr	r0, [pc, #180]	; (1828 <Matrix_scan+0x27c>)
    1772:	f002 ff05 	bl	4580 <_print>
    1776:	2400      	movs	r4, #0
		for ( uint8_t key = 0; key < Matrix_maxKeys; key++ )
		{
			// Every 4 keys, put a newline
			if ( key % 4 == 0 )
    1778:	07a3      	lsls	r3, r4, #30
    177a:	d102      	bne.n	1782 <Matrix_scan+0x1d6>
				print( NL );
    177c:	4826      	ldr	r0, [pc, #152]	; (1818 <Matrix_scan+0x26c>)
    177e:	f002 feff 	bl	4580 <_print>

			print("\033[1m0x");
    1782:	482a      	ldr	r0, [pc, #168]	; (182c <Matrix_scan+0x280>)
    1784:	f002 fefc 	bl	4580 <_print>
			printHex_op( key, 2 );
    1788:	2102      	movs	r1, #2
    178a:	b2a0      	uxth	r0, r4
    178c:	f002 ff81 	bl	4692 <printHex_op>
			print("\033[0m");
    1790:	4827      	ldr	r0, [pc, #156]	; (1830 <Matrix_scan+0x284>)
    1792:	f002 fef5 	bl	4580 <_print>
			print(":");
    1796:	4827      	ldr	r0, [pc, #156]	; (1834 <Matrix_scan+0x288>)
    1798:	f002 fef2 	bl	4580 <_print>
    179c:	4917      	ldr	r1, [pc, #92]	; (17fc <Matrix_scan+0x250>)
    179e:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
    17a2:	440d      	add	r5, r1
    17a4:	3401      	adds	r4, #1
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    17a6:	7928      	ldrb	r0, [r5, #4]
    17a8:	f7ff fee4 	bl	1574 <Matrix_keyPositionDebug>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    17ac:	7968      	ldrb	r0, [r5, #5]
    17ae:	f7ff fee1 	bl	1574 <Matrix_keyPositionDebug>
			print(" 0x");
    17b2:	4821      	ldr	r0, [pc, #132]	; (1838 <Matrix_scan+0x28c>)
    17b4:	f002 fee4 	bl	4580 <_print>
			printHex_op( Matrix_scanArray[ key ].activeCount, 4 );
    17b8:	2104      	movs	r1, #4
    17ba:	8828      	ldrh	r0, [r5, #0]
    17bc:	f002 ff69 	bl	4692 <printHex_op>
			print(" 0x");
    17c0:	481d      	ldr	r0, [pc, #116]	; (1838 <Matrix_scan+0x28c>)
    17c2:	f002 fedd 	bl	4580 <_print>
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 4 );
    17c6:	8868      	ldrh	r0, [r5, #2]
    17c8:	2104      	movs	r1, #4
    17ca:	f002 ff62 	bl	4692 <printHex_op>
			print(" ");
    17ce:	480f      	ldr	r0, [pc, #60]	; (180c <Matrix_scan+0x260>)
    17d0:	f002 fed6 	bl	4580 <_print>
		printHex( scanNum );
		print( NL );

		// Display the state info for each key
		print("<key>:<previous state><current state> <active count> <inactive count>");
		for ( uint8_t key = 0; key < Matrix_maxKeys; key++ )
    17d4:	2c3f      	cmp	r4, #63	; 0x3f
    17d6:	d1cf      	bne.n	1778 <Matrix_scan+0x1cc>
			print(" 0x");
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 4 );
			print(" ");
		}

		print( NL );
    17d8:	480f      	ldr	r0, [pc, #60]	; (1818 <Matrix_scan+0x26c>)
	}
}
    17da:	b003      	add	sp, #12
    17dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			print(" 0x");
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 4 );
			print(" ");
		}

		print( NL );
    17e0:	f002 bece 	b.w	4580 <_print>
	}
}
    17e4:	b003      	add	sp, #12
    17e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    17ea:	bf00      	nop
    17ec:	1fffefd4 	.word	0x1fffefd4
    17f0:	1fffefd0 	.word	0x1fffefd0
    17f4:	1fffefd2 	.word	0x1fffefd2
    17f8:	1fffefcc 	.word	0x1fffefcc
    17fc:	1ffff765 	.word	0x1ffff765
    1800:	1fffe9a2 	.word	0x1fffe9a2
    1804:	000049ab 	.word	0x000049ab
    1808:	1fffefd6 	.word	0x1fffefd6
    180c:	00004a00 	.word	0x00004a00
    1810:	1fffe990 	.word	0x1fffe990
    1814:	1fffefd8 	.word	0x1fffefd8
    1818:	00006caf 	.word	0x00006caf
    181c:	000049df 	.word	0x000049df
    1820:	00004a02 	.word	0x00004a02
    1824:	00004a25 	.word	0x00004a25
    1828:	00004a48 	.word	0x00004a48
    182c:	00004a8e 	.word	0x00004a8e
    1830:	00005033 	.word	0x00005033
    1834:	00004a95 	.word	0x00004a95
    1838:	00004a97 	.word	0x00004a97

0000183c <cliFunc_echo>:

// ----- CLI Command Functions -----

// XXX Just an example command showing how to parse arguments (more complex than generally needed)
void cliFunc_echo( char* args )
{
    183c:	b507      	push	{r0, r1, r2, lr}
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    183e:	9001      	str	r0, [sp, #4]

	// Parse args until a \0 is found
	while ( 1 )
	{
		print( NL ); // No \r\n by default after the command is entered
    1840:	4808      	ldr	r0, [pc, #32]	; (1864 <cliFunc_echo+0x28>)
    1842:	f002 fe9d 	bl	4580 <_print>

		curArgs = arg2Ptr; // Use the previous 2nd arg pointer to separate the next arg from the list
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    1846:	9801      	ldr	r0, [sp, #4]
    1848:	4669      	mov	r1, sp
    184a:	aa01      	add	r2, sp, #4
    184c:	f002 fbe2 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    1850:	9800      	ldr	r0, [sp, #0]
    1852:	7803      	ldrb	r3, [r0, #0]
    1854:	b113      	cbz	r3, 185c <cliFunc_echo+0x20>
			break;

		// Print out the arg
		dPrint( arg1Ptr );
    1856:	f001 fb7d 	bl	2f54 <Output_putstr>
	}
    185a:	e7f1      	b.n	1840 <cliFunc_echo+0x4>
}
    185c:	b003      	add	sp, #12
    185e:	f85d fb04 	ldr.w	pc, [sp], #4
    1862:	bf00      	nop
    1864:	00006caf 	.word	0x00006caf

00001868 <Scan_setup>:

// ----- Functions -----

// Setup
inline void Scan_setup()
{
    1868:	b508      	push	{r3, lr}
	// Register Scan CLI dictionary
	CLI_registerDictionary( scanCLIDict, scanCLIDictName );
    186a:	4805      	ldr	r0, [pc, #20]	; (1880 <Scan_setup+0x18>)
    186c:	4905      	ldr	r1, [pc, #20]	; (1884 <Scan_setup+0x1c>)
    186e:	f002 fc47 	bl	4100 <CLI_registerDictionary>

	// Setup GPIO pins for matrix scanning
	Matrix_setup();
    1872:	f7ff fe0d 	bl	1490 <Matrix_setup>

	// Reset scan count
	Scan_scanCount = 0;
    1876:	4b04      	ldr	r3, [pc, #16]	; (1888 <Scan_setup+0x20>)
    1878:	2200      	movs	r2, #0
    187a:	801a      	strh	r2, [r3, #0]
    187c:	bd08      	pop	{r3, pc}
    187e:	bf00      	nop
    1880:	00004c7c 	.word	0x00004c7c
    1884:	00004b88 	.word	0x00004b88
    1888:	1fffefdc 	.word	0x1fffefdc

0000188c <Scan_loop>:
}


// Main Detection Loop
inline uint8_t Scan_loop()
{
    188c:	b508      	push	{r3, lr}
	Matrix_scan( Scan_scanCount++ );
    188e:	4b04      	ldr	r3, [pc, #16]	; (18a0 <Scan_loop+0x14>)
    1890:	8818      	ldrh	r0, [r3, #0]
    1892:	1c42      	adds	r2, r0, #1
    1894:	801a      	strh	r2, [r3, #0]
    1896:	f7ff fe89 	bl	15ac <Matrix_scan>

	return 0;
}
    189a:	2000      	movs	r0, #0
    189c:	bd08      	pop	{r3, pc}
    189e:	bf00      	nop
    18a0:	1fffefdc 	.word	0x1fffefdc

000018a4 <Scan_finishedWithMacro>:


// Signal from Macro Module that all keys have been processed (that it knows about)
inline void Scan_finishedWithMacro( uint8_t sentKeys )
{
    18a4:	4770      	bx	lr
    18a6:	0000      	movs	r0, r0

000018a8 <Scan_finishedWithOutput>:
// Signal from Output Module that all keys have been processed (that it knows about)
inline void Scan_finishedWithOutput( uint8_t sentKeys )
{
	// Reset scan loop indicator (resets each key debounce state)
	// TODO should this occur after USB send or Macro processing?
	Scan_scanCount = 0;
    18a8:	4b01      	ldr	r3, [pc, #4]	; (18b0 <Scan_finishedWithOutput+0x8>)
    18aa:	2200      	movs	r2, #0
    18ac:	801a      	strh	r2, [r3, #0]
    18ae:	4770      	bx	lr
    18b0:	1fffefdc 	.word	0x1fffefdc

000018b4 <CustomAction_action1_capability>:
// Refer to kll.h in Macros/PartialMap for state and stateType information
void CustomAction_action1_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	// XXX This is required for debug cli to give you a list of capabilities
	if ( stateType == 0xFF && state == 0xFF )
    18b4:	29ff      	cmp	r1, #255	; 0xff
    18b6:	d103      	bne.n	18c0 <CustomAction_action1_capability+0xc>
    18b8:	28ff      	cmp	r0, #255	; 0xff
    18ba:	d101      	bne.n	18c0 <CustomAction_action1_capability+0xc>
	{
		print("CustomAction_action1_capability()");
    18bc:	4802      	ldr	r0, [pc, #8]	; (18c8 <CustomAction_action1_capability+0x14>)
    18be:	e000      	b.n	18c2 <CustomAction_action1_capability+0xe>
		return;
	}

	// Prints Action1 info message to the debug cli
	info_print("Action1");
    18c0:	4802      	ldr	r0, [pc, #8]	; (18cc <CustomAction_action1_capability+0x18>)
    18c2:	f002 be5d 	b.w	4580 <_print>
    18c6:	bf00      	nop
    18c8:	00004b9d 	.word	0x00004b9d
    18cc:	00004bbf 	.word	0x00004bbf

000018d0 <CustomAction_blockHold_capability>:

uint8_t CustomAction_blockHold_storage = 0;
void CustomAction_blockHold_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    18d0:	29ff      	cmp	r1, #255	; 0xff
	info_print("Action1");
}

uint8_t CustomAction_blockHold_storage = 0;
void CustomAction_blockHold_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    18d2:	b538      	push	{r3, r4, r5, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    18d4:	d103      	bne.n	18de <CustomAction_blockHold_capability+0xe>
    18d6:	28ff      	cmp	r0, #255	; 0xff
    18d8:	d101      	bne.n	18de <CustomAction_blockHold_capability+0xe>
	{
		print("CustomAction_blockHold_capability(usbCode)");
    18da:	4815      	ldr	r0, [pc, #84]	; (1930 <CustomAction_blockHold_capability+0x60>)
    18dc:	e010      	b.n	1900 <CustomAction_blockHold_capability+0x30>
		return;
	}

	// Retrieve 8-bit argument
	uint8_t key = args[0];
    18de:	7815      	ldrb	r5, [r2, #0]

	// We only care about normal keys
	if ( stateType == 0x00 )
    18e0:	bb29      	cbnz	r1, 192e <CustomAction_blockHold_capability+0x5e>
	{
		// Block given key if we're in the "Press" or "Hold" state
		if ( ( state == 0x01 || state == 0x02 )
    18e2:	1e42      	subs	r2, r0, #1
    18e4:	2a01      	cmp	r2, #1
    18e6:	d80f      	bhi.n	1908 <CustomAction_blockHold_capability+0x38>
			&& CustomAction_blockHold_storage == 0 )
    18e8:	4b12      	ldr	r3, [pc, #72]	; (1934 <CustomAction_blockHold_capability+0x64>)
    18ea:	781a      	ldrb	r2, [r3, #0]
    18ec:	b9fa      	cbnz	r2, 192e <CustomAction_blockHold_capability+0x5e>
		{
			CustomAction_blockHold_storage = key;
			info_msg("Blocking Key: ");
    18ee:	4812      	ldr	r0, [pc, #72]	; (1938 <CustomAction_blockHold_capability+0x68>)
	{
		// Block given key if we're in the "Press" or "Hold" state
		if ( ( state == 0x01 || state == 0x02 )
			&& CustomAction_blockHold_storage == 0 )
		{
			CustomAction_blockHold_storage = key;
    18f0:	701d      	strb	r5, [r3, #0]
			info_msg("Blocking Key: ");
    18f2:	f002 fe45 	bl	4580 <_print>
			printHex( key );
    18f6:	4628      	mov	r0, r5
    18f8:	2101      	movs	r1, #1
    18fa:	f002 feca 	bl	4692 <printHex_op>
			print( NL );
    18fe:	480f      	ldr	r0, [pc, #60]	; (193c <CustomAction_blockHold_capability+0x6c>)
			printHex( CustomAction_blockHold_storage );
			print( NL );
			CustomAction_blockHold_storage = 0;
		}
	}
}
    1900:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			&& CustomAction_blockHold_storage == 0 )
		{
			CustomAction_blockHold_storage = key;
			info_msg("Blocking Key: ");
			printHex( key );
			print( NL );
    1904:	f002 be3c 	b.w	4580 <_print>
		}
		// Release if in the "Off" or "Release" state and we're blocking
		else if ( ( state == 0x00 || state == 0x03 )
    1908:	b108      	cbz	r0, 190e <CustomAction_blockHold_capability+0x3e>
    190a:	2803      	cmp	r0, #3
    190c:	d10f      	bne.n	192e <CustomAction_blockHold_capability+0x5e>
			&& key == CustomAction_blockHold_storage )
    190e:	4c09      	ldr	r4, [pc, #36]	; (1934 <CustomAction_blockHold_capability+0x64>)
    1910:	7823      	ldrb	r3, [r4, #0]
    1912:	42ab      	cmp	r3, r5
    1914:	d10b      	bne.n	192e <CustomAction_blockHold_capability+0x5e>
		{
			info_msg("Unblocking Key: ");
    1916:	480a      	ldr	r0, [pc, #40]	; (1940 <CustomAction_blockHold_capability+0x70>)
    1918:	f002 fe32 	bl	4580 <_print>
			printHex( CustomAction_blockHold_storage );
    191c:	7820      	ldrb	r0, [r4, #0]
    191e:	2101      	movs	r1, #1
    1920:	f002 feb7 	bl	4692 <printHex_op>
			print( NL );
    1924:	4805      	ldr	r0, [pc, #20]	; (193c <CustomAction_blockHold_capability+0x6c>)
    1926:	f002 fe2b 	bl	4580 <_print>
			CustomAction_blockHold_storage = 0;
    192a:	2300      	movs	r3, #0
    192c:	7023      	strb	r3, [r4, #0]
    192e:	bd38      	pop	{r3, r4, r5, pc}
    1930:	00004bdb 	.word	0x00004bdb
    1934:	1fffefda 	.word	0x1fffefda
    1938:	00004c06 	.word	0x00004c06
    193c:	00006caf 	.word	0x00006caf
    1940:	00004c27 	.word	0x00004c27

00001944 <CustomAction_blockKey_capability>:
}

void CustomAction_blockKey_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1944:	29ff      	cmp	r1, #255	; 0xff
		}
	}
}

void CustomAction_blockKey_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    1946:	b507      	push	{r0, r1, r2, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1948:	d105      	bne.n	1956 <CustomAction_blockKey_capability+0x12>
    194a:	28ff      	cmp	r0, #255	; 0xff
    194c:	d103      	bne.n	1956 <CustomAction_blockKey_capability+0x12>
	{
		print("CustomAction_blockKey_capability(usbCode)");
    194e:	4809      	ldr	r0, [pc, #36]	; (1974 <CustomAction_blockKey_capability+0x30>)
    1950:	f002 fe16 	bl	4580 <_print>
    1954:	e00a      	b.n	196c <CustomAction_blockKey_capability+0x28>
		return;
	}

	// Retrieve 8-bit argument
	uint8_t key = args[0];
    1956:	7813      	ldrb	r3, [r2, #0]

	// If key is not blocked, process
	if ( key != CustomAction_blockHold_storage )
    1958:	4a07      	ldr	r2, [pc, #28]	; (1978 <CustomAction_blockKey_capability+0x34>)
		print("CustomAction_blockKey_capability(usbCode)");
		return;
	}

	// Retrieve 8-bit argument
	uint8_t key = args[0];
    195a:	f88d 3007 	strb.w	r3, [sp, #7]

	// If key is not blocked, process
	if ( key != CustomAction_blockHold_storage )
    195e:	7812      	ldrb	r2, [r2, #0]
    1960:	429a      	cmp	r2, r3
    1962:	d003      	beq.n	196c <CustomAction_blockKey_capability+0x28>
	{
		extern void Output_usbCodeSend_capability( uint8_t state, uint8_t stateType, uint8_t *args );
		Output_usbCodeSend_capability( state, stateType, &key );
    1964:	f10d 0207 	add.w	r2, sp, #7
    1968:	f001 f9c2 	bl	2cf0 <Output_usbCodeSend_capability>
	}
}
    196c:	b003      	add	sp, #12
    196e:	f85d fb04 	ldr.w	pc, [sp], #4
    1972:	bf00      	nop
    1974:	00004c4a 	.word	0x00004c4a
    1978:	1fffefda 	.word	0x1fffefda

0000197c <cliFunc_capList>:


// ----- CLI Command Functions -----

void cliFunc_capList( char* args )
{
    197c:	b510      	push	{r4, lr}
	print( NL );
    197e:	4810      	ldr	r0, [pc, #64]	; (19c0 <cliFunc_capList+0x44>)
    1980:	f002 fdfe 	bl	4580 <_print>
	info_msg("Capabilities List ");
    1984:	480f      	ldr	r0, [pc, #60]	; (19c4 <cliFunc_capList+0x48>)
    1986:	f002 fdfb 	bl	4580 <_print>
	printHex( CapabilitiesNum );
    198a:	200f      	movs	r0, #15
    198c:	2101      	movs	r1, #1
    198e:	f002 fe80 	bl	4692 <printHex_op>
    1992:	2400      	movs	r4, #0

	// Iterate through all of the capabilities and display them
	for ( var_uint_t cap = 0; cap < CapabilitiesNum; cap++ )
	{
		print( NL "\t" );
    1994:	480c      	ldr	r0, [pc, #48]	; (19c8 <cliFunc_capList+0x4c>)
    1996:	f002 fdf3 	bl	4580 <_print>
		printHex( cap );
    199a:	b2a0      	uxth	r0, r4
    199c:	2101      	movs	r1, #1
    199e:	f002 fe78 	bl	4692 <printHex_op>
		print(" - ");
    19a2:	480a      	ldr	r0, [pc, #40]	; (19cc <cliFunc_capList+0x50>)
    19a4:	f002 fdec 	bl	4580 <_print>

		// Display/Lookup Capability Name (utilize debug mode of capability)
		void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
    19a8:	4b09      	ldr	r3, [pc, #36]	; (19d0 <cliFunc_capList+0x54>)
		capability( 0xFF, 0xFF, 0 );
    19aa:	20ff      	movs	r0, #255	; 0xff
    19ac:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
    19b0:	4601      	mov	r1, r0
    19b2:	2200      	movs	r2, #0
    19b4:	3401      	adds	r4, #1
    19b6:	4798      	blx	r3
	print( NL );
	info_msg("Capabilities List ");
	printHex( CapabilitiesNum );

	// Iterate through all of the capabilities and display them
	for ( var_uint_t cap = 0; cap < CapabilitiesNum; cap++ )
    19b8:	2c0f      	cmp	r4, #15
    19ba:	d1eb      	bne.n	1994 <cliFunc_capList+0x18>

		// Display/Lookup Capability Name (utilize debug mode of capability)
		void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
		capability( 0xFF, 0xFF, 0 );
	}
}
    19bc:	bd10      	pop	{r4, pc}
    19be:	bf00      	nop
    19c0:	00006caf 	.word	0x00006caf
    19c4:	00004e7d 	.word	0x00004e7d
    19c8:	00004ea2 	.word	0x00004ea2
    19cc:	00006c44 	.word	0x00006c44
    19d0:	00004ce8 	.word	0x00004ce8

000019d4 <cliFunc_macroStep>:
		}
	}
}

void cliFunc_macroStep( char* args )
{
    19d4:	b507      	push	{r0, r1, r2, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    19d6:	4669      	mov	r1, sp
    19d8:	aa01      	add	r2, sp, #4
    19da:	f002 fb1b 	bl	4014 <CLI_argumentIsolation>

	// Default to 1, if no argument given
	var_uint_t count = (var_uint_t)numToInt( arg1Ptr );
    19de:	9800      	ldr	r0, [sp, #0]
    19e0:	f002 feac 	bl	473c <numToInt>
    19e4:	b2c0      	uxtb	r0, r0

	if ( count == 0 )
    19e6:	2800      	cmp	r0, #0
		count = 1;

	// Set the macro step counter, negative int's are cast to uint
	macroStepCounter = count;
    19e8:	4b03      	ldr	r3, [pc, #12]	; (19f8 <cliFunc_macroStep+0x24>)

	// Default to 1, if no argument given
	var_uint_t count = (var_uint_t)numToInt( arg1Ptr );

	if ( count == 0 )
		count = 1;
    19ea:	bf08      	it	eq
    19ec:	2001      	moveq	r0, #1

	// Set the macro step counter, negative int's are cast to uint
	macroStepCounter = count;
    19ee:	8018      	strh	r0, [r3, #0]
}
    19f0:	b003      	add	sp, #12
    19f2:	f85d fb04 	ldr.w	pc, [sp], #4
    19f6:	bf00      	nop
    19f8:	1fffefde 	.word	0x1fffefde

000019fc <cliFunc_capSelect>:
		capability( 0xFF, 0xFF, 0 );
	}
}

void cliFunc_capSelect( char* args )
{
    19fc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	// Parse code from argument
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    1a00:	2500      	movs	r5, #0
		capability( 0xFF, 0xFF, 0 );
	}
}

void cliFunc_capSelect( char* args )
{
    1a02:	4604      	mov	r4, r0
	// Parse code from argument
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    1a04:	9001      	str	r0, [sp, #4]
	// Total number of args to scan (must do a lookup if a keyboard capability is selected)
	var_uint_t totalArgs = 2; // Always at least two args
	var_uint_t cap = 0;

	// Arguments used for keyboard capability function
	var_uint_t argSetCount = 0;
    1a06:	46a8      	mov	r8, r5
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Total number of args to scan (must do a lookup if a keyboard capability is selected)
	var_uint_t totalArgs = 2; // Always at least two args
	var_uint_t cap = 0;
    1a08:	46a9      	mov	r9, r5
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Total number of args to scan (must do a lookup if a keyboard capability is selected)
	var_uint_t totalArgs = 2; // Always at least two args
    1a0a:	2702      	movs	r7, #2

	// Process all args
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    1a0c:	9801      	ldr	r0, [sp, #4]
    1a0e:	4669      	mov	r1, sp
    1a10:	aa01      	add	r2, sp, #4
    1a12:	f002 faff 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		// Extra arguments are ignored
		if ( *arg1Ptr == '\0' )
    1a16:	9800      	ldr	r0, [sp, #0]
    1a18:	7803      	ldrb	r3, [r0, #0]
    1a1a:	2b00      	cmp	r3, #0
    1a1c:	d05b      	beq.n	1ad6 <cliFunc_capSelect+0xda>
			break;

		// For the first argument, choose the capability
		if ( c == 0 ) switch ( arg1Ptr[0] )
    1a1e:	f015 0fff 	tst.w	r5, #255	; 0xff
    1a22:	d10e      	bne.n	1a42 <cliFunc_capSelect+0x46>
    1a24:	2b4b      	cmp	r3, #75	; 0x4b
    1a26:	d10c      	bne.n	1a42 <cliFunc_capSelect+0x46>
		{
		// Keyboard Capability
		case 'K':
			// Determine capability index
			cap = numToInt( &arg1Ptr[1] );
    1a28:	3001      	adds	r0, #1
    1a2a:	f002 fe87 	bl	473c <numToInt>

			// Lookup the number of args
			totalArgs += CapabilitiesList[ cap ].argCount;
    1a2e:	4b2b      	ldr	r3, [pc, #172]	; (1adc <cliFunc_capSelect+0xe0>)
		if ( c == 0 ) switch ( arg1Ptr[0] )
		{
		// Keyboard Capability
		case 'K':
			// Determine capability index
			cap = numToInt( &arg1Ptr[1] );
    1a30:	fa5f f980 	uxtb.w	r9, r0

			// Lookup the number of args
			totalArgs += CapabilitiesList[ cap ].argCount;
    1a34:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
			continue;
    1a38:	4646      	mov	r6, r8
		case 'K':
			// Determine capability index
			cap = numToInt( &arg1Ptr[1] );

			// Lookup the number of args
			totalArgs += CapabilitiesList[ cap ].argCount;
    1a3a:	791b      	ldrb	r3, [r3, #4]
    1a3c:	441f      	add	r7, r3
    1a3e:	b2ff      	uxtb	r7, r7
			continue;
    1a40:	e043      	b.n	1aca <cliFunc_capSelect+0xce>
		}

		// Because allocating memory isn't doable, and the argument count is arbitrary
		// The argument pointer is repurposed as the argument list (much smaller anyways)
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    1a42:	f002 fe7b 	bl	473c <numToInt>
    1a46:	f108 0601 	add.w	r6, r8, #1
    1a4a:	b2f6      	uxtb	r6, r6

		// Once all the arguments are prepared, call the keyboard capability function
		if ( argSetCount == totalArgs )
    1a4c:	42be      	cmp	r6, r7
			continue;
		}

		// Because allocating memory isn't doable, and the argument count is arbitrary
		// The argument pointer is repurposed as the argument list (much smaller anyways)
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    1a4e:	f804 0008 	strb.w	r0, [r4, r8]

		// Once all the arguments are prepared, call the keyboard capability function
		if ( argSetCount == totalArgs )
    1a52:	d13a      	bne.n	1aca <cliFunc_capSelect+0xce>
		{
			// Indicate that the capability was called
			print( NL );
    1a54:	4822      	ldr	r0, [pc, #136]	; (1ae0 <cliFunc_capSelect+0xe4>)
    1a56:	f002 fd93 	bl	4580 <_print>
			info_msg("K");
    1a5a:	4822      	ldr	r0, [pc, #136]	; (1ae4 <cliFunc_capSelect+0xe8>)
    1a5c:	f002 fd90 	bl	4580 <_print>
			printInt8( cap );
    1a60:	4648      	mov	r0, r9
    1a62:	f002 fdbf 	bl	45e4 <printInt8>
			print(" - ");
    1a66:	4820      	ldr	r0, [pc, #128]	; (1ae8 <cliFunc_capSelect+0xec>)
    1a68:	f002 fd8a 	bl	4580 <_print>
			printHex( argSet[0] );
    1a6c:	2101      	movs	r1, #1
    1a6e:	7820      	ldrb	r0, [r4, #0]
    1a70:	f002 fe0f 	bl	4692 <printHex_op>
			print(" - ");
    1a74:	481c      	ldr	r0, [pc, #112]	; (1ae8 <cliFunc_capSelect+0xec>)
    1a76:	f002 fd83 	bl	4580 <_print>
			printHex( argSet[1] );
    1a7a:	2101      	movs	r1, #1
    1a7c:	7860      	ldrb	r0, [r4, #1]
    1a7e:	f002 fe08 	bl	4692 <printHex_op>
			print(" - ");
    1a82:	4819      	ldr	r0, [pc, #100]	; (1ae8 <cliFunc_capSelect+0xec>)
    1a84:	f002 fd7c 	bl	4580 <_print>
			printHex( argSet[2] );
    1a88:	78a0      	ldrb	r0, [r4, #2]
    1a8a:	2101      	movs	r1, #1
    1a8c:	f002 fe01 	bl	4692 <printHex_op>
			print( "..." NL );
    1a90:	4816      	ldr	r0, [pc, #88]	; (1aec <cliFunc_capSelect+0xf0>)
    1a92:	f002 fd75 	bl	4580 <_print>
    1a96:	2300      	movs	r3, #0

			// Make sure this isn't the reload capability
			// If it is, and the remote reflash define is not set, ignore
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
			{
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    1a98:	4a10      	ldr	r2, [pc, #64]	; (1adc <cliFunc_capSelect+0xe0>)
    1a9a:	4815      	ldr	r0, [pc, #84]	; (1af0 <cliFunc_capSelect+0xf4>)
    1a9c:	5899      	ldr	r1, [r3, r2]
    1a9e:	4281      	cmp	r1, r0
    1aa0:	d109      	bne.n	1ab6 <cliFunc_capSelect+0xba>
				{
					print( NL );
    1aa2:	480f      	ldr	r0, [pc, #60]	; (1ae0 <cliFunc_capSelect+0xe4>)
    1aa4:	f002 fd6c 	bl	4580 <_print>
					warn_print("flashModeEnabled not set, cancelling firmware reload...");
    1aa8:	4812      	ldr	r0, [pc, #72]	; (1af4 <cliFunc_capSelect+0xf8>)
    1aaa:	f002 fd69 	bl	4580 <_print>
					info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    1aae:	4812      	ldr	r0, [pc, #72]	; (1af8 <cliFunc_capSelect+0xfc>)
    1ab0:	f002 fd66 	bl	4580 <_print>
    1ab4:	e00f      	b.n	1ad6 <cliFunc_capSelect+0xda>
    1ab6:	3308      	adds	r3, #8
			printHex( argSet[2] );
			print( "..." NL );

			// Make sure this isn't the reload capability
			// If it is, and the remote reflash define is not set, ignore
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    1ab8:	2b78      	cmp	r3, #120	; 0x78
    1aba:	d1ed      	bne.n	1a98 <cliFunc_capSelect+0x9c>
					return;
				}
			}

			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
			capability( argSet[0], argSet[1], &argSet[2] );
    1abc:	f852 3039 	ldr.w	r3, [r2, r9, lsl #3]
    1ac0:	7820      	ldrb	r0, [r4, #0]
    1ac2:	7861      	ldrb	r1, [r4, #1]
    1ac4:	1ca2      	adds	r2, r4, #2
    1ac6:	4798      	blx	r3
    1ac8:	4637      	mov	r7, r6
	// Arguments used for keyboard capability function
	var_uint_t argSetCount = 0;
	uint8_t *argSet = (uint8_t*)args;

	// Process all args
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
    1aca:	42be      	cmp	r6, r7
    1acc:	f105 0501 	add.w	r5, r5, #1
    1ad0:	d201      	bcs.n	1ad6 <cliFunc_capSelect+0xda>
    1ad2:	46b0      	mov	r8, r6
    1ad4:	e79a      	b.n	1a0c <cliFunc_capSelect+0x10>

			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
			capability( argSet[0], argSet[1], &argSet[2] );
		}
	}
}
    1ad6:	b003      	add	sp, #12
    1ad8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1adc:	00004ce8 	.word	0x00004ce8
    1ae0:	00006caf 	.word	0x00006caf
    1ae4:	00004ea6 	.word	0x00004ea6
    1ae8:	00006c44 	.word	0x00006c44
    1aec:	00004f03 	.word	0x00004f03
    1af0:	00002c49 	.word	0x00002c49
    1af4:	00004eba 	.word	0x00004eba
    1af8:	00004f09 	.word	0x00004f09

00001afc <cliFunc_layerDebug>:
		}
	}
}

void cliFunc_layerDebug( char *args )
{
    1afc:	b510      	push	{r4, lr}
	// Toggle layer debug mode
	layerDebugMode = layerDebugMode ? 0 : 1;
    1afe:	4c09      	ldr	r4, [pc, #36]	; (1b24 <cliFunc_layerDebug+0x28>)

	print( NL );
    1b00:	4809      	ldr	r0, [pc, #36]	; (1b28 <cliFunc_layerDebug+0x2c>)
}

void cliFunc_layerDebug( char *args )
{
	// Toggle layer debug mode
	layerDebugMode = layerDebugMode ? 0 : 1;
    1b02:	7823      	ldrb	r3, [r4, #0]
    1b04:	f1d3 0301 	rsbs	r3, r3, #1
    1b08:	bf38      	it	cc
    1b0a:	2300      	movcc	r3, #0
    1b0c:	7023      	strb	r3, [r4, #0]

	print( NL );
    1b0e:	f002 fd37 	bl	4580 <_print>
	info_msg("Layer Debug Mode: ");
    1b12:	4806      	ldr	r0, [pc, #24]	; (1b2c <cliFunc_layerDebug+0x30>)
    1b14:	f002 fd34 	bl	4580 <_print>
	printInt8( layerDebugMode );
    1b18:	7820      	ldrb	r0, [r4, #0]
}
    1b1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	// Toggle layer debug mode
	layerDebugMode = layerDebugMode ? 0 : 1;

	print( NL );
	info_msg("Layer Debug Mode: ");
	printInt8( layerDebugMode );
    1b1e:	f002 bd61 	b.w	45e4 <printInt8>
    1b22:	bf00      	nop
    1b24:	1ffff176 	.word	0x1ffff176
    1b28:	00006caf 	.word	0x00006caf
    1b2c:	00004f50 	.word	0x00004f50

00001b30 <cliFunc_layerState>:
		printHex( LayerIndex[ layer ].last );
	}
}

void cliFunc_layerState( char* args )
{
    1b30:	b573      	push	{r0, r1, r4, r5, r6, lr}

	uint8_t arg1 = 0;
	uint8_t arg2 = 0;

	// Process first two args
	for ( uint8_t c = 0; c < 2; c++ )
    1b32:	2400      	movs	r4, #0
void cliFunc_layerState( char* args )
{
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    1b34:	9001      	str	r0, [sp, #4]

	uint8_t arg1 = 0;
    1b36:	4625      	mov	r5, r4

	// Process first two args
	for ( uint8_t c = 0; c < 2; c++ )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    1b38:	9801      	ldr	r0, [sp, #4]
    1b3a:	4669      	mov	r1, sp
    1b3c:	aa01      	add	r2, sp, #4
    1b3e:	f002 fa69 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    1b42:	9800      	ldr	r0, [sp, #0]
    1b44:	7803      	ldrb	r3, [r0, #0]
    1b46:	b30b      	cbz	r3, 1b8c <cliFunc_layerState+0x5c>
			break;

		switch ( c )
    1b48:	2c01      	cmp	r4, #1
    1b4a:	d006      	beq.n	1b5a <cliFunc_layerState+0x2a>
		{
		// First argument (e.g. L1)
		case 0:
			if ( arg1Ptr[0] != 'L' )
    1b4c:	2b4c      	cmp	r3, #76	; 0x4c
    1b4e:	d11d      	bne.n	1b8c <cliFunc_layerState+0x5c>
				return;

			arg1 = (uint8_t)numToInt( &arg1Ptr[1] );
    1b50:	3001      	adds	r0, #1
    1b52:	f002 fdf3 	bl	473c <numToInt>
    1b56:	b2c5      	uxtb	r5, r0
			break;
    1b58:	e014      	b.n	1b84 <cliFunc_layerState+0x54>
		// Second argument (e.g. 4)
		case 1:
			arg2 = (uint8_t)numToInt( arg1Ptr );
    1b5a:	f002 fdef 	bl	473c <numToInt>
    1b5e:	b2c6      	uxtb	r6, r0

			// Display operation (to indicate that it worked)
			print( NL );
    1b60:	480b      	ldr	r0, [pc, #44]	; (1b90 <cliFunc_layerState+0x60>)
    1b62:	f002 fd0d 	bl	4580 <_print>
			info_msg("Setting Layer L");
    1b66:	480b      	ldr	r0, [pc, #44]	; (1b94 <cliFunc_layerState+0x64>)
    1b68:	f002 fd0a 	bl	4580 <_print>
			printInt8( arg1 );
    1b6c:	4628      	mov	r0, r5
    1b6e:	f002 fd39 	bl	45e4 <printInt8>
			print(" to - ");
    1b72:	4809      	ldr	r0, [pc, #36]	; (1b98 <cliFunc_layerState+0x68>)
    1b74:	f002 fd04 	bl	4580 <_print>
			printHex( arg2 );
    1b78:	4630      	mov	r0, r6
    1b7a:	4621      	mov	r1, r4
    1b7c:	f002 fd89 	bl	4692 <printHex_op>

			// Set the layer state
			LayerState[ arg1 ] = arg2;
    1b80:	4b06      	ldr	r3, [pc, #24]	; (1b9c <cliFunc_layerState+0x6c>)
    1b82:	555e      	strb	r6, [r3, r5]

	uint8_t arg1 = 0;
	uint8_t arg2 = 0;

	// Process first two args
	for ( uint8_t c = 0; c < 2; c++ )
    1b84:	3401      	adds	r4, #1
    1b86:	b2e4      	uxtb	r4, r4
    1b88:	2c02      	cmp	r4, #2
    1b8a:	d1d5      	bne.n	1b38 <cliFunc_layerState+0x8>
			// Set the layer state
			LayerState[ arg1 ] = arg2;
			break;
		}
	}
}
    1b8c:	b002      	add	sp, #8
    1b8e:	bd70      	pop	{r4, r5, r6, pc}
    1b90:	00006caf 	.word	0x00006caf
    1b94:	00004f75 	.word	0x00004f75
    1b98:	00004f97 	.word	0x00004f97
    1b9c:	1ffffafd 	.word	0x1ffffafd

00001ba0 <cliFunc_macroDebug>:

void cliFunc_macroDebug( char* args )
{
    1ba0:	b510      	push	{r4, lr}
	// Toggle macro debug mode
	macroDebugMode = macroDebugMode ? 0 : 1;
    1ba2:	4c09      	ldr	r4, [pc, #36]	; (1bc8 <cliFunc_macroDebug+0x28>)

	print( NL );
    1ba4:	4809      	ldr	r0, [pc, #36]	; (1bcc <cliFunc_macroDebug+0x2c>)
}

void cliFunc_macroDebug( char* args )
{
	// Toggle macro debug mode
	macroDebugMode = macroDebugMode ? 0 : 1;
    1ba6:	7823      	ldrb	r3, [r4, #0]
    1ba8:	f1d3 0301 	rsbs	r3, r3, #1
    1bac:	bf38      	it	cc
    1bae:	2300      	movcc	r3, #0
    1bb0:	7023      	strb	r3, [r4, #0]

	print( NL );
    1bb2:	f002 fce5 	bl	4580 <_print>
	info_msg("Macro Debug Mode: ");
    1bb6:	4806      	ldr	r0, [pc, #24]	; (1bd0 <cliFunc_macroDebug+0x30>)
    1bb8:	f002 fce2 	bl	4580 <_print>
	printInt8( macroDebugMode );
    1bbc:	7820      	ldrb	r0, [r4, #0]
}
    1bbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	// Toggle macro debug mode
	macroDebugMode = macroDebugMode ? 0 : 1;

	print( NL );
	info_msg("Macro Debug Mode: ");
	printInt8( macroDebugMode );
    1bc2:	f002 bd0f 	b.w	45e4 <printInt8>
    1bc6:	bf00      	nop
    1bc8:	1ffff16b 	.word	0x1ffff16b
    1bcc:	00006caf 	.word	0x00006caf
    1bd0:	00004f9e 	.word	0x00004f9e

00001bd4 <cliFunc_macroProc>:
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
	}
}

void cliFunc_macroProc( char* args )
{
    1bd4:	b510      	push	{r4, lr}
	// Toggle macro pause mode
	macroPauseMode = macroPauseMode ? 0 : 1;
    1bd6:	4c09      	ldr	r4, [pc, #36]	; (1bfc <cliFunc_macroProc+0x28>)

	print( NL );
    1bd8:	4809      	ldr	r0, [pc, #36]	; (1c00 <cliFunc_macroProc+0x2c>)
}

void cliFunc_macroProc( char* args )
{
	// Toggle macro pause mode
	macroPauseMode = macroPauseMode ? 0 : 1;
    1bda:	7823      	ldrb	r3, [r4, #0]
    1bdc:	f1d3 0301 	rsbs	r3, r3, #1
    1be0:	bf38      	it	cc
    1be2:	2300      	movcc	r3, #0
    1be4:	7023      	strb	r3, [r4, #0]

	print( NL );
    1be6:	f002 fccb 	bl	4580 <_print>
	info_msg("Macro Processing Mode: ");
    1bea:	4806      	ldr	r0, [pc, #24]	; (1c04 <cliFunc_macroProc+0x30>)
    1bec:	f002 fcc8 	bl	4580 <_print>
	printInt8( macroPauseMode );
    1bf0:	7820      	ldrb	r0, [r4, #0]
}
    1bf2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	// Toggle macro pause mode
	macroPauseMode = macroPauseMode ? 0 : 1;

	print( NL );
	info_msg("Macro Processing Mode: ");
	printInt8( macroPauseMode );
    1bf6:	f002 bcf5 	b.w	45e4 <printInt8>
    1bfa:	bf00      	nop
    1bfc:	1ffff0a2 	.word	0x1ffff0a2
    1c00:	00006caf 	.word	0x00006caf
    1c04:	00004fc3 	.word	0x00004fc3

00001c08 <cliFunc_layerList>:
	info_msg("Layer Debug Mode: ");
	printInt8( layerDebugMode );
}

void cliFunc_layerList( char* args )
{
    1c08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	print( NL );
    1c0c:	482b      	ldr	r0, [pc, #172]	; (1cbc <cliFunc_layerList+0xb4>)
	info_msg("Layer List");

	// Iterate through all of the layers and display them
	for ( uint16_t layer = 0; layer < LayerNum; layer++ )
	{
		print( NL "\t" );
    1c0e:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 1ce0 <cliFunc_layerList+0xd8>
		printHex( layer );
		print(" - ");
    1c12:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 1ce4 <cliFunc_layerList+0xdc>
		// Default map
		if ( layer == 0 )
			print(" \033[1m(default)\033[0m");

		// Layer State
		print( NL "\t\t Layer State: " );
    1c16:	4f2a      	ldr	r7, [pc, #168]	; (1cc0 <cliFunc_layerList+0xb8>)
		printHex( LayerState[ layer ] );
    1c18:	4e2a      	ldr	r6, [pc, #168]	; (1cc4 <cliFunc_layerList+0xbc>)

		// First -> Last Indices
		print(" First -> Last Indices: ");
    1c1a:	4d2b      	ldr	r5, [pc, #172]	; (1cc8 <cliFunc_layerList+0xc0>)
		printHex( LayerIndex[ layer ].first );
		print(" -> ");
    1c1c:	4c2b      	ldr	r4, [pc, #172]	; (1ccc <cliFunc_layerList+0xc4>)
	printInt8( layerDebugMode );
}

void cliFunc_layerList( char* args )
{
	print( NL );
    1c1e:	f002 fcaf 	bl	4580 <_print>
	info_msg("Layer List");
    1c22:	482b      	ldr	r0, [pc, #172]	; (1cd0 <cliFunc_layerList+0xc8>)
    1c24:	f002 fcac 	bl	4580 <_print>

	// Iterate through all of the layers and display them
	for ( uint16_t layer = 0; layer < LayerNum; layer++ )
	{
		print( NL "\t" );
    1c28:	4648      	mov	r0, r9
    1c2a:	f002 fca9 	bl	4580 <_print>
		printHex( layer );
    1c2e:	2101      	movs	r1, #1
    1c30:	2000      	movs	r0, #0
    1c32:	f002 fd2e 	bl	4692 <printHex_op>
		print(" - ");
    1c36:	4640      	mov	r0, r8
    1c38:	f002 fca2 	bl	4580 <_print>

		// Display layer name
		dPrint( (char*)LayerIndex[ layer ].name );
    1c3c:	4825      	ldr	r0, [pc, #148]	; (1cd4 <cliFunc_layerList+0xcc>)
    1c3e:	f001 f989 	bl	2f54 <Output_putstr>

		// Default map
		if ( layer == 0 )
			print(" \033[1m(default)\033[0m");
    1c42:	4825      	ldr	r0, [pc, #148]	; (1cd8 <cliFunc_layerList+0xd0>)
    1c44:	f002 fc9c 	bl	4580 <_print>

		// Layer State
		print( NL "\t\t Layer State: " );
    1c48:	4638      	mov	r0, r7
    1c4a:	f002 fc99 	bl	4580 <_print>
		printHex( LayerState[ layer ] );
    1c4e:	7830      	ldrb	r0, [r6, #0]
    1c50:	2101      	movs	r1, #1
    1c52:	f002 fd1e 	bl	4692 <printHex_op>

		// First -> Last Indices
		print(" First -> Last Indices: ");
    1c56:	4628      	mov	r0, r5
    1c58:	f002 fc92 	bl	4580 <_print>
		printHex( LayerIndex[ layer ].first );
    1c5c:	2101      	movs	r1, #1
    1c5e:	2000      	movs	r0, #0
    1c60:	f002 fd17 	bl	4692 <printHex_op>
		print(" -> ");
    1c64:	4620      	mov	r0, r4
    1c66:	f002 fc8b 	bl	4580 <_print>
		printHex( LayerIndex[ layer ].last );
    1c6a:	2101      	movs	r1, #1
    1c6c:	203e      	movs	r0, #62	; 0x3e
    1c6e:	f002 fd10 	bl	4692 <printHex_op>
	info_msg("Layer List");

	// Iterate through all of the layers and display them
	for ( uint16_t layer = 0; layer < LayerNum; layer++ )
	{
		print( NL "\t" );
    1c72:	4648      	mov	r0, r9
    1c74:	f002 fc84 	bl	4580 <_print>
		printHex( layer );
    1c78:	2001      	movs	r0, #1
    1c7a:	4601      	mov	r1, r0
    1c7c:	f002 fd09 	bl	4692 <printHex_op>
		print(" - ");
    1c80:	4640      	mov	r0, r8
    1c82:	f002 fc7d 	bl	4580 <_print>

		// Display layer name
		dPrint( (char*)LayerIndex[ layer ].name );
    1c86:	4815      	ldr	r0, [pc, #84]	; (1cdc <cliFunc_layerList+0xd4>)
    1c88:	f001 f964 	bl	2f54 <Output_putstr>
		// Default map
		if ( layer == 0 )
			print(" \033[1m(default)\033[0m");

		// Layer State
		print( NL "\t\t Layer State: " );
    1c8c:	4638      	mov	r0, r7
    1c8e:	f002 fc77 	bl	4580 <_print>
		printHex( LayerState[ layer ] );
    1c92:	7870      	ldrb	r0, [r6, #1]
    1c94:	2101      	movs	r1, #1
    1c96:	f002 fcfc 	bl	4692 <printHex_op>

		// First -> Last Indices
		print(" First -> Last Indices: ");
    1c9a:	4628      	mov	r0, r5
    1c9c:	f002 fc70 	bl	4580 <_print>
		printHex( LayerIndex[ layer ].first );
    1ca0:	2001      	movs	r0, #1
    1ca2:	4601      	mov	r1, r0
    1ca4:	f002 fcf5 	bl	4692 <printHex_op>
		print(" -> ");
    1ca8:	4620      	mov	r0, r4
    1caa:	f002 fc69 	bl	4580 <_print>
		printHex( LayerIndex[ layer ].last );
    1cae:	2034      	movs	r0, #52	; 0x34
    1cb0:	2101      	movs	r1, #1
	}
}
    1cb2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

		// First -> Last Indices
		print(" First -> Last Indices: ");
		printHex( LayerIndex[ layer ].first );
		print(" -> ");
		printHex( LayerIndex[ layer ].last );
    1cb6:	f002 bcec 	b.w	4692 <printHex_op>
    1cba:	bf00      	nop
    1cbc:	00006caf 	.word	0x00006caf
    1cc0:	00005038 	.word	0x00005038
    1cc4:	1ffffafd 	.word	0x1ffffafd
    1cc8:	0000504b 	.word	0x0000504b
    1ccc:	00005064 	.word	0x00005064
    1cd0:	00004fed 	.word	0x00004fed
    1cd4:	0000500a 	.word	0x0000500a
    1cd8:	00005025 	.word	0x00005025
    1cdc:	00005069 	.word	0x00005069
    1ce0:	00004ea2 	.word	0x00004ea2
    1ce4:	00006c44 	.word	0x00006c44

00001ce8 <cliFunc_macroList>:
	info_msg("Macro Debug Mode: ");
	printInt8( macroDebugMode );
}

void cliFunc_macroList( char* args )
{
    1ce8:	b538      	push	{r3, r4, r5, lr}
	// Show pending key events
	print( NL );
    1cea:	4845      	ldr	r0, [pc, #276]	; (1e00 <cliFunc_macroList+0x118>)
	info_msg("Pending Key Events: ");
	printInt16( (uint16_t)macroTriggerListBufferSize );
    1cec:	4c45      	ldr	r4, [pc, #276]	; (1e04 <cliFunc_macroList+0x11c>)
}

void cliFunc_macroList( char* args )
{
	// Show pending key events
	print( NL );
    1cee:	f002 fc47 	bl	4580 <_print>
	info_msg("Pending Key Events: ");
    1cf2:	4845      	ldr	r0, [pc, #276]	; (1e08 <cliFunc_macroList+0x120>)
    1cf4:	f002 fc44 	bl	4580 <_print>
	printInt16( (uint16_t)macroTriggerListBufferSize );
    1cf8:	7820      	ldrb	r0, [r4, #0]
    1cfa:	f002 fc93 	bl	4624 <printInt16>
	print(" : ");
    1cfe:	4843      	ldr	r0, [pc, #268]	; (1e0c <cliFunc_macroList+0x124>)
    1d00:	f002 fc3e 	bl	4580 <_print>
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    1d04:	2300      	movs	r3, #0
    1d06:	7822      	ldrb	r2, [r4, #0]
    1d08:	1c5d      	adds	r5, r3, #1
    1d0a:	b2db      	uxtb	r3, r3
    1d0c:	429a      	cmp	r2, r3
    1d0e:	d90c      	bls.n	1d2a <cliFunc_macroList+0x42>
	{
		printHex( macroTriggerListBuffer[ key ].scanCode );
    1d10:	4a3f      	ldr	r2, [pc, #252]	; (1e10 <cliFunc_macroList+0x128>)
    1d12:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1d16:	4413      	add	r3, r2
    1d18:	2101      	movs	r1, #1
    1d1a:	7898      	ldrb	r0, [r3, #2]
    1d1c:	f002 fcb9 	bl	4692 <printHex_op>
		print(" ");
    1d20:	483c      	ldr	r0, [pc, #240]	; (1e14 <cliFunc_macroList+0x12c>)
    1d22:	f002 fc2d 	bl	4580 <_print>
    1d26:	462b      	mov	r3, r5
    1d28:	e7ed      	b.n	1d06 <cliFunc_macroList+0x1e>
	}

	// Show pending trigger macros
	print( NL );
    1d2a:	4835      	ldr	r0, [pc, #212]	; (1e00 <cliFunc_macroList+0x118>)
	info_msg("Pending Trigger Macros: ");
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    1d2c:	4c3a      	ldr	r4, [pc, #232]	; (1e18 <cliFunc_macroList+0x130>)
		printHex( macroTriggerListBuffer[ key ].scanCode );
		print(" ");
	}

	// Show pending trigger macros
	print( NL );
    1d2e:	f002 fc27 	bl	4580 <_print>
	info_msg("Pending Trigger Macros: ");
    1d32:	483a      	ldr	r0, [pc, #232]	; (1e1c <cliFunc_macroList+0x134>)
    1d34:	f002 fc24 	bl	4580 <_print>
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    1d38:	8820      	ldrh	r0, [r4, #0]
    1d3a:	f002 fc73 	bl	4624 <printInt16>
	print(" : ");
    1d3e:	4833      	ldr	r0, [pc, #204]	; (1e0c <cliFunc_macroList+0x124>)
    1d40:	f002 fc1e 	bl	4580 <_print>
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    1d44:	2300      	movs	r3, #0
    1d46:	8822      	ldrh	r2, [r4, #0]
    1d48:	1c5d      	adds	r5, r3, #1
    1d4a:	b2db      	uxtb	r3, r3
    1d4c:	4293      	cmp	r3, r2
    1d4e:	d20a      	bcs.n	1d66 <cliFunc_macroList+0x7e>
	{
		printHex( macroTriggerMacroPendingList[ macro ] );
    1d50:	4a33      	ldr	r2, [pc, #204]	; (1e20 <cliFunc_macroList+0x138>)
    1d52:	2101      	movs	r1, #1
    1d54:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    1d58:	f002 fc9b 	bl	4692 <printHex_op>
		print(" ");
    1d5c:	482d      	ldr	r0, [pc, #180]	; (1e14 <cliFunc_macroList+0x12c>)
    1d5e:	f002 fc0f 	bl	4580 <_print>
    1d62:	462b      	mov	r3, r5
    1d64:	e7ef      	b.n	1d46 <cliFunc_macroList+0x5e>
	}

	// Show pending result macros
	print( NL );
    1d66:	4826      	ldr	r0, [pc, #152]	; (1e00 <cliFunc_macroList+0x118>)
	info_msg("Pending Result Macros: ");
	printInt16( (uint16_t)macroResultMacroPendingListSize );
    1d68:	4c2e      	ldr	r4, [pc, #184]	; (1e24 <cliFunc_macroList+0x13c>)
		printHex( macroTriggerMacroPendingList[ macro ] );
		print(" ");
	}

	// Show pending result macros
	print( NL );
    1d6a:	f002 fc09 	bl	4580 <_print>
	info_msg("Pending Result Macros: ");
    1d6e:	482e      	ldr	r0, [pc, #184]	; (1e28 <cliFunc_macroList+0x140>)
    1d70:	f002 fc06 	bl	4580 <_print>
	printInt16( (uint16_t)macroResultMacroPendingListSize );
    1d74:	8820      	ldrh	r0, [r4, #0]
    1d76:	f002 fc55 	bl	4624 <printInt16>
	print(" : ");
    1d7a:	4824      	ldr	r0, [pc, #144]	; (1e0c <cliFunc_macroList+0x124>)
    1d7c:	f002 fc00 	bl	4580 <_print>
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    1d80:	2300      	movs	r3, #0
    1d82:	8822      	ldrh	r2, [r4, #0]
    1d84:	1c5d      	adds	r5, r3, #1
    1d86:	b2db      	uxtb	r3, r3
    1d88:	4293      	cmp	r3, r2
    1d8a:	d20a      	bcs.n	1da2 <cliFunc_macroList+0xba>
	{
		printHex( macroResultMacroPendingList[ macro ] );
    1d8c:	4a27      	ldr	r2, [pc, #156]	; (1e2c <cliFunc_macroList+0x144>)
    1d8e:	2101      	movs	r1, #1
    1d90:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    1d94:	f002 fc7d 	bl	4692 <printHex_op>
		print(" ");
    1d98:	481e      	ldr	r0, [pc, #120]	; (1e14 <cliFunc_macroList+0x12c>)
    1d9a:	f002 fbf1 	bl	4580 <_print>
    1d9e:	462b      	mov	r3, r5
    1da0:	e7ef      	b.n	1d82 <cliFunc_macroList+0x9a>
	}

	// Show available trigger macro indices
	print( NL );
    1da2:	4817      	ldr	r0, [pc, #92]	; (1e00 <cliFunc_macroList+0x118>)
    1da4:	f002 fbec 	bl	4580 <_print>
	info_msg("Trigger Macros Range: T0 -> T");
    1da8:	4821      	ldr	r0, [pc, #132]	; (1e30 <cliFunc_macroList+0x148>)
    1daa:	f002 fbe9 	bl	4580 <_print>
	printInt16( (uint16_t)TriggerMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    1dae:	2061      	movs	r0, #97	; 0x61
    1db0:	f002 fc38 	bl	4624 <printInt16>

	// Show available result macro indices
	print( NL );
    1db4:	4812      	ldr	r0, [pc, #72]	; (1e00 <cliFunc_macroList+0x118>)
    1db6:	f002 fbe3 	bl	4580 <_print>
	info_msg("Result  Macros Range: R0 -> R");
    1dba:	481e      	ldr	r0, [pc, #120]	; (1e34 <cliFunc_macroList+0x14c>)
    1dbc:	f002 fbe0 	bl	4580 <_print>
	printInt16( (uint16_t)ResultMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    1dc0:	2060      	movs	r0, #96	; 0x60
    1dc2:	f002 fc2f 	bl	4624 <printInt16>

	// Show Trigger to Result Macro Links
	print( NL );
    1dc6:	480e      	ldr	r0, [pc, #56]	; (1e00 <cliFunc_macroList+0x118>)
    1dc8:	f002 fbda 	bl	4580 <_print>
	info_msg("Trigger : Result Macro Pairs");
    1dcc:	481a      	ldr	r0, [pc, #104]	; (1e38 <cliFunc_macroList+0x150>)
    1dce:	f002 fbd7 	bl	4580 <_print>
    1dd2:	2400      	movs	r4, #0
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
	{
		print( NL );
    1dd4:	480a      	ldr	r0, [pc, #40]	; (1e00 <cliFunc_macroList+0x118>)
    1dd6:	f002 fbd3 	bl	4580 <_print>
		print("\tT");
    1dda:	4818      	ldr	r0, [pc, #96]	; (1e3c <cliFunc_macroList+0x154>)
    1ddc:	f002 fbd0 	bl	4580 <_print>
		printInt16( (uint16_t)macro ); // Hopefully large enough :P (can't assume 32-bit)
    1de0:	b2a0      	uxth	r0, r4
    1de2:	f002 fc1f 	bl	4624 <printInt16>
		print(" : R");
    1de6:	4816      	ldr	r0, [pc, #88]	; (1e40 <cliFunc_macroList+0x158>)
    1de8:	f002 fbca 	bl	4580 <_print>
    1dec:	4b15      	ldr	r3, [pc, #84]	; (1e44 <cliFunc_macroList+0x15c>)
    1dee:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    1df2:	3401      	adds	r4, #1
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
    1df4:	7918      	ldrb	r0, [r3, #4]
    1df6:	f002 fc15 	bl	4624 <printInt16>
	printInt16( (uint16_t)ResultMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)

	// Show Trigger to Result Macro Links
	print( NL );
	info_msg("Trigger : Result Macro Pairs");
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    1dfa:	2c62      	cmp	r4, #98	; 0x62
    1dfc:	d1ea      	bne.n	1dd4 <cliFunc_macroList+0xec>
		print("\tT");
		printInt16( (uint16_t)macro ); // Hopefully large enough :P (can't assume 32-bit)
		print(" : R");
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
	}
}
    1dfe:	bd38      	pop	{r3, r4, r5, pc}
    1e00:	00006caf 	.word	0x00006caf
    1e04:	1ffff16a 	.word	0x1ffff16a
    1e08:	00005075 	.word	0x00005075
    1e0c:	0000509c 	.word	0x0000509c
    1e10:	1ffff920 	.word	0x1ffff920
    1e14:	00004a00 	.word	0x00004a00
    1e18:	1ffff174 	.word	0x1ffff174
    1e1c:	000050a0 	.word	0x000050a0
    1e20:	1ffff0a6 	.word	0x1ffff0a6
    1e24:	1ffff0a4 	.word	0x1ffff0a4
    1e28:	000050cb 	.word	0x000050cb
    1e2c:	1fffefe0 	.word	0x1fffefe0
    1e30:	000050f5 	.word	0x000050f5
    1e34:	00005125 	.word	0x00005125
    1e38:	00005155 	.word	0x00005155
    1e3c:	00005184 	.word	0x00005184
    1e40:	00005187 	.word	0x00005187
    1e44:	00005f28 	.word	0x00005f28

00001e48 <Macro_layerState.part.1>:


// ----- Capabilities -----

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
    1e48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		return;

	// Is layer in the LayerIndexStack?
	uint8_t inLayerIndexStack = 0;
	uint16_t stackItem = 0;
	while ( stackItem < macroLayerIndexStackSize )
    1e4a:	4d2a      	ldr	r5, [pc, #168]	; (1ef4 <Macro_layerState.part.1+0xac>)
    1e4c:	882e      	ldrh	r6, [r5, #0]
    1e4e:	2200      	movs	r2, #0
    1e50:	b293      	uxth	r3, r2
    1e52:	42b3      	cmp	r3, r6
    1e54:	d209      	bcs.n	1e6a <Macro_layerState.part.1+0x22>
    1e56:	4c28      	ldr	r4, [pc, #160]	; (1ef8 <Macro_layerState.part.1+0xb0>)
    1e58:	3201      	adds	r2, #1
    1e5a:	eb04 0442 	add.w	r4, r4, r2, lsl #1
	{
		// Flag if layer is already in the LayerIndexStack
		if ( macroLayerIndexStack[ stackItem ] == layer )
    1e5e:	f834 4c02 	ldrh.w	r4, [r4, #-2]
    1e62:	4284      	cmp	r4, r0
    1e64:	d1f4      	bne.n	1e50 <Macro_layerState.part.1+0x8>
		{
			inLayerIndexStack = 1;
    1e66:	2201      	movs	r2, #1
    1e68:	e000      	b.n	1e6c <Macro_layerState.part.1+0x24>
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
		return;

	// Is layer in the LayerIndexStack?
	uint8_t inLayerIndexStack = 0;
    1e6a:	2200      	movs	r2, #0
		// Increment to next item
		stackItem++;
	}

	// Toggle Layer State Byte
	if ( LayerState[ layer ] & layerState )
    1e6c:	4c23      	ldr	r4, [pc, #140]	; (1efc <Macro_layerState.part.1+0xb4>)
    1e6e:	5c27      	ldrb	r7, [r4, r0]
    1e70:	420f      	tst	r7, r1
	{
		// Unset
		LayerState[ layer ] &= ~layerState;
    1e72:	bf14      	ite	ne
    1e74:	ea27 0101 	bicne.w	r1, r7, r1
	}
	else
	{
		// Set
		LayerState[ layer ] |= layerState;
    1e78:	4339      	orreq	r1, r7
    1e7a:	5421      	strb	r1, [r4, r0]
	}

	// If the layer was not in the LayerIndexStack add it
	if ( !inLayerIndexStack )
    1e7c:	b922      	cbnz	r2, 1e88 <Macro_layerState.part.1+0x40>
	{
		macroLayerIndexStack[ macroLayerIndexStackSize++ ] = layer;
    1e7e:	1c71      	adds	r1, r6, #1
    1e80:	8029      	strh	r1, [r5, #0]
    1e82:	491d      	ldr	r1, [pc, #116]	; (1ef8 <Macro_layerState.part.1+0xb0>)
    1e84:	f821 0016 	strh.w	r0, [r1, r6, lsl #1]
	}

	// If the layer is in the LayerIndexStack and the state is 0x00, remove
	if ( LayerState[ layer ] == 0x00 && inLayerIndexStack )
    1e88:	5c21      	ldrb	r1, [r4, r0]
    1e8a:	b969      	cbnz	r1, 1ea8 <Macro_layerState.part.1+0x60>
    1e8c:	b162      	cbz	r2, 1ea8 <Macro_layerState.part.1+0x60>
	{
		// Remove the layer from the LayerIndexStack
		// Using the already positioned stackItem variable from the loop above
		while ( stackItem < macroLayerIndexStackSize )
    1e8e:	882a      	ldrh	r2, [r5, #0]
    1e90:	4293      	cmp	r3, r2
    1e92:	d207      	bcs.n	1ea4 <Macro_layerState.part.1+0x5c>
		{
			macroLayerIndexStack[ stackItem ] = macroLayerIndexStack[ stackItem + 1 ];
    1e94:	4818      	ldr	r0, [pc, #96]	; (1ef8 <Macro_layerState.part.1+0xb0>)
    1e96:	1c59      	adds	r1, r3, #1
    1e98:	f830 6011 	ldrh.w	r6, [r0, r1, lsl #1]
    1e9c:	f820 6013 	strh.w	r6, [r0, r3, lsl #1]
			stackItem++;
    1ea0:	b28b      	uxth	r3, r1
    1ea2:	e7f5      	b.n	1e90 <Macro_layerState.part.1+0x48>
		}

		// Reduce LayerIndexStack size
		macroLayerIndexStackSize--;
    1ea4:	3a01      	subs	r2, #1
    1ea6:	802a      	strh	r2, [r5, #0]
	}

	// Layer Debug Mode
	if ( layerDebugMode )
    1ea8:	4b15      	ldr	r3, [pc, #84]	; (1f00 <Macro_layerState.part.1+0xb8>)
    1eaa:	781b      	ldrb	r3, [r3, #0]
    1eac:	b303      	cbz	r3, 1ef0 <Macro_layerState.part.1+0xa8>
	{
		dbug_msg("Layer ");
    1eae:	4815      	ldr	r0, [pc, #84]	; (1f04 <Macro_layerState.part.1+0xbc>)
    1eb0:	f002 fb66 	bl	4580 <_print>

		// Iterate over each of the layers displaying the state as a hex value
		for ( uint16_t index = 0; index < LayerNum; index++ )
		{
			printHex_op( LayerState[ index ], 0 );
    1eb4:	7820      	ldrb	r0, [r4, #0]
    1eb6:	2100      	movs	r1, #0
    1eb8:	f002 fbeb 	bl	4692 <printHex_op>
    1ebc:	7860      	ldrb	r0, [r4, #1]
    1ebe:	2100      	movs	r1, #0
    1ec0:	f002 fbe7 	bl	4692 <printHex_op>
		}

		// Always show the default layer (it's always 0)
		print(" 0");
    1ec4:	4810      	ldr	r0, [pc, #64]	; (1f08 <Macro_layerState.part.1+0xc0>)
    1ec6:	f002 fb5b 	bl	4580 <_print>

		// Iterate over the layer stack starting from the bottom of the stack
		for ( uint16_t index = macroLayerIndexStackSize; index > 0; index-- )
    1eca:	882c      	ldrh	r4, [r5, #0]
    1ecc:	b15c      	cbz	r4, 1ee6 <Macro_layerState.part.1+0x9e>
		{
			print(":");
    1ece:	480f      	ldr	r0, [pc, #60]	; (1f0c <Macro_layerState.part.1+0xc4>)
    1ed0:	f002 fb56 	bl	4580 <_print>
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
    1ed4:	3c01      	subs	r4, #1
    1ed6:	4b08      	ldr	r3, [pc, #32]	; (1ef8 <Macro_layerState.part.1+0xb0>)
    1ed8:	2100      	movs	r1, #0
    1eda:	f833 0014 	ldrh.w	r0, [r3, r4, lsl #1]
    1ede:	f002 fbd8 	bl	4692 <printHex_op>

		// Always show the default layer (it's always 0)
		print(" 0");

		// Iterate over the layer stack starting from the bottom of the stack
		for ( uint16_t index = macroLayerIndexStackSize; index > 0; index-- )
    1ee2:	b2a4      	uxth	r4, r4
    1ee4:	e7f2      	b.n	1ecc <Macro_layerState.part.1+0x84>
		{
			print(":");
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
		}

		print( NL );
    1ee6:	480a      	ldr	r0, [pc, #40]	; (1f10 <Macro_layerState.part.1+0xc8>)
	}
}
    1ee8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		{
			print(":");
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
		}

		print( NL );
    1eec:	f002 bb48 	b.w	4580 <_print>
    1ef0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1ef2:	bf00      	nop
    1ef4:	1ffff16c 	.word	0x1ffff16c
    1ef8:	1ffff16e 	.word	0x1ffff16e
    1efc:	1ffffafd 	.word	0x1ffffafd
    1f00:	1ffff176 	.word	0x1ffff176
    1f04:	0000518c 	.word	0x0000518c
    1f08:	000051a6 	.word	0x000051a6
    1f0c:	00004a95 	.word	0x00004a95
    1f10:	00006caf 	.word	0x00006caf

00001f14 <Macro_layerState_capability>:
// Argument #1: Layer Index -> uint16_t
// Argument #2: Layer State -> uint8_t
void Macro_layerState_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1f14:	29ff      	cmp	r1, #255	; 0xff
    1f16:	d104      	bne.n	1f22 <Macro_layerState_capability+0xe>
    1f18:	28ff      	cmp	r0, #255	; 0xff
    1f1a:	d105      	bne.n	1f28 <Macro_layerState_capability+0x14>
	{
		print("Macro_layerState(layerIndex,layerState)");
    1f1c:	4806      	ldr	r0, [pc, #24]	; (1f38 <Macro_layerState_capability+0x24>)
    1f1e:	f002 bb2f 	b.w	4580 <_print>
	}

	// Only use capability on press or release
	// TODO Analog
	// XXX This may cause issues, might be better to implement state table here to decide -HaaTa
	if ( stateType == 0x00 && state == 0x02 ) // Hold condition
    1f22:	b909      	cbnz	r1, 1f28 <Macro_layerState_capability+0x14>
    1f24:	2802      	cmp	r0, #2
    1f26:	d005      	beq.n	1f34 <Macro_layerState_capability+0x20>

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    1f28:	8810      	ldrh	r0, [r2, #0]
	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	// Get layer toggle byte
	uint8_t layerState = args[ sizeof(uint16_t) ];
    1f2a:	7891      	ldrb	r1, [r2, #2]

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    1f2c:	2801      	cmp	r0, #1
    1f2e:	d101      	bne.n	1f34 <Macro_layerState_capability+0x20>
    1f30:	f7ff bf8a 	b.w	1e48 <Macro_layerState.part.1>
    1f34:	4770      	bx	lr
    1f36:	bf00      	nop
    1f38:	000051a9 	.word	0x000051a9

00001f3c <Macro_layerShift_capability>:
// Shifts given layer
// Argument #1: Layer Index -> uint16_t
void Macro_layerShift_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1f3c:	29ff      	cmp	r1, #255	; 0xff
    1f3e:	d104      	bne.n	1f4a <Macro_layerShift_capability+0xe>
    1f40:	28ff      	cmp	r0, #255	; 0xff
    1f42:	d106      	bne.n	1f52 <Macro_layerShift_capability+0x16>
	{
		print("Macro_layerShift(layerIndex)");
    1f44:	4806      	ldr	r0, [pc, #24]	; (1f60 <Macro_layerShift_capability+0x24>)
    1f46:	f002 bb1b 	b.w	4580 <_print>
		return;
	}

	// Only use capability on press or release
	// TODO Analog
	if ( stateType == 0x00 && ( state == 0x00 || state == 0x02 ) ) // Only pass press or release conditions
    1f4a:	b911      	cbnz	r1, 1f52 <Macro_layerShift_capability+0x16>
    1f4c:	f010 0ffd 	tst.w	r0, #253	; 0xfd
    1f50:	d005      	beq.n	1f5e <Macro_layerShift_capability+0x22>

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    1f52:	8810      	ldrh	r0, [r2, #0]
    1f54:	2801      	cmp	r0, #1
    1f56:	d102      	bne.n	1f5e <Macro_layerShift_capability+0x22>
    1f58:	4601      	mov	r1, r0
    1f5a:	f7ff bf75 	b.w	1e48 <Macro_layerState.part.1>
    1f5e:	4770      	bx	lr
    1f60:	000051d1 	.word	0x000051d1

00001f64 <Macro_layerLatch_capability>:
// Latches given layer
// Argument #1: Layer Index -> uint16_t
void Macro_layerLatch_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1f64:	29ff      	cmp	r1, #255	; 0xff
    1f66:	d104      	bne.n	1f72 <Macro_layerLatch_capability+0xe>
    1f68:	28ff      	cmp	r0, #255	; 0xff
    1f6a:	d105      	bne.n	1f78 <Macro_layerLatch_capability+0x14>
	{
		print("Macro_layerLatch(layerIndex)");
    1f6c:	4806      	ldr	r0, [pc, #24]	; (1f88 <Macro_layerLatch_capability+0x24>)
    1f6e:	f002 bb07 	b.w	4580 <_print>
		return;
	}

	// Only use capability on press
	// TODO Analog
	if ( stateType == 0x00 && state != 0x03 ) // Only on release
    1f72:	b909      	cbnz	r1, 1f78 <Macro_layerLatch_capability+0x14>
    1f74:	2803      	cmp	r0, #3
    1f76:	d105      	bne.n	1f84 <Macro_layerLatch_capability+0x20>

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    1f78:	8810      	ldrh	r0, [r2, #0]
    1f7a:	2801      	cmp	r0, #1
    1f7c:	d102      	bne.n	1f84 <Macro_layerLatch_capability+0x20>
    1f7e:	2102      	movs	r1, #2
    1f80:	f7ff bf62 	b.w	1e48 <Macro_layerState.part.1>
    1f84:	4770      	bx	lr
    1f86:	bf00      	nop
    1f88:	000051ee 	.word	0x000051ee

00001f8c <Macro_layerLock_capability>:
// Locks given layer
// Argument #1: Layer Index -> uint16_t
void Macro_layerLock_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1f8c:	29ff      	cmp	r1, #255	; 0xff
    1f8e:	d104      	bne.n	1f9a <Macro_layerLock_capability+0xe>
    1f90:	28ff      	cmp	r0, #255	; 0xff
    1f92:	d105      	bne.n	1fa0 <Macro_layerLock_capability+0x14>
	{
		print("Macro_layerLock(layerIndex)");
    1f94:	4806      	ldr	r0, [pc, #24]	; (1fb0 <Macro_layerLock_capability+0x24>)
    1f96:	f002 baf3 	b.w	4580 <_print>
	}

	// Only use capability on press
	// TODO Analog
	// XXX Could also be on release, but that's sorta dumb -HaaTa
	if ( stateType == 0x00 && state != 0x01 ) // All normal key conditions except press
    1f9a:	b909      	cbnz	r1, 1fa0 <Macro_layerLock_capability+0x14>
    1f9c:	2801      	cmp	r0, #1
    1f9e:	d105      	bne.n	1fac <Macro_layerLock_capability+0x20>

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    1fa0:	8810      	ldrh	r0, [r2, #0]
    1fa2:	2801      	cmp	r0, #1
    1fa4:	d102      	bne.n	1fac <Macro_layerLock_capability+0x20>
    1fa6:	2104      	movs	r1, #4
    1fa8:	f7ff bf4e 	b.w	1e48 <Macro_layerState.part.1>
    1fac:	4770      	bx	lr
    1fae:	bf00      	nop
    1fb0:	0000520b 	.word	0x0000520b

00001fb4 <Macro_layerRotate_capability>:
// Layers are still evaluated using the layer stack
uint16_t Macro_rotationLayer;
void Macro_layerRotate_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1fb4:	29ff      	cmp	r1, #255	; 0xff
// Rotate layer to next/previous
// Uses state variable to keep track of the current layer position
// Layers are still evaluated using the layer stack
uint16_t Macro_rotationLayer;
void Macro_layerRotate_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    1fb6:	b538      	push	{r3, r4, r5, lr}
    1fb8:	4615      	mov	r5, r2
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    1fba:	d106      	bne.n	1fca <Macro_layerRotate_capability+0x16>
    1fbc:	28ff      	cmp	r0, #255	; 0xff
    1fbe:	d107      	bne.n	1fd0 <Macro_layerRotate_capability+0x1c>
	{
		print("Macro_layerRotate(previous)");
    1fc0:	4814      	ldr	r0, [pc, #80]	; (2014 <Macro_layerRotate_capability+0x60>)
			Macro_rotationLayer = LayerNum - 1;
	}

	// Toggle the computed layer rotation
	Macro_layerState( state, stateType, Macro_rotationLayer, 0x04 );
}
    1fc2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void Macro_layerRotate_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
	{
		print("Macro_layerRotate(previous)");
    1fc6:	f002 badb 	b.w	4580 <_print>
	}

	// Only use capability on press
	// TODO Analog
	// XXX Could also be on release, but that's sorta dumb -HaaTa
	if ( stateType == 0x00 && state != 0x01 ) // All normal key conditions except press
    1fca:	b909      	cbnz	r1, 1fd0 <Macro_layerRotate_capability+0x1c>
    1fcc:	2801      	cmp	r0, #1
    1fce:	d11f      	bne.n	2010 <Macro_layerRotate_capability+0x5c>
		return;

	// Unset previous rotation layer if not 0
	if ( Macro_rotationLayer != 0 )
    1fd0:	4c11      	ldr	r4, [pc, #68]	; (2018 <Macro_layerRotate_capability+0x64>)

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    1fd2:	8820      	ldrh	r0, [r4, #0]
    1fd4:	2801      	cmp	r0, #1
    1fd6:	d102      	bne.n	1fde <Macro_layerRotate_capability+0x2a>
    1fd8:	2104      	movs	r1, #4
    1fda:	f7ff ff35 	bl	1e48 <Macro_layerState.part.1>

	// Get direction of rotation, 0, next, non-zero previous
	uint8_t direction = *args;

	// Next
	if ( !direction )
    1fde:	782a      	ldrb	r2, [r5, #0]
	{
		Macro_rotationLayer++;
    1fe0:	4b0d      	ldr	r3, [pc, #52]	; (2018 <Macro_layerRotate_capability+0x64>)

	// Get direction of rotation, 0, next, non-zero previous
	uint8_t direction = *args;

	// Next
	if ( !direction )
    1fe2:	b932      	cbnz	r2, 1ff2 <Macro_layerRotate_capability+0x3e>
	{
		Macro_rotationLayer++;
    1fe4:	8821      	ldrh	r1, [r4, #0]
    1fe6:	3101      	adds	r1, #1
    1fe8:	b289      	uxth	r1, r1

		// Invalid layer
		if ( Macro_rotationLayer >= LayerNum )
    1fea:	2901      	cmp	r1, #1
    1fec:	d807      	bhi.n	1ffe <Macro_layerRotate_capability+0x4a>
	uint8_t direction = *args;

	// Next
	if ( !direction )
	{
		Macro_rotationLayer++;
    1fee:	8019      	strh	r1, [r3, #0]
    1ff0:	e006      	b.n	2000 <Macro_layerRotate_capability+0x4c>
			Macro_rotationLayer = 0;
	}
	// Previous
	else
	{
		Macro_rotationLayer--;
    1ff2:	8822      	ldrh	r2, [r4, #0]
    1ff4:	3a01      	subs	r2, #1
    1ff6:	b292      	uxth	r2, r2

		// Layer wrap
		if ( Macro_rotationLayer >= LayerNum )
    1ff8:	2a01      	cmp	r2, #1
			Macro_rotationLayer = LayerNum - 1;
    1ffa:	bf88      	it	hi
    1ffc:	2201      	movhi	r2, #1
    1ffe:	801a      	strh	r2, [r3, #0]

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    2000:	8820      	ldrh	r0, [r4, #0]
    2002:	2801      	cmp	r0, #1
    2004:	d104      	bne.n	2010 <Macro_layerRotate_capability+0x5c>
    2006:	2104      	movs	r1, #4
			Macro_rotationLayer = LayerNum - 1;
	}

	// Toggle the computed layer rotation
	Macro_layerState( state, stateType, Macro_rotationLayer, 0x04 );
}
    2008:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    200c:	f7ff bf1c 	b.w	1e48 <Macro_layerState.part.1>
    2010:	bd38      	pop	{r3, r4, r5, pc}
    2012:	bf00      	nop
    2014:	00005227 	.word	0x00005227
    2018:	1ffff91e 	.word	0x1ffff91e

0000201c <Macro_layerLookup>:
// ----- Functions -----

// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Macro_layerLookup( TriggerGuide *guide, uint8_t latch_expire )
{
    201c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t scanCode = guide->scanCode;

	// TODO Analog
	// If a normal key, and not pressed, do a layer cache lookup
	if ( guide->type == 0x00 && guide->state != 0x01 )
    2020:	7803      	ldrb	r3, [r0, #0]

// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Macro_layerLookup( TriggerGuide *guide, uint8_t latch_expire )
{
	uint8_t scanCode = guide->scanCode;
    2022:	7884      	ldrb	r4, [r0, #2]
// ----- Functions -----

// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Macro_layerLookup( TriggerGuide *guide, uint8_t latch_expire )
{
    2024:	460f      	mov	r7, r1
	uint8_t scanCode = guide->scanCode;

	// TODO Analog
	// If a normal key, and not pressed, do a layer cache lookup
	if ( guide->type == 0x00 && guide->state != 0x01 )
    2026:	b9cb      	cbnz	r3, 205c <Macro_layerLookup+0x40>
    2028:	7843      	ldrb	r3, [r0, #1]
    202a:	2b01      	cmp	r3, #1
    202c:	d016      	beq.n	205c <Macro_layerLookup+0x40>
	{
		// Cached layer
		var_uint_t cachedLayer = macroTriggerListLayerCache[ scanCode ];
    202e:	4b3a      	ldr	r3, [pc, #232]	; (2118 <Macro_layerLookup+0xfc>)

		// Lookup map, then layer
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    2030:	4a3a      	ldr	r2, [pc, #232]	; (211c <Macro_layerLookup+0x100>)
	// TODO Analog
	// If a normal key, and not pressed, do a layer cache lookup
	if ( guide->type == 0x00 && guide->state != 0x01 )
	{
		// Cached layer
		var_uint_t cachedLayer = macroTriggerListLayerCache[ scanCode ];
    2032:	5d18      	ldrb	r0, [r3, r4]

		// Lookup map, then layer
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    2034:	230c      	movs	r3, #12
    2036:	4343      	muls	r3, r0
    2038:	18d1      	adds	r1, r2, r3
		const Layer *layer = &LayerIndex[ cachedLayer ];

		// Cache trigger list before attempting to expire latch
		nat_ptr_t *trigger_list = map[ scanCode - layer->first ];
    203a:	58d3      	ldr	r3, [r2, r3]
    203c:	7a09      	ldrb	r1, [r1, #8]
    203e:	1a64      	subs	r4, r4, r1
    2040:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]

		// Check if latch has been pressed for this layer
		uint8_t latch = LayerState[ cachedLayer ] & 0x02;
    2044:	4b36      	ldr	r3, [pc, #216]	; (2120 <Macro_layerLookup+0x104>)
    2046:	5c1b      	ldrb	r3, [r3, r0]
		if ( latch && latch_expire )
    2048:	079b      	lsls	r3, r3, #30
    204a:	d561      	bpl.n	2110 <Macro_layerLookup+0xf4>
    204c:	2f00      	cmp	r7, #0
    204e:	d05f      	beq.n	2110 <Macro_layerLookup+0xf4>

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    2050:	2801      	cmp	r0, #1
    2052:	d15d      	bne.n	2110 <Macro_layerLookup+0xf4>
    2054:	2102      	movs	r1, #2
    2056:	f7ff fef7 	bl	1e48 <Macro_layerState.part.1>
    205a:	e059      	b.n	2110 <Macro_layerLookup+0xf4>

		return trigger_list;
	}

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    205c:	4b31      	ldr	r3, [pc, #196]	; (2124 <Macro_layerLookup+0x108>)
    205e:	881d      	ldrh	r5, [r3, #0]
    2060:	f64f 73ff 	movw	r3, #65535	; 0xffff
    2064:	429d      	cmp	r5, r3
    2066:	d03a      	beq.n	20de <Macro_layerLookup+0xc2>
	{
		// Lookup Layer
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    2068:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 2134 <Macro_layerLookup+0x118>

		// Check if latch has been pressed for this layer
		// XXX Regardless of whether a key is found, the latch is removed on first lookup
		uint8_t latch = LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x02;
    206c:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 2120 <Macro_layerLookup+0x104>

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
	{
		// Lookup Layer
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    2070:	f839 6015 	ldrh.w	r6, [r9, r5, lsl #1]

		// Check if latch has been pressed for this layer
		// XXX Regardless of whether a key is found, the latch is removed on first lookup
		uint8_t latch = LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x02;
    2074:	f818 3006 	ldrb.w	r3, [r8, r6]
    2078:	f003 0302 	and.w	r3, r3, #2
		if ( latch && latch_expire )
    207c:	f003 0aff 	and.w	sl, r3, #255	; 0xff
    2080:	b133      	cbz	r3, 2090 <Macro_layerLookup+0x74>
    2082:	b12f      	cbz	r7, 2090 <Macro_layerLookup+0x74>

// Sets the given layer with the specified layerState
void Macro_layerState( uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
{
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
    2084:	2e01      	cmp	r6, #1
    2086:	d103      	bne.n	2090 <Macro_layerLookup+0x74>
    2088:	4630      	mov	r0, r6
    208a:	2102      	movs	r1, #2
    208c:	f7ff fedc 	bl	1e48 <Macro_layerState.part.1>
		}

		// Only use layer, if state is valid
		// XOR each of the state bits
		// If only two are enabled, do not use this state
		if ( (LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x01) ^ (latch>>1) ^ ((LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x04)>>2) )
    2090:	f839 2015 	ldrh.w	r2, [r9, r5, lsl #1]
    2094:	f818 3002 	ldrb.w	r3, [r8, r2]
    2098:	f003 0101 	and.w	r1, r3, #1
    209c:	ea81 0a5a 	eor.w	sl, r1, sl, lsr #1
    20a0:	f3c3 0380 	ubfx	r3, r3, #2, #1
    20a4:	459a      	cmp	sl, r3
    20a6:	d017      	beq.n	20d8 <Macro_layerLookup+0xbc>

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
	{
		// Lookup Layer
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    20a8:	210c      	movs	r1, #12
    20aa:	4b1c      	ldr	r3, [pc, #112]	; (211c <Macro_layerLookup+0x100>)
    20ac:	434e      	muls	r6, r1
    20ae:	1999      	adds	r1, r3, r6
		// XOR each of the state bits
		// If only two are enabled, do not use this state
		if ( (LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x01) ^ (latch>>1) ^ ((LayerState[ macroLayerIndexStack[ layerIndex ] ] & 0x04)>>2) )
		{
			// Lookup layer
			nat_ptr_t **map = (nat_ptr_t**)layer->triggerMap;
    20b0:	599b      	ldr	r3, [r3, r6]

			// Determine if layer has key defined
			// Make sure scanCode is between layer first and last scancodes
			if ( map != 0
    20b2:	b18b      	cbz	r3, 20d8 <Macro_layerLookup+0xbc>
				&& scanCode <= layer->last
    20b4:	7a48      	ldrb	r0, [r1, #9]
    20b6:	42a0      	cmp	r0, r4
    20b8:	d30e      	bcc.n	20d8 <Macro_layerLookup+0xbc>
				&& scanCode >= layer->first
    20ba:	7a09      	ldrb	r1, [r1, #8]
    20bc:	428c      	cmp	r4, r1
    20be:	d30b      	bcc.n	20d8 <Macro_layerLookup+0xbc>
				&& *map[ scanCode - layer->first ] != 0 )
    20c0:	1a61      	subs	r1, r4, r1
    20c2:	eb03 0081 	add.w	r0, r3, r1, lsl #2
    20c6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    20ca:	681b      	ldr	r3, [r3, #0]
    20cc:	b123      	cbz	r3, 20d8 <Macro_layerLookup+0xbc>
			{
				// Set the layer cache
				macroTriggerListLayerCache[ scanCode ] = macroLayerIndexStack[ layerIndex ];
    20ce:	4b12      	ldr	r3, [pc, #72]	; (2118 <Macro_layerLookup+0xfc>)
    20d0:	551a      	strb	r2, [r3, r4]

				return map[ scanCode - layer->first ];
    20d2:	6800      	ldr	r0, [r0, #0]
    20d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

		return trigger_list;
	}

	// If no trigger macro is defined at the given layer, fallthrough to the next layer
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    20d8:	3d01      	subs	r5, #1
    20da:	b2ad      	uxth	r5, r5
    20dc:	e7c0      	b.n	2060 <Macro_layerLookup+0x44>
	// Lookup default layer
	const Layer *layer = &LayerIndex[0];

	// Make sure scanCode is between layer first and last scancodes
	if ( map != 0
		&& scanCode <= layer->last
    20de:	2c3e      	cmp	r4, #62	; 0x3e
    20e0:	d809      	bhi.n	20f6 <Macro_layerLookup+0xda>
		&& scanCode >= layer->first
		&& *map[ scanCode - layer->first ] != 0 )
    20e2:	4b11      	ldr	r3, [pc, #68]	; (2128 <Macro_layerLookup+0x10c>)
    20e4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    20e8:	6803      	ldr	r3, [r0, #0]
    20ea:	b123      	cbz	r3, 20f6 <Macro_layerLookup+0xda>
	{
		// Set the layer cache to default map
		macroTriggerListLayerCache[ scanCode ] = 0;
    20ec:	4b0a      	ldr	r3, [pc, #40]	; (2118 <Macro_layerLookup+0xfc>)
    20ee:	2200      	movs	r2, #0
    20f0:	551a      	strb	r2, [r3, r4]

		return map[ scanCode - layer->first ];
    20f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}

	// Otherwise no defined Trigger Macro
	erro_msg("Scan Code has no defined Trigger Macro: ");
    20f6:	480d      	ldr	r0, [pc, #52]	; (212c <Macro_layerLookup+0x110>)
    20f8:	f002 fa42 	bl	4580 <_print>
	printHex( scanCode );
    20fc:	4620      	mov	r0, r4
    20fe:	2101      	movs	r1, #1
    2100:	f002 fac7 	bl	4692 <printHex_op>
	print( NL );
    2104:	480a      	ldr	r0, [pc, #40]	; (2130 <Macro_layerLookup+0x114>)
    2106:	f002 fa3b 	bl	4580 <_print>
	return 0;
    210a:	2000      	movs	r0, #0
    210c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			extern void LCD_layerStack_capability( uint8_t state, uint8_t stateType, uint8_t *args );
			LCD_layerStack_capability( 0, 0, 0 );
#endif
		}

		return trigger_list;
    2110:	4620      	mov	r0, r4
	// Otherwise no defined Trigger Macro
	erro_msg("Scan Code has no defined Trigger Macro: ");
	printHex( scanCode );
	print( NL );
	return 0;
}
    2112:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2116:	bf00      	nop
    2118:	1ffffaff 	.word	0x1ffffaff
    211c:	00005e94 	.word	0x00005e94
    2120:	1ffffafd 	.word	0x1ffffafd
    2124:	1ffff16c 	.word	0x1ffff16c
    2128:	1fffe9b4 	.word	0x1fffe9b4
    212c:	00005243 	.word	0x00005243
    2130:	00006caf 	.word	0x00006caf
    2134:	1ffff16e 	.word	0x1ffff16e

00002138 <Macro_keyState>:
		}
	}
#endif

	// Only add to macro trigger list if one of three states
	switch ( state )
    2138:	1e4b      	subs	r3, r1, #1
    213a:	2b02      	cmp	r3, #2
//   * 0x01 - Pressed
//   * 0x02 - Held
//   * 0x03 - Released
//   * 0x04 - Unpressed (this is currently ignored)
inline void Macro_keyState( uint8_t scanCode, uint8_t state )
{
    213c:	b570      	push	{r4, r5, r6, lr}
    213e:	4604      	mov	r4, r0
		}
	}
#endif

	// Only add to macro trigger list if one of three states
	switch ( state )
    2140:	d819      	bhi.n	2176 <Macro_keyState+0x3e>
	{
	case 0x01: // Pressed
	case 0x02: // Held
	case 0x03: // Released
		// Check if ScanCode is out of range
		if ( scanCode > MaxScanCode )
    2142:	283e      	cmp	r0, #62	; 0x3e
    2144:	d90b      	bls.n	215e <Macro_keyState+0x26>
		{
			warn_msg("ScanCode is out of range/not defined: ");
    2146:	480c      	ldr	r0, [pc, #48]	; (2178 <Macro_keyState+0x40>)
    2148:	f002 fa1a 	bl	4580 <_print>
			printHex( scanCode );
    214c:	4620      	mov	r0, r4
    214e:	2101      	movs	r1, #1
    2150:	f002 fa9f 	bl	4692 <printHex_op>
			print( NL );
    2154:	4809      	ldr	r0, [pc, #36]	; (217c <Macro_keyState+0x44>)
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
		macroTriggerListBufferSize++;
		break;
	}
}
    2156:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		// Check if ScanCode is out of range
		if ( scanCode > MaxScanCode )
		{
			warn_msg("ScanCode is out of range/not defined: ");
			printHex( scanCode );
			print( NL );
    215a:	f002 ba11 	b.w	4580 <_print>
			return;
		}

		macroTriggerListBuffer[ macroTriggerListBufferSize ].scanCode = scanCode;
    215e:	4a08      	ldr	r2, [pc, #32]	; (2180 <Macro_keyState+0x48>)
    2160:	4d08      	ldr	r5, [pc, #32]	; (2184 <Macro_keyState+0x4c>)
    2162:	7813      	ldrb	r3, [r2, #0]
    2164:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    2168:	182e      	adds	r6, r5, r0
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
		macroTriggerListBufferSize++;
    216a:	3301      	adds	r3, #1
			print( NL );
			return;
		}

		macroTriggerListBuffer[ macroTriggerListBufferSize ].scanCode = scanCode;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
    216c:	7071      	strb	r1, [r6, #1]
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
    216e:	2100      	movs	r1, #0
			printHex( scanCode );
			print( NL );
			return;
		}

		macroTriggerListBuffer[ macroTriggerListBufferSize ].scanCode = scanCode;
    2170:	70b4      	strb	r4, [r6, #2]
		macroTriggerListBuffer[ macroTriggerListBufferSize ].state    = state;
		macroTriggerListBuffer[ macroTriggerListBufferSize ].type     = 0x00; // Normal key
    2172:	5429      	strb	r1, [r5, r0]
		macroTriggerListBufferSize++;
    2174:	7013      	strb	r3, [r2, #0]
    2176:	bd70      	pop	{r4, r5, r6, pc}
    2178:	00005281 	.word	0x00005281
    217c:	00006caf 	.word	0x00006caf
    2180:	1ffff16a 	.word	0x1ffff16a
    2184:	1ffff920 	.word	0x1ffff920

00002188 <cliFunc_keyHold>:
		}
	}
}

void cliFunc_keyHold( char* args )
{
    2188:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    218a:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    218c:	9801      	ldr	r0, [sp, #4]
    218e:	4669      	mov	r1, sp
    2190:	aa01      	add	r2, sp, #4
    2192:	f001 ff3f 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    2196:	9800      	ldr	r0, [sp, #0]
    2198:	7803      	ldrb	r3, [r0, #0]
    219a:	b14b      	cbz	r3, 21b0 <cliFunc_keyHold+0x28>
			break;

		// Ignore non-Scancode numbers
		switch ( arg1Ptr[0] )
    219c:	2b53      	cmp	r3, #83	; 0x53
    219e:	d1f5      	bne.n	218c <cliFunc_keyHold+0x4>
		{
		// Scancode
		case 'S':
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x02 ); // Hold scancode
    21a0:	3001      	adds	r0, #1
    21a2:	f002 facb 	bl	473c <numToInt>
    21a6:	2102      	movs	r1, #2
    21a8:	b2c0      	uxtb	r0, r0
    21aa:	f7ff ffc5 	bl	2138 <Macro_keyState>
			break;
    21ae:	e7ed      	b.n	218c <cliFunc_keyHold+0x4>
		}
	}
}
    21b0:	b003      	add	sp, #12
    21b2:	f85d fb04 	ldr.w	pc, [sp], #4

000021b6 <cliFunc_keyPress>:

void cliFunc_keyPress( char* args )
{
    21b6:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    21b8:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    21ba:	9801      	ldr	r0, [sp, #4]
    21bc:	4669      	mov	r1, sp
    21be:	aa01      	add	r2, sp, #4
    21c0:	f001 ff28 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    21c4:	9800      	ldr	r0, [sp, #0]
    21c6:	7803      	ldrb	r3, [r0, #0]
    21c8:	b14b      	cbz	r3, 21de <cliFunc_keyPress+0x28>
			break;

		// Ignore non-Scancode numbers
		switch ( arg1Ptr[0] )
    21ca:	2b53      	cmp	r3, #83	; 0x53
    21cc:	d1f5      	bne.n	21ba <cliFunc_keyPress+0x4>
		{
		// Scancode
		case 'S':
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x01 ); // Press scancode
    21ce:	3001      	adds	r0, #1
    21d0:	f002 fab4 	bl	473c <numToInt>
    21d4:	2101      	movs	r1, #1
    21d6:	b2c0      	uxtb	r0, r0
    21d8:	f7ff ffae 	bl	2138 <Macro_keyState>
			break;
    21dc:	e7ed      	b.n	21ba <cliFunc_keyPress+0x4>
		}
	}
}
    21de:	b003      	add	sp, #12
    21e0:	f85d fb04 	ldr.w	pc, [sp], #4

000021e4 <cliFunc_keyRelease>:

void cliFunc_keyRelease( char* args )
{
    21e4:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    21e6:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    21e8:	9801      	ldr	r0, [sp, #4]
    21ea:	4669      	mov	r1, sp
    21ec:	aa01      	add	r2, sp, #4
    21ee:	f001 ff11 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    21f2:	9800      	ldr	r0, [sp, #0]
    21f4:	7803      	ldrb	r3, [r0, #0]
    21f6:	b14b      	cbz	r3, 220c <cliFunc_keyRelease+0x28>
			break;

		// Ignore non-Scancode numbers
		switch ( arg1Ptr[0] )
    21f8:	2b53      	cmp	r3, #83	; 0x53
    21fa:	d1f5      	bne.n	21e8 <cliFunc_keyRelease+0x4>
		{
		// Scancode
		case 'S':
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x03 ); // Release scancode
    21fc:	3001      	adds	r0, #1
    21fe:	f002 fa9d 	bl	473c <numToInt>
    2202:	2103      	movs	r1, #3
    2204:	b2c0      	uxtb	r0, r0
    2206:	f7ff ff97 	bl	2138 <Macro_keyState>
			break;
    220a:	e7ed      	b.n	21e8 <cliFunc_keyRelease+0x4>
		}
	}
}
    220c:	b003      	add	sp, #12
    220e:	f85d fb04 	ldr.w	pc, [sp], #4
    2212:	0000      	movs	r0, r0

00002214 <Macro_evalTriggerMacro>:
}


// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    2214:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    2218:	f8df 8230 	ldr.w	r8, [pc, #560]	; 244c <Macro_evalTriggerMacro+0x238>

// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    221c:	4f83      	ldr	r7, [pc, #524]	; (242c <Macro_evalTriggerMacro+0x218>)
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    221e:	eb08 0640 	add.w	r6, r8, r0, lsl #1
}


// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    2222:	b087      	sub	sp, #28
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
    2224:	7872      	ldrb	r2, [r6, #1]

// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    2226:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
    222a:	2a01      	cmp	r2, #1
}


// Evaluate/Update TriggerMacro
TriggerMacroEval Macro_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    222c:	4681      	mov	r9, r0
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    222e:	9303      	str	r3, [sp, #12]
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
    2230:	d10c      	bne.n	224c <Macro_evalTriggerMacro+0x38>
	{
		record->state = TriggerMacro_Waiting;
		record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
    2232:	f818 1010 	ldrb.w	r1, [r8, r0, lsl #1]
    2236:	f857 0030 	ldr.w	r0, [r7, r0, lsl #3]
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];

	// Check if macro has finished and should be incremented sequence elements
	if ( record->state == TriggerMacro_Release )
	{
		record->state = TriggerMacro_Waiting;
    223a:	2202      	movs	r2, #2
    223c:	7072      	strb	r2, [r6, #1]
		record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
    223e:	5c42      	ldrb	r2, [r0, r1]
    2240:	1c4c      	adds	r4, r1, #1
    2242:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    2246:	4422      	add	r2, r4
    2248:	f808 2019 	strb.w	r2, [r8, r9, lsl #1]
	}

	// Current Macro position
	var_uint_t pos = record->pos;
    224c:	f818 3019 	ldrb.w	r3, [r8, r9, lsl #1]

	// Length of the combo being processed
	uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    2250:	f857 2039 	ldr.w	r2, [r7, r9, lsl #3]
		record->state = TriggerMacro_Waiting;
		record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
	}

	// Current Macro position
	var_uint_t pos = record->pos;
    2254:	9301      	str	r3, [sp, #4]

	// Length of the combo being processed
	uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    2256:	5cd1      	ldrb	r1, [r2, r3]
    2258:	eb01 0141 	add.w	r1, r1, r1, lsl #1

	// If no combo items are left, remove the TriggerMacro from the pending list
	if ( comboLength == 0 )
    225c:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
    2260:	9104      	str	r1, [sp, #16]
    2262:	d101      	bne.n	2268 <Macro_evalTriggerMacro+0x54>
	{
		return TriggerMacroEval_Remove;
    2264:	2003      	movs	r0, #3
    2266:	e0de      	b.n	2426 <Macro_evalTriggerMacro+0x212>
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    2268:	7811      	ldrb	r1, [r2, #0]
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    226a:	9b01      	ldr	r3, [sp, #4]
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    226c:	2003      	movs	r0, #3
    226e:	fb00 2201 	mla	r2, r0, r1, r2
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    2272:	f103 0a01 	add.w	sl, r3, #1
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    2276:	7855      	ldrb	r5, [r2, #1]
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    2278:	fa5f fa8a 	uxtb.w	sl, sl
	// On scan after position increment, change to TriggerMacro_Waiting state
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    227c:	2400      	movs	r4, #0
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    227e:	9901      	ldr	r1, [sp, #4]
    2280:	9b04      	ldr	r3, [sp, #16]
    2282:	4419      	add	r1, r3
    2284:	4551      	cmp	r1, sl
    2286:	db72      	blt.n	236e <Macro_evalTriggerMacro+0x15a>
	{
		// Assign TriggerGuide element (key type, state and scancode)
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    2288:	9b03      	ldr	r3, [sp, #12]
    228a:	681a      	ldr	r2, [r3, #0]

		TriggerMacroVote vote = TriggerMacroVote_Invalid;
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    228c:	f04f 0b00 	mov.w	fp, #0
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
	{
		// Assign TriggerGuide element (key type, state and scancode)
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    2290:	4452      	add	r2, sl
    2292:	9202      	str	r2, [sp, #8]

		TriggerMacroVote vote = TriggerMacroVote_Invalid;
    2294:	465a      	mov	r2, fp
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    2296:	4966      	ldr	r1, [pc, #408]	; (2430 <Macro_evalTriggerMacro+0x21c>)
    2298:	7808      	ldrb	r0, [r1, #0]
    229a:	fa5f f18b 	uxtb.w	r1, fp
    229e:	4288      	cmp	r0, r1
    22a0:	d95a      	bls.n	2358 <Macro_evalTriggerMacro+0x144>
		{
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];
    22a2:	4864      	ldr	r0, [pc, #400]	; (2434 <Macro_evalTriggerMacro+0x220>)
    22a4:	9b02      	ldr	r3, [sp, #8]

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    22a6:	b2d2      	uxtb	r2, r2
		TriggerMacroVote vote = TriggerMacroVote_Invalid;
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
		{
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];
    22a8:	eb01 0141 	add.w	r1, r1, r1, lsl #1

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    22ac:	9205      	str	r2, [sp, #20]
		TriggerMacroVote vote = TriggerMacroVote_Invalid;
		// Iterate through the key buffer, comparing to each key in the combo
		for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
		{
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];
    22ae:	4401      	add	r1, r0
    22b0:	781a      	ldrb	r2, [r3, #0]

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    22b2:	b335      	cbz	r5, 2302 <Macro_evalTriggerMacro+0xee>
// Votes on the given key vs. guide, long macros
// A long macro is defined as a guide with more than 1 combo
inline TriggerMacroVote Macro_evalLongTriggerMacroVote( TriggerGuide *key, TriggerGuide *guide )
{
	// Depending on key type
	switch ( guide->type )
    22b4:	2a01      	cmp	r2, #1
    22b6:	d01d      	beq.n	22f4 <Macro_evalTriggerMacro+0xe0>
    22b8:	d303      	bcc.n	22c2 <Macro_evalTriggerMacro+0xae>
    22ba:	2a02      	cmp	r2, #2
    22bc:	d11c      	bne.n	22f8 <Macro_evalTriggerMacro+0xe4>
		erro_print("LED State Type - Not implemented...");
		break;

	// Analog State Type
	case 0x02:
		erro_print("Analog State Type - Not implemented...");
    22be:	485e      	ldr	r0, [pc, #376]	; (2438 <Macro_evalTriggerMacro+0x224>)
    22c0:	e01b      	b.n	22fa <Macro_evalTriggerMacro+0xe6>
	{
	// Normal State Type
	case 0x00:
		// Depending on the state of the buffered key, make voting decision
		// Incorrect key
		if ( guide->scanCode != key->scanCode )
    22c2:	9b02      	ldr	r3, [sp, #8]
    22c4:	788a      	ldrb	r2, [r1, #2]
    22c6:	7898      	ldrb	r0, [r3, #2]
    22c8:	4290      	cmp	r0, r2
    22ca:	784a      	ldrb	r2, [r1, #1]
    22cc:	d009      	beq.n	22e2 <Macro_evalTriggerMacro+0xce>
		{
			switch ( key->state )
    22ce:	2a02      	cmp	r2, #2
    22d0:	d039      	beq.n	2346 <Macro_evalTriggerMacro+0x132>
    22d2:	2a03      	cmp	r2, #3
    22d4:	d003      	beq.n	22de <Macro_evalTriggerMacro+0xca>
		erro_print("Invalid State Type. This is a bug.");
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    22d6:	1e51      	subs	r1, r2, #1
    22d8:	424a      	negs	r2, r1
    22da:	414a      	adcs	r2, r1
    22dc:	e033      	b.n	2346 <Macro_evalTriggerMacro+0x132>
			case 0x02:
				return TriggerMacroVote_DoNothing;

			// Wrong key released, fail out if pos == 0
			case 0x03:
				return TriggerMacroVote_DoNothing | TriggerMacroVote_DoNothingRelease;
    22de:	2206      	movs	r2, #6
    22e0:	e031      	b.n	2346 <Macro_evalTriggerMacro+0x132>
		}

		// Correct key
		else
		{
			switch ( key->state )
    22e2:	2a02      	cmp	r2, #2
    22e4:	d02e      	beq.n	2344 <Macro_evalTriggerMacro+0x130>
    22e6:	2a03      	cmp	r2, #3
    22e8:	d021      	beq.n	232e <Macro_evalTriggerMacro+0x11a>
		erro_print("Invalid State Type. This is a bug.");
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    22ea:	2a01      	cmp	r2, #1
    22ec:	bf0c      	ite	eq
    22ee:	2208      	moveq	r2, #8
    22f0:	2200      	movne	r2, #0
    22f2:	e028      	b.n	2346 <Macro_evalTriggerMacro+0x132>

		break;

	// LED State Type
	case 0x01:
		erro_print("LED State Type - Not implemented...");
    22f4:	4851      	ldr	r0, [pc, #324]	; (243c <Macro_evalTriggerMacro+0x228>)
    22f6:	e000      	b.n	22fa <Macro_evalTriggerMacro+0xe6>
		erro_print("Analog State Type - Not implemented...");
		break;

	// Invalid State Type
	default:
		erro_print("Invalid State Type. This is a bug.");
    22f8:	4851      	ldr	r0, [pc, #324]	; (2440 <Macro_evalTriggerMacro+0x22c>)
    22fa:	f002 f941 	bl	4580 <_print>
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    22fe:	2200      	movs	r2, #0
    2300:	e021      	b.n	2346 <Macro_evalTriggerMacro+0x132>

// Votes on the given key vs. guide, short macros
inline TriggerMacroVote Macro_evalShortTriggerMacroVote( TriggerGuide *key, TriggerGuide *guide )
{
	// Depending on key type
	switch ( guide->type )
    2302:	2a01      	cmp	r2, #1
    2304:	d015      	beq.n	2332 <Macro_evalTriggerMacro+0x11e>
    2306:	d303      	bcc.n	2310 <Macro_evalTriggerMacro+0xfc>
    2308:	2a02      	cmp	r2, #2
    230a:	d114      	bne.n	2336 <Macro_evalTriggerMacro+0x122>
		erro_print("LED State Type - Not implemented...");
		break;

	// Analog State Type
	case 0x02:
		erro_print("Analog State Type - Not implemented...");
    230c:	484a      	ldr	r0, [pc, #296]	; (2438 <Macro_evalTriggerMacro+0x224>)
    230e:	e013      	b.n	2338 <Macro_evalTriggerMacro+0x124>
	switch ( guide->type )
	{
	// Normal State Type
	case 0x00:
		// For short TriggerMacros completely ignore incorrect keys
		if ( guide->scanCode == key->scanCode )
    2310:	9b02      	ldr	r3, [sp, #8]
    2312:	788a      	ldrb	r2, [r1, #2]
    2314:	7898      	ldrb	r0, [r3, #2]
    2316:	4290      	cmp	r0, r2
    2318:	d112      	bne.n	2340 <Macro_evalTriggerMacro+0x12c>
		{
			switch ( key->state )
    231a:	784a      	ldrb	r2, [r1, #1]
    231c:	2a02      	cmp	r2, #2
    231e:	d011      	beq.n	2344 <Macro_evalTriggerMacro+0x130>
    2320:	2a03      	cmp	r2, #3
    2322:	d004      	beq.n	232e <Macro_evalTriggerMacro+0x11a>
			case 0x03:
				return TriggerMacroVote_Release;
			}
		}

		return TriggerMacroVote_DoNothing;
    2324:	2a01      	cmp	r2, #1
    2326:	bf0c      	ite	eq
    2328:	2208      	moveq	r2, #8
    232a:	2202      	movne	r2, #2
    232c:	e00b      	b.n	2346 <Macro_evalTriggerMacro+0x132>
			case 0x02:
				return TriggerMacroVote_PassRelease;

			// Correct key, released, possible release
			case 0x03:
				return TriggerMacroVote_Release;
    232e:	2210      	movs	r2, #16
    2330:	e009      	b.n	2346 <Macro_evalTriggerMacro+0x132>

		return TriggerMacroVote_DoNothing;

	// LED State Type
	case 0x01:
		erro_print("LED State Type - Not implemented...");
    2332:	4842      	ldr	r0, [pc, #264]	; (243c <Macro_evalTriggerMacro+0x228>)
    2334:	e000      	b.n	2338 <Macro_evalTriggerMacro+0x124>
		erro_print("Analog State Type - Not implemented...");
		break;

	// Invalid State Type
	default:
		erro_print("Invalid State Type. This is a bug.");
    2336:	4842      	ldr	r0, [pc, #264]	; (2440 <Macro_evalTriggerMacro+0x22c>)
    2338:	f002 f922 	bl	4580 <_print>
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
    233c:	462a      	mov	r2, r5
    233e:	e002      	b.n	2346 <Macro_evalTriggerMacro+0x132>
			case 0x03:
				return TriggerMacroVote_Release;
			}
		}

		return TriggerMacroVote_DoNothing;
    2340:	2202      	movs	r2, #2
    2342:	e000      	b.n	2346 <Macro_evalTriggerMacro+0x132>
			case 0x01:
				return TriggerMacroVote_Pass;

			// Correct key, held, possible passing or release
			case 0x02:
				return TriggerMacroVote_PassRelease;
    2344:	2218      	movs	r2, #24
			// Lookup key information
			TriggerGuide *keyInfo = &macroTriggerListBuffer[ key ];

			// If vote is a pass (>= 0x08, no more keys in the combo need to be looked at)
			// Also mask all of the non-passing votes
			vote |= longMacro
    2346:	9b05      	ldr	r3, [sp, #20]
    2348:	b2d2      	uxtb	r2, r2
    234a:	431a      	orrs	r2, r3
				? Macro_evalLongTriggerMacroVote( keyInfo, guide )
				: Macro_evalShortTriggerMacroVote( keyInfo, guide );
			if ( vote >= TriggerMacroVote_Pass )
    234c:	2a07      	cmp	r2, #7
    234e:	f10b 0b01 	add.w	fp, fp, #1
    2352:	d9a0      	bls.n	2296 <Macro_evalTriggerMacro+0x82>
			{
				vote &= TriggerMacroVote_Release | TriggerMacroVote_PassRelease | TriggerMacroVote_Pass;
    2354:	f002 0218 	and.w	r2, r2, #24
			}
		}

		// If no pass vote was found after scanning all of the keys
		// Fail the combo, if this is a short macro (long macros already will have a fail vote)
		if ( !longMacro && vote < TriggerMacroVote_Pass )
    2358:	b91d      	cbnz	r5, 2362 <Macro_evalTriggerMacro+0x14e>
    235a:	2a07      	cmp	r2, #7
			vote |= TriggerMacroVote_Fail;
    235c:	bf98      	it	ls
    235e:	f042 0201 	orrls.w	r2, r2, #1
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    2362:	f10a 0a03 	add.w	sl, sl, #3
		// Fail the combo, if this is a short macro (long macros already will have a fail vote)
		if ( !longMacro && vote < TriggerMacroVote_Pass )
			vote |= TriggerMacroVote_Fail;

		// After voting, append to overall vote
		overallVote |= vote;
    2366:	4314      	orrs	r4, r2
	// TODO Add support for system LED states (NumLock, CapsLock, etc.)
	// TODO Add support for analog key states
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	// TODO Add support for Press/Hold/Release differentiation when evaluating (not sure if useful)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    2368:	fa5f fa8a 	uxtb.w	sl, sl
    236c:	e787      	b.n	227e <Macro_evalTriggerMacro+0x6a>
		overallVote |= vote;
	}

	// If no pass vote was found after scanning the entire combo
	// And this is the first position in the combo, just remove it (nothing important happened)
	if ( longMacro && overallVote & TriggerMacroVote_DoNothingRelease && pos == 0 )
    236e:	b12d      	cbz	r5, 237c <Macro_evalTriggerMacro+0x168>
    2370:	0763      	lsls	r3, r4, #29
    2372:	d503      	bpl.n	237c <Macro_evalTriggerMacro+0x168>
    2374:	9b01      	ldr	r3, [sp, #4]
    2376:	b90b      	cbnz	r3, 237c <Macro_evalTriggerMacro+0x168>
		overallVote |= TriggerMacroVote_Fail;
    2378:	f044 0401 	orr.w	r4, r4, #1

	// Decide new state of macro after voting
	// Fail macro, remove from pending list
	if ( overallVote & TriggerMacroVote_Fail )
    237c:	07e0      	lsls	r0, r4, #31
    237e:	f53f af71 	bmi.w	2264 <Macro_evalTriggerMacro+0x50>
	{
		return TriggerMacroEval_Remove;
	}
	// Do nothing, incorrect key is being held or released
	else if ( overallVote & TriggerMacroVote_DoNothing && longMacro )
    2382:	07a2      	lsls	r2, r4, #30
    2384:	d502      	bpl.n	238c <Macro_evalTriggerMacro+0x178>
    2386:	b10d      	cbz	r5, 238c <Macro_evalTriggerMacro+0x178>
	// If this is a short macro, just remove it
	// The state can be rebuilt on the next iteration
	if ( !longMacro )
		return TriggerMacroEval_Remove;

	return TriggerMacroEval_DoNothing;
    2388:	2000      	movs	r0, #0
    238a:	e04c      	b.n	2426 <Macro_evalTriggerMacro+0x212>
	{
		// Just doing nothing :)
	}
	// If ready for transition and in Press state, set to Waiting and increment combo position
	// Position is incremented (and possibly remove the macro from the pending list) on the next iteration
	else if ( overallVote & TriggerMacroVote_Release && record->state == TriggerMacro_Press )
    238c:	f004 0210 	and.w	r2, r4, #16
    2390:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    2394:	b1c2      	cbz	r2, 23c8 <Macro_evalTriggerMacro+0x1b4>
    2396:	7872      	ldrb	r2, [r6, #1]
    2398:	b9b2      	cbnz	r2, 23c8 <Macro_evalTriggerMacro+0x1b4>
	{
		record->state = TriggerMacro_Release;
    239a:	2201      	movs	r2, #1
    239c:	7072      	strb	r2, [r6, #1]

		// If this is the last combo in the sequence, remove from the pending list
		if ( macro->guide[ record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1 ] == 0 )
    239e:	f857 3039 	ldr.w	r3, [r7, r9, lsl #3]
    23a2:	f818 2019 	ldrb.w	r2, [r8, r9, lsl #1]
    23a6:	5c98      	ldrb	r0, [r3, r2]
    23a8:	1c51      	adds	r1, r2, #1
    23aa:	2203      	movs	r2, #3
    23ac:	fb12 1200 	smlabb	r2, r2, r0, r1
    23b0:	5c9b      	ldrb	r3, [r3, r2]
    23b2:	b13b      	cbz	r3, 23c4 <Macro_evalTriggerMacro+0x1b0>
		return TriggerMacroEval_DoResultAndRemove;
	}

	// If this is a short macro, just remove it
	// The state can be rebuilt on the next iteration
	if ( !longMacro )
    23b4:	2d00      	cmp	r5, #0
    23b6:	f43f af55 	beq.w	2264 <Macro_evalTriggerMacro+0x50>
    23ba:	e7e5      	b.n	2388 <Macro_evalTriggerMacro+0x174>
		// If this result macro has more than 1 key, only send once
		// TODO Add option to have long macro repeat rate
		if ( macro->guide[ pos + comboLength + 1 ] == 0 )
		{
			// Long result macro (more than 1 combo)
			if ( Macro_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    23bc:	5ccb      	ldrb	r3, [r1, r3]
    23be:	b333      	cbz	r3, 240e <Macro_evalTriggerMacro+0x1fa>
			{
				// Only ever trigger result once, on press
				if ( overallVote == TriggerMacroVote_Pass )
    23c0:	2c08      	cmp	r4, #8
    23c2:	d1f7      	bne.n	23b4 <Macro_evalTriggerMacro+0x1a0>
	{
		record->state = TriggerMacro_Release;

		// If this is the last combo in the sequence, remove from the pending list
		if ( macro->guide[ record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1 ] == 0 )
			return TriggerMacroEval_DoResultAndRemove;
    23c4:	2002      	movs	r0, #2
    23c6:	e02e      	b.n	2426 <Macro_evalTriggerMacro+0x212>
	}
	// If passing and in Waiting state, set macro state to Press
	else if ( overallVote & TriggerMacroVote_Pass
    23c8:	0723      	lsls	r3, r4, #28
    23ca:	d529      	bpl.n	2420 <Macro_evalTriggerMacro+0x20c>
		&& ( record->state == TriggerMacro_Waiting || record->state == TriggerMacro_Press ) )
    23cc:	7872      	ldrb	r2, [r6, #1]
    23ce:	f012 02fd 	ands.w	r2, r2, #253	; 0xfd
    23d2:	d125      	bne.n	2420 <Macro_evalTriggerMacro+0x20c>
	{
		record->state = TriggerMacro_Press;
    23d4:	7072      	strb	r2, [r6, #1]

		// If in press state, and this is the final combo, send request for ResultMacro
		// Check to see if the result macro only has a single element
		// If this result macro has more than 1 key, only send once
		// TODO Add option to have long macro repeat rate
		if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    23d6:	f857 2039 	ldr.w	r2, [r7, r9, lsl #3]
    23da:	4411      	add	r1, r2
    23dc:	7848      	ldrb	r0, [r1, #1]
    23de:	2800      	cmp	r0, #0
    23e0:	d1e8      	bne.n	23b4 <Macro_evalTriggerMacro+0x1a0>
		{
			// Long result macro (more than 1 combo)
			if ( Macro_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    23e2:	9b03      	ldr	r3, [sp, #12]
    23e4:	7919      	ldrb	r1, [r3, #4]
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    23e6:	4b17      	ldr	r3, [pc, #92]	; (2444 <Macro_evalTriggerMacro+0x230>)
    23e8:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
    23ec:	780e      	ldrb	r6, [r1, #0]
inline uint8_t Macro_isLongResultMacro( const ResultMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
    23ee:	2301      	movs	r3, #1
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    23f0:	b2c7      	uxtb	r7, r0
    23f2:	42b7      	cmp	r7, r6
    23f4:	d2e2      	bcs.n	23bc <Macro_evalTriggerMacro+0x1a8>
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    23f6:	f811 c003 	ldrb.w	ip, [r1, r3]
    23fa:	4f13      	ldr	r7, [pc, #76]	; (2448 <Macro_evalTriggerMacro+0x234>)
    23fc:	eb07 07cc 	add.w	r7, r7, ip, lsl #3
    2400:	3001      	adds	r0, #1
    2402:	793f      	ldrb	r7, [r7, #4]
    2404:	3701      	adds	r7, #1
    2406:	fa53 f387 	uxtab	r3, r3, r7
    240a:	b2db      	uxtb	r3, r3
    240c:	e7f0      	b.n	23f0 <Macro_evalTriggerMacro+0x1dc>
inline uint8_t Macro_isLongTriggerMacro( const TriggerMacro *macro )
{
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    240e:	7813      	ldrb	r3, [r2, #0]
    2410:	2001      	movs	r0, #1
    2412:	2103      	movs	r1, #3
    2414:	fb11 0303 	smlabb	r3, r1, r3, r0
			}
			// Short result macro
			else
			{
				// Only trigger result once, on press, if long trigger (more than 1 combo)
				if ( Macro_isLongTriggerMacro( macro ) )
    2418:	5cd3      	ldrb	r3, [r2, r3]
    241a:	2b00      	cmp	r3, #0
    241c:	d1d2      	bne.n	23c4 <Macro_evalTriggerMacro+0x1b0>
    241e:	e002      	b.n	2426 <Macro_evalTriggerMacro+0x212>
			}
		}
	}
	// Otherwise, just remove the macro on key release
	// One more result has to be called to indicate to the ResultMacro that the key transitioned to the release state
	else if ( overallVote & TriggerMacroVote_Release )
    2420:	2800      	cmp	r0, #0
    2422:	d1cf      	bne.n	23c4 <Macro_evalTriggerMacro+0x1b0>
    2424:	e7c6      	b.n	23b4 <Macro_evalTriggerMacro+0x1a0>
	// The state can be rebuilt on the next iteration
	if ( !longMacro )
		return TriggerMacroEval_Remove;

	return TriggerMacroEval_DoNothing;
}
    2426:	b007      	add	sp, #28
    2428:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    242c:	00005f28 	.word	0x00005f28
    2430:	1ffff16a 	.word	0x1ffff16a
    2434:	1ffff920 	.word	0x1ffff920
    2438:	000052f8 	.word	0x000052f8
    243c:	000052bd 	.word	0x000052bd
    2440:	00005336 	.word	0x00005336
    2444:	000057a0 	.word	0x000057a0
    2448:	00004ce8 	.word	0x00004ce8
    244c:	1ffffb3d 	.word	0x1ffffb3d

00002450 <Macro_process>:


// Macro Procesing Loop
// Called once per USB buffer send
inline void Macro_process()
{
    2450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return;
	}
#endif

	// Only do one round of macro processing between Output Module timer sends
	if ( USBKeys_Sent != 0 )
    2454:	4bb0      	ldr	r3, [pc, #704]	; (2718 <Macro_process+0x2c8>)
    2456:	781a      	ldrb	r2, [r3, #0]


// Macro Procesing Loop
// Called once per USB buffer send
inline void Macro_process()
{
    2458:	b085      	sub	sp, #20
		return;
	}
#endif

	// Only do one round of macro processing between Output Module timer sends
	if ( USBKeys_Sent != 0 )
    245a:	2a00      	cmp	r2, #0
    245c:	f040 8159 	bne.w	2712 <Macro_process+0x2c2>
		}
	}
#endif

	// If the pause flag is set, only process if the step counter is non-zero
	if ( macroPauseMode )
    2460:	4bae      	ldr	r3, [pc, #696]	; (271c <Macro_process+0x2cc>)
    2462:	781b      	ldrb	r3, [r3, #0]
    2464:	b14b      	cbz	r3, 247a <Macro_process+0x2a>
	{
		if ( macroStepCounter == 0 )
    2466:	4bae      	ldr	r3, [pc, #696]	; (2720 <Macro_process+0x2d0>)
    2468:	881a      	ldrh	r2, [r3, #0]
    246a:	2a00      	cmp	r2, #0
    246c:	f000 8151 	beq.w	2712 <Macro_process+0x2c2>
			return;

		// Proceed, decrementing the step counter
		macroStepCounter--;
    2470:	3a01      	subs	r2, #1
		dbug_print("Macro Step");
    2472:	48ac      	ldr	r0, [pc, #688]	; (2724 <Macro_process+0x2d4>)
	{
		if ( macroStepCounter == 0 )
			return;

		// Proceed, decrementing the step counter
		macroStepCounter--;
    2474:	801a      	strh	r2, [r3, #0]
		dbug_print("Macro Step");
    2476:	f002 f883 	bl	4580 <_print>
		// Number of Triggers in list
		nat_ptr_t triggerListSize = triggerList[0];

		// Iterate over triggerList to see if any TriggerMacros need to be added
		// First item is the number of items in the TriggerList
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    247a:	2400      	movs	r4, #0

// Update pending trigger list
inline void Macro_updateTriggerMacroPendingList()
{
	// Iterate over the macroTriggerListBuffer to add any new Trigger Macros to the pending list
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    247c:	4baa      	ldr	r3, [pc, #680]	; (2728 <Macro_process+0x2d8>)
    247e:	781a      	ldrb	r2, [r3, #0]
    2480:	b2e0      	uxtb	r0, r4
    2482:	4282      	cmp	r2, r0
    2484:	4698      	mov	r8, r3
    2486:	d937      	bls.n	24f8 <Macro_process+0xa8>
	{
		// TODO LED States
		// TODO Analog Switches
		// Only add TriggerMacro to pending list if key was pressed (not held, released or off)
		if ( macroTriggerListBuffer[ key ].state == 0x00 && macroTriggerListBuffer[ key ].state != 0x01 )
    2488:	4ba8      	ldr	r3, [pc, #672]	; (272c <Macro_process+0x2dc>)
    248a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    248e:	4418      	add	r0, r3
    2490:	7841      	ldrb	r1, [r0, #1]
    2492:	b379      	cbz	r1, 24f4 <Macro_process+0xa4>
		// TODO Analog
		// If this is a release case, indicate to layer lookup for possible latch expiry
		uint8_t latch_expire = macroTriggerListBuffer[ key ].state == 0x03;

		// Lookup Trigger List
		nat_ptr_t *triggerList = Macro_layerLookup( &macroTriggerListBuffer[ key ], latch_expire );
    2494:	1ecb      	subs	r3, r1, #3
    2496:	4259      	negs	r1, r3
    2498:	4159      	adcs	r1, r3
    249a:	f7ff fdbf 	bl	201c <Macro_layerLookup>

		// If there was an error during lookup, skip
		if ( triggerList == 0 )
    249e:	b348      	cbz	r0, 24f4 <Macro_process+0xa4>
    24a0:	4fa3      	ldr	r7, [pc, #652]	; (2730 <Macro_process+0x2e0>)
			continue;

		// Number of Triggers in list
		nat_ptr_t triggerListSize = triggerList[0];
    24a2:	f8d0 e000 	ldr.w	lr, [r0]
    24a6:	883b      	ldrh	r3, [r7, #0]

		// Iterate over triggerList to see if any TriggerMacros need to be added
		// First item is the number of items in the TriggerList
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    24a8:	2201      	movs	r2, #1
    24aa:	f10e 0101 	add.w	r1, lr, #1
    24ae:	428a      	cmp	r2, r1
    24b0:	d21f      	bcs.n	24f2 <Macro_process+0xa2>
		{
			// Lookup trigger macro index
			var_uint_t triggerMacroIndex = triggerList[ macro ];
    24b2:	f810 1022 	ldrb.w	r1, [r0, r2, lsl #2]
    24b6:	2600      	movs	r6, #0
    24b8:	b2f5      	uxtb	r5, r6

			// Iterate over macroTriggerMacroPendingList to see if any macro in the scancode's
			//  triggerList needs to be added
			var_uint_t pending = 0;
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    24ba:	429d      	cmp	r5, r3
    24bc:	d207      	bcs.n	24ce <Macro_process+0x7e>
			{
				// Stop scanning if the trigger macro index is found in the pending list
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    24be:	f8df c274 	ldr.w	ip, [pc, #628]	; 2734 <Macro_process+0x2e4>
    24c2:	f83c c015 	ldrh.w	ip, [ip, r5, lsl #1]
    24c6:	458c      	cmp	ip, r1
    24c8:	f106 0601 	add.w	r6, r6, #1
    24cc:	d1f4      	bne.n	24b8 <Macro_process+0x68>
					break;
			}

			// If the triggerMacroIndex (macro) was not found in the macroTriggerMacroPendingList
			// Add it to the list
			if ( pending == macroTriggerMacroPendingListSize )
    24ce:	429d      	cmp	r5, r3
    24d0:	d10c      	bne.n	24ec <Macro_process+0x9c>
			{
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    24d2:	4e98      	ldr	r6, [pc, #608]	; (2734 <Macro_process+0x2e4>)
    24d4:	1c5d      	adds	r5, r3, #1
    24d6:	f826 1013 	strh.w	r1, [r6, r3, lsl #1]

				// Reset macro position
				TriggerMacroRecordList[ triggerMacroIndex ].pos   = 0;
    24da:	4b97      	ldr	r3, [pc, #604]	; (2738 <Macro_process+0x2e8>)
    24dc:	2600      	movs	r6, #0
    24de:	f803 6011 	strb.w	r6, [r3, r1, lsl #1]
				TriggerMacroRecordList[ triggerMacroIndex ].state = TriggerMacro_Waiting;
    24e2:	eb03 0141 	add.w	r1, r3, r1, lsl #1
    24e6:	2302      	movs	r3, #2
    24e8:	704b      	strb	r3, [r1, #1]

			// If the triggerMacroIndex (macro) was not found in the macroTriggerMacroPendingList
			// Add it to the list
			if ( pending == macroTriggerMacroPendingListSize )
			{
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    24ea:	b2ab      	uxth	r3, r5
		// Number of Triggers in list
		nat_ptr_t triggerListSize = triggerList[0];

		// Iterate over triggerList to see if any TriggerMacros need to be added
		// First item is the number of items in the TriggerList
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    24ec:	3201      	adds	r2, #1
    24ee:	b2d2      	uxtb	r2, r2
    24f0:	e7db      	b.n	24aa <Macro_process+0x5a>
    24f2:	803b      	strh	r3, [r7, #0]
    24f4:	3401      	adds	r4, #1
    24f6:	e7c1      	b.n	247c <Macro_process+0x2c>

// Update pending trigger list
inline void Macro_updateTriggerMacroPendingList()
{
	// Iterate over the macroTriggerListBuffer to add any new Trigger Macros to the pending list
	for ( uint8_t key = 0; key < macroTriggerListBufferSize; key++ )
    24f8:	2700      	movs	r7, #0
    24fa:	463e      	mov	r6, r7
	// Tail pointer for macroTriggerMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroTriggerMacroPendingListTail = 0;

	// Iterate through the pending TriggerMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    24fc:	4b8c      	ldr	r3, [pc, #560]	; (2730 <Macro_process+0x2e0>)
    24fe:	881a      	ldrh	r2, [r3, #0]
    2500:	b2fc      	uxtb	r4, r7
    2502:	4294      	cmp	r4, r2
    2504:	f080 80a6 	bcs.w	2654 <Macro_process+0x204>
	{
		switch ( Macro_evalTriggerMacro( macroTriggerMacroPendingList[ macro ] ) )
    2508:	4d8a      	ldr	r5, [pc, #552]	; (2734 <Macro_process+0x2e4>)
    250a:	f815 0014 	ldrb.w	r0, [r5, r4, lsl #1]
    250e:	f7ff fe81 	bl	2214 <Macro_evalTriggerMacro>
    2512:	2802      	cmp	r0, #2
    2514:	d056      	beq.n	25c4 <Macro_process+0x174>
    2516:	2803      	cmp	r0, #3
    2518:	f000 809a 	beq.w	2650 <Macro_process+0x200>
    251c:	2801      	cmp	r0, #1
    251e:	d14a      	bne.n	25b6 <Macro_process+0x166>
		{
		// Trigger Result Macro (purposely falling through)
		case TriggerMacroEval_DoResult:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    2520:	4886      	ldr	r0, [pc, #536]	; (273c <Macro_process+0x2ec>)
    2522:	f835 e014 	ldrh.w	lr, [r5, r4, lsl #1]
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    2526:	f8df 9220 	ldr.w	r9, [pc, #544]	; 2748 <Macro_process+0x2f8>
		switch ( Macro_evalTriggerMacro( macroTriggerMacroPendingList[ macro ] ) )
		{
		// Trigger Result Macro (purposely falling through)
		case TriggerMacroEval_DoResult:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    252a:	eb00 03ce 	add.w	r3, r0, lr, lsl #3
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    252e:	f8b9 2000 	ldrh.w	r2, [r9]
// Append result macro to pending list, checking for duplicates
// Do nothing if duplicate
inline void Macro_appendResultMacroToPendingList( const TriggerMacro *triggerMacro )
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;
    2532:	791b      	ldrb	r3, [r3, #4]

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    2534:	2100      	movs	r1, #0
    2536:	fa5f fa81 	uxtb.w	sl, r1
    253a:	4592      	cmp	sl, r2
    253c:	f8df c204 	ldr.w	ip, [pc, #516]	; 2744 <Macro_process+0x2f4>
    2540:	d206      	bcs.n	2550 <Macro_process+0x100>
	{
		// If duplicate found, do nothing
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
    2542:	f83c c01a 	ldrh.w	ip, [ip, sl, lsl #1]
    2546:	459c      	cmp	ip, r3
    2548:	f101 0101 	add.w	r1, r1, #1
    254c:	d1f3      	bne.n	2536 <Macro_process+0xe6>
    254e:	e032      	b.n	25b6 <Macro_process+0x166>
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    2550:	1c51      	adds	r1, r2, #1
    2552:	f82c 3012 	strh.w	r3, [ip, r2, lsl #1]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    2556:	f850 003e 	ldr.w	r0, [r0, lr, lsl #3]
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    255a:	f8a9 1000 	strh.w	r1, [r9]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    255e:	7802      	ldrb	r2, [r0, #0]

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
    2560:	2100      	movs	r1, #0
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    2562:	b132      	cbz	r2, 2572 <Macro_process+0x122>
	{
		pos += TriggerGuideSize * comboLength + 1;
    2564:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    2568:	3201      	adds	r2, #1
    256a:	4411      	add	r1, r2
    256c:	b2c9      	uxtb	r1, r1
		comboLength = triggerMacro->guide[ pos ];
    256e:	5c42      	ldrb	r2, [r0, r1]
    2570:	e7f7      	b.n	2562 <Macro_process+0x112>
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    2572:	4401      	add	r1, r0
    2574:	f811 cc01 	ldrb.w	ip, [r1, #-1]
    2578:	f898 1000 	ldrb.w	r1, [r8]
    257c:	eb01 0941 	add.w	r9, r1, r1, lsl #1

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    2580:	454a      	cmp	r2, r9
    2582:	d013      	beq.n	25ac <Macro_process+0x15c>
    2584:	4869      	ldr	r0, [pc, #420]	; (272c <Macro_process+0x2dc>)
    2586:	eb02 0e00 	add.w	lr, r2, r0
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
    258a:	f89e 1002 	ldrb.w	r1, [lr, #2]
    258e:	4561      	cmp	r1, ip
    2590:	d10a      	bne.n	25a8 <Macro_process+0x158>
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    2592:	f8df a1ac 	ldr.w	sl, [pc, #428]	; 2740 <Macro_process+0x2f0>
    2596:	f89e e001 	ldrb.w	lr, [lr, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    259a:	5c10      	ldrb	r0, [r2, r0]
	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    259c:	eb03 0143 	add.w	r1, r3, r3, lsl #1
    25a0:	4451      	add	r1, sl
    25a2:	f881 e001 	strb.w	lr, [r1, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    25a6:	7088      	strb	r0, [r1, #2]
    25a8:	3203      	adds	r2, #3
    25aa:	e7e9      	b.n	2580 <Macro_process+0x130>
		}
	}

	// Reset the macro position
	ResultMacroRecordList[ resultMacroIndex ].pos = 0;
    25ac:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    25b0:	4a63      	ldr	r2, [pc, #396]	; (2740 <Macro_process+0x2f0>)
    25b2:	2100      	movs	r1, #0
    25b4:	54d1      	strb	r1, [r2, r3]
		case TriggerMacroEval_DoResult:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );

		default:
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = macroTriggerMacroPendingList[ macro ];
    25b6:	1c73      	adds	r3, r6, #1
    25b8:	f835 2014 	ldrh.w	r2, [r5, r4, lsl #1]
    25bc:	f825 2016 	strh.w	r2, [r5, r6, lsl #1]
    25c0:	b2de      	uxtb	r6, r3
			break;
    25c2:	e045      	b.n	2650 <Macro_process+0x200>

		// Trigger Result Macro and Remove (purposely falling through)
		case TriggerMacroEval_DoResultAndRemove:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    25c4:	485d      	ldr	r0, [pc, #372]	; (273c <Macro_process+0x2ec>)
    25c6:	f835 4014 	ldrh.w	r4, [r5, r4, lsl #1]
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    25ca:	f8df e17c 	ldr.w	lr, [pc, #380]	; 2748 <Macro_process+0x2f8>
			break;

		// Trigger Result Macro and Remove (purposely falling through)
		case TriggerMacroEval_DoResultAndRemove:
			// Append ResultMacro to PendingList
			Macro_appendResultMacroToPendingList( &TriggerMacroList[ macroTriggerMacroPendingList[ macro ] ] );
    25ce:	eb00 03c4 	add.w	r3, r0, r4, lsl #3
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    25d2:	f8be 2000 	ldrh.w	r2, [lr]
// Append result macro to pending list, checking for duplicates
// Do nothing if duplicate
inline void Macro_appendResultMacroToPendingList( const TriggerMacro *triggerMacro )
{
	// Lookup result macro index
	var_uint_t resultMacroIndex = triggerMacro->result;
    25d6:	791b      	ldrb	r3, [r3, #4]

	// Iterate through result macro pending list, making sure this macro hasn't been added yet
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    25d8:	2100      	movs	r1, #0
    25da:	fa5f fc81 	uxtb.w	ip, r1
    25de:	4594      	cmp	ip, r2
    25e0:	4d58      	ldr	r5, [pc, #352]	; (2744 <Macro_process+0x2f4>)
    25e2:	d206      	bcs.n	25f2 <Macro_process+0x1a2>
	{
		// If duplicate found, do nothing
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
    25e4:	f835 501c 	ldrh.w	r5, [r5, ip, lsl #1]
    25e8:	429d      	cmp	r5, r3
    25ea:	f101 0101 	add.w	r1, r1, #1
    25ee:	d1f4      	bne.n	25da <Macro_process+0x18a>
    25f0:	e02e      	b.n	2650 <Macro_process+0x200>
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    25f2:	1c51      	adds	r1, r2, #1
    25f4:	f825 3012 	strh.w	r3, [r5, r2, lsl #1]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    25f8:	f850 0034 	ldr.w	r0, [r0, r4, lsl #3]
		if ( macroResultMacroPendingList[ macro ] == resultMacroIndex )
			return;
	}

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;
    25fc:	f8ae 1000 	strh.w	r1, [lr]

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    2600:	7802      	ldrb	r2, [r0, #0]

	// No duplicates found, add to pending list
	macroResultMacroPendingList[ macroResultMacroPendingListSize++ ] = resultMacroIndex;

	// Lookup scanCode of the last key in the last combo
	var_uint_t pos = 0;
    2602:	2100      	movs	r1, #0
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    2604:	b132      	cbz	r2, 2614 <Macro_process+0x1c4>
	{
		pos += TriggerGuideSize * comboLength + 1;
    2606:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    260a:	3201      	adds	r2, #1
    260c:	4411      	add	r1, r2
    260e:	b2c9      	uxtb	r1, r1
		comboLength = triggerMacro->guide[ pos ];
    2610:	5c42      	ldrb	r2, [r0, r1]
    2612:	e7f7      	b.n	2604 <Macro_process+0x1b4>
	}

	uint8_t scanCode = ((TriggerGuide*)&triggerMacro->guide[ pos - TriggerGuideSize ])->scanCode;
    2614:	4401      	add	r1, r0
    2616:	f811 ec01 	ldrb.w	lr, [r1, #-1]
    261a:	f898 1000 	ldrb.w	r1, [r8]
    261e:	eb01 0541 	add.w	r5, r1, r1, lsl #1

	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
    2622:	42aa      	cmp	r2, r5
    2624:	d00f      	beq.n	2646 <Macro_process+0x1f6>
    2626:	4841      	ldr	r0, [pc, #260]	; (272c <Macro_process+0x2dc>)
    2628:	1814      	adds	r4, r2, r0
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
    262a:	78a1      	ldrb	r1, [r4, #2]
    262c:	4571      	cmp	r1, lr
    262e:	d108      	bne.n	2642 <Macro_process+0x1f2>
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    2630:	f8df c10c 	ldr.w	ip, [pc, #268]	; 2740 <Macro_process+0x2f0>
    2634:	7864      	ldrb	r4, [r4, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    2636:	5c10      	ldrb	r0, [r2, r0]
	// Lookup scanCode in buffer list for the current state and stateType
	for ( uint8_t keyIndex = 0; keyIndex < macroTriggerListBufferSize; keyIndex++ )
	{
		if ( macroTriggerListBuffer[ keyIndex ].scanCode == scanCode )
		{
			ResultMacroRecordList[ resultMacroIndex ].state     = macroTriggerListBuffer[ keyIndex ].state;
    2638:	eb03 0143 	add.w	r1, r3, r3, lsl #1
    263c:	4461      	add	r1, ip
    263e:	704c      	strb	r4, [r1, #1]
			ResultMacroRecordList[ resultMacroIndex ].stateType = macroTriggerListBuffer[ keyIndex ].type;
    2640:	7088      	strb	r0, [r1, #2]
    2642:	3203      	adds	r2, #3
    2644:	e7ed      	b.n	2622 <Macro_process+0x1d2>
		}
	}

	// Reset the macro position
	ResultMacroRecordList[ resultMacroIndex ].pos = 0;
    2646:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    264a:	4a3d      	ldr	r2, [pc, #244]	; (2740 <Macro_process+0x2f0>)
    264c:	2100      	movs	r1, #0
    264e:	54d1      	strb	r1, [r2, r3]
    2650:	3701      	adds	r7, #1
    2652:	e753      	b.n	24fc <Macro_process+0xac>
			break;
		}
	}

	// Update the macroTriggerMacroPendingListSize with the tail pointer
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;
    2654:	801e      	strh	r6, [r3, #0]
	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroResultMacroPendingListTail = 0;

	// Iterate through the pending ResultMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    2656:	2600      	movs	r6, #0
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;


	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroResultMacroPendingListTail = 0;
    2658:	4635      	mov	r5, r6

	// Iterate through the pending ResultMacros, processing each of them
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingListSize; macro++ )
    265a:	4b3b      	ldr	r3, [pc, #236]	; (2748 <Macro_process+0x2f8>)
    265c:	881a      	ldrh	r2, [r3, #0]
    265e:	fa5f f986 	uxtb.w	r9, r6
    2662:	4591      	cmp	r9, r2
    2664:	d23e      	bcs.n	26e4 <Macro_process+0x294>

// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
    2666:	4b37      	ldr	r3, [pc, #220]	; (2744 <Macro_process+0x2f4>)
    2668:	4a38      	ldr	r2, [pc, #224]	; (274c <Macro_process+0x2fc>)
    266a:	f813 3019 	ldrb.w	r3, [r3, r9, lsl #1]
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];
    266e:	4f34      	ldr	r7, [pc, #208]	; (2740 <Macro_process+0x2f0>)
    2670:	eb03 0843 	add.w	r8, r3, r3, lsl #1

// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
    2674:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];

	// Current Macro position
	var_uint_t pos = record->pos;
    2678:	f818 4007 	ldrb.w	r4, [r8, r7]

	// Length of combo being processed
	uint8_t comboLength = macro->guide[ pos ];
    267c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];
    2680:	eb08 0107 	add.w	r1, r8, r7

	// Current Macro position
	var_uint_t pos = record->pos;

	// Length of combo being processed
	uint8_t comboLength = macro->guide[ pos ];
    2684:	5d1b      	ldrb	r3, [r3, r4]
// Evaluate/Update ResultMacro
inline ResultMacroEval Macro_evalResultMacro( var_uint_t resultMacroIndex )
{
	// Lookup ResultMacro
	const ResultMacro *macro = &ResultMacroList[ resultMacroIndex ];
	ResultMacroRecord *record = &ResultMacroRecordList[ resultMacroIndex ];
    2686:	9102      	str	r1, [sp, #8]

	// Function Counter, used to keep track of the combo items processed
	var_uint_t funcCount = 0;

	// Combo Item Position within the guide
	var_uint_t comboItem = pos + 1;
    2688:	3401      	adds	r4, #1

	// Current Macro position
	var_uint_t pos = record->pos;

	// Length of combo being processed
	uint8_t comboLength = macro->guide[ pos ];
    268a:	9303      	str	r3, [sp, #12]

	// Function Counter, used to keep track of the combo items processed
	var_uint_t funcCount = 0;

	// Combo Item Position within the guide
	var_uint_t comboItem = pos + 1;
    268c:	b2e4      	uxtb	r4, r4
    268e:	f04f 0a00 	mov.w	sl, #0

	// Iterate through the Result Combo
	while ( funcCount < comboLength )
    2692:	9903      	ldr	r1, [sp, #12]
    2694:	fa5f f38a 	uxtb.w	r3, sl
    2698:	428b      	cmp	r3, r1
    269a:	f8db 1000 	ldr.w	r1, [fp]
    269e:	d219      	bcs.n	26d4 <Macro_process+0x284>
	{
		// Assign TriggerGuide element (key type, state and scancode)
		ResultGuide *guide = (ResultGuide*)(&macro->guide[ comboItem ]);
    26a0:	eb01 0e04 	add.w	lr, r1, r4

		// Do lookup on capability function
		void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
    26a4:	4b2a      	ldr	r3, [pc, #168]	; (2750 <Macro_process+0x300>)
    26a6:	5d09      	ldrb	r1, [r1, r4]

		// Call capability
		capability( record->state, record->stateType, &guide->args );
    26a8:	9a02      	ldr	r2, [sp, #8]
    26aa:	f853 c031 	ldr.w	ip, [r3, r1, lsl #3]
    26ae:	7850      	ldrb	r0, [r2, #1]
    26b0:	7891      	ldrb	r1, [r2, #2]
    26b2:	9301      	str	r3, [sp, #4]
    26b4:	f10e 0201 	add.w	r2, lr, #1
    26b8:	47e0      	blx	ip

		// Increment counters
		funcCount++;
		comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ comboItem ]) );
    26ba:	f8db 2000 	ldr.w	r2, [fp]
    26be:	9b01      	ldr	r3, [sp, #4]
    26c0:	5d12      	ldrb	r2, [r2, r4]
    26c2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    26c6:	f10a 0a01 	add.w	sl, sl, #1
    26ca:	791b      	ldrb	r3, [r3, #4]
    26cc:	3301      	adds	r3, #1
    26ce:	441c      	add	r4, r3
    26d0:	b2e4      	uxtb	r4, r4
    26d2:	e7de      	b.n	2692 <Macro_process+0x242>
	}

	// Move to next item in the sequence
	record->pos = comboItem;
    26d4:	f808 4007 	strb.w	r4, [r8, r7]

	// If the ResultMacro is finished, remove
	if ( macro->guide[ comboItem ] == 0 )
    26d8:	5d0b      	ldrb	r3, [r1, r4]
    26da:	b993      	cbnz	r3, 2702 <Macro_process+0x2b2>
	{
		record->pos = 0;
    26dc:	f808 3007 	strb.w	r3, [r8, r7]
    26e0:	3601      	adds	r6, #1
    26e2:	e7ba      	b.n	265a <Macro_process+0x20a>

	// Update the macroResultMacroPendingListSize with the tail pointer
	macroResultMacroPendingListSize = macroResultMacroPendingListTail;

	// Signal buffer that we've used it
	Scan_finishedWithMacro( macroTriggerListBufferSize );
    26e4:	4c10      	ldr	r4, [pc, #64]	; (2728 <Macro_process+0x2d8>)
			break;
		}
	}

	// Update the macroResultMacroPendingListSize with the tail pointer
	macroResultMacroPendingListSize = macroResultMacroPendingListTail;
    26e6:	801d      	strh	r5, [r3, #0]

	// Signal buffer that we've used it
	Scan_finishedWithMacro( macroTriggerListBufferSize );
    26e8:	7820      	ldrb	r0, [r4, #0]
    26ea:	f7ff f8db 	bl	18a4 <Scan_finishedWithMacro>

	// Reset TriggerList buffer
	macroTriggerListBufferSize = 0;

	// If Macro debug mode is set, clear the USB Buffer
	if ( macroDebugMode )
    26ee:	4a19      	ldr	r2, [pc, #100]	; (2754 <Macro_process+0x304>)
    26f0:	7812      	ldrb	r2, [r2, #0]

	// Signal buffer that we've used it
	Scan_finishedWithMacro( macroTriggerListBufferSize );

	// Reset TriggerList buffer
	macroTriggerListBufferSize = 0;
    26f2:	2300      	movs	r3, #0
    26f4:	7023      	strb	r3, [r4, #0]

	// If Macro debug mode is set, clear the USB Buffer
	if ( macroDebugMode )
    26f6:	b162      	cbz	r2, 2712 <Macro_process+0x2c2>
	{
		USBKeys_Modifiers = 0;
    26f8:	4a17      	ldr	r2, [pc, #92]	; (2758 <Macro_process+0x308>)
    26fa:	7013      	strb	r3, [r2, #0]
		USBKeys_Sent = 0;
    26fc:	4a06      	ldr	r2, [pc, #24]	; (2718 <Macro_process+0x2c8>)
    26fe:	7013      	strb	r3, [r2, #0]
    2700:	e007      	b.n	2712 <Macro_process+0x2c2>
		switch ( Macro_evalResultMacro( macroResultMacroPendingList[ macro ] ) )
		{
		// Re-add macros to pending list
		case ResultMacroEval_DoNothing:
		default:
			macroResultMacroPendingList[ macroResultMacroPendingListTail++ ] = macroResultMacroPendingList[ macro ];
    2702:	4b10      	ldr	r3, [pc, #64]	; (2744 <Macro_process+0x2f4>)
    2704:	1c6a      	adds	r2, r5, #1
    2706:	f833 1019 	ldrh.w	r1, [r3, r9, lsl #1]
    270a:	f823 1015 	strh.w	r1, [r3, r5, lsl #1]
    270e:	b2d5      	uxtb	r5, r2
			break;
    2710:	e7e6      	b.n	26e0 <Macro_process+0x290>
	if ( macroDebugMode )
	{
		USBKeys_Modifiers = 0;
		USBKeys_Sent = 0;
	}
}
    2712:	b005      	add	sp, #20
    2714:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2718:	1ffff17c 	.word	0x1ffff17c
    271c:	1ffff0a2 	.word	0x1ffff0a2
    2720:	1fffefde 	.word	0x1fffefde
    2724:	00005370 	.word	0x00005370
    2728:	1ffff16a 	.word	0x1ffff16a
    272c:	1ffff920 	.word	0x1ffff920
    2730:	1ffff174 	.word	0x1ffff174
    2734:	1ffff0a6 	.word	0x1ffff0a6
    2738:	1ffffb3d 	.word	0x1ffffb3d
    273c:	00005f28 	.word	0x00005f28
    2740:	1ffff9da 	.word	0x1ffff9da
    2744:	1fffefe0 	.word	0x1fffefe0
    2748:	1ffff0a4 	.word	0x1ffff0a4
    274c:	000057a0 	.word	0x000057a0
    2750:	00004ce8 	.word	0x00004ce8
    2754:	1ffff16b 	.word	0x1ffff16b
    2758:	1ffff178 	.word	0x1ffff178

0000275c <Macro_setup>:


inline void Macro_setup()
{
    275c:	b508      	push	{r3, lr}
	// Register Macro CLI dictionary
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    275e:	4812      	ldr	r0, [pc, #72]	; (27a8 <Macro_setup+0x4c>)
    2760:	4912      	ldr	r1, [pc, #72]	; (27ac <Macro_setup+0x50>)
    2762:	f001 fccd 	bl	4100 <CLI_registerDictionary>

	// Disable Macro debug mode
	macroDebugMode = 0;
    2766:	4a12      	ldr	r2, [pc, #72]	; (27b0 <Macro_setup+0x54>)
    2768:	2300      	movs	r3, #0
    276a:	7013      	strb	r3, [r2, #0]

	// Disable Macro pause flag
	macroPauseMode = 0;
    276c:	4a11      	ldr	r2, [pc, #68]	; (27b4 <Macro_setup+0x58>)
    276e:	7013      	strb	r3, [r2, #0]

	// Set Macro step counter to zero
	macroStepCounter = 0;
    2770:	4a11      	ldr	r2, [pc, #68]	; (27b8 <Macro_setup+0x5c>)
    2772:	8013      	strh	r3, [r2, #0]

	// Make sure macro trigger buffer is empty
	macroTriggerListBufferSize = 0;
    2774:	4a11      	ldr	r2, [pc, #68]	; (27bc <Macro_setup+0x60>)
    2776:	7013      	strb	r3, [r2, #0]

	// Set the current rotated layer to 0
	Macro_rotationLayer = 0;
    2778:	4a11      	ldr	r2, [pc, #68]	; (27c0 <Macro_setup+0x64>)
    277a:	8013      	strh	r3, [r2, #0]

	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
	{
		TriggerMacroRecordList[ macro ].pos   = 0;
    277c:	4911      	ldr	r1, [pc, #68]	; (27c4 <Macro_setup+0x68>)
    277e:	2200      	movs	r2, #0
    2780:	1858      	adds	r0, r3, r1
    2782:	545a      	strb	r2, [r3, r1]
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
    2784:	2102      	movs	r1, #2
    2786:	440b      	add	r3, r1

	// Set the current rotated layer to 0
	Macro_rotationLayer = 0;

	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    2788:	2bc4      	cmp	r3, #196	; 0xc4
	{
		TriggerMacroRecordList[ macro ].pos   = 0;
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
    278a:	7041      	strb	r1, [r0, #1]

	// Set the current rotated layer to 0
	Macro_rotationLayer = 0;

	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    278c:	d1f6      	bne.n	277c <Macro_setup+0x20>
    278e:	4613      	mov	r3, r2
	}

	// Initialize ResultMacro states
	for ( var_uint_t macro = 0; macro < ResultMacroNum; macro++ )
	{
		ResultMacroRecordList[ macro ].pos       = 0;
    2790:	480d      	ldr	r0, [pc, #52]	; (27c8 <Macro_setup+0x6c>)
    2792:	1819      	adds	r1, r3, r0
    2794:	2200      	movs	r2, #0
    2796:	541a      	strb	r2, [r3, r0]
		ResultMacroRecordList[ macro ].state     = 0;
    2798:	704a      	strb	r2, [r1, #1]
		ResultMacroRecordList[ macro ].stateType = 0;
    279a:	708a      	strb	r2, [r1, #2]
    279c:	3303      	adds	r3, #3
		TriggerMacroRecordList[ macro ].pos   = 0;
		TriggerMacroRecordList[ macro ].state = TriggerMacro_Waiting;
	}

	// Initialize ResultMacro states
	for ( var_uint_t macro = 0; macro < ResultMacroNum; macro++ )
    279e:	f240 1223 	movw	r2, #291	; 0x123
    27a2:	4293      	cmp	r3, r2
    27a4:	d1f4      	bne.n	2790 <Macro_setup+0x34>
	{
		ResultMacroRecordList[ macro ].pos       = 0;
		ResultMacroRecordList[ macro ].state     = 0;
		ResultMacroRecordList[ macro ].stateType = 0;
	}
}
    27a6:	bd08      	pop	{r3, pc}
    27a8:	00005c2c 	.word	0x00005c2c
    27ac:	00005594 	.word	0x00005594
    27b0:	1ffff16b 	.word	0x1ffff16b
    27b4:	1ffff0a2 	.word	0x1ffff0a2
    27b8:	1fffefde 	.word	0x1fffefde
    27bc:	1ffff16a 	.word	0x1ffff16a
    27c0:	1ffff91e 	.word	0x1ffff91e
    27c4:	1ffffb3d 	.word	0x1ffffb3d
    27c8:	1ffff9da 	.word	0x1ffff9da

000027cc <macroDebugShowTrigger>:
}

void macroDebugShowTrigger( var_uint_t index )
{
	// Only proceed if the macro exists
	if ( index >= TriggerMacroNum )
    27cc:	2861      	cmp	r0, #97	; 0x61
	info_msg("Macro Processing Mode: ");
	printInt8( macroPauseMode );
}

void macroDebugShowTrigger( var_uint_t index )
{
    27ce:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    27d2:	4605      	mov	r5, r0
	// Only proceed if the macro exists
	if ( index >= TriggerMacroNum )
    27d4:	d867      	bhi.n	28a6 <macroDebugShowTrigger+0xda>
		return;

	// Trigger Macro Show
	const TriggerMacro *macro = &TriggerMacroList[ index ];
    27d6:	4c35      	ldr	r4, [pc, #212]	; (28ac <macroDebugShowTrigger+0xe0>)
	TriggerMacroRecord *record = &TriggerMacroRecordList[ index ];
    27d8:	f8df 9100 	ldr.w	r9, [pc, #256]	; 28dc <macroDebugShowTrigger+0x110>
	// Only proceed if the macro exists
	if ( index >= TriggerMacroNum )
		return;

	// Trigger Macro Show
	const TriggerMacro *macro = &TriggerMacroList[ index ];
    27dc:	eb04 08c0 	add.w	r8, r4, r0, lsl #3
	TriggerMacroRecord *record = &TriggerMacroRecordList[ index ];
    27e0:	eb09 0a40 	add.w	sl, r9, r0, lsl #1

	print( NL );
    27e4:	4832      	ldr	r0, [pc, #200]	; (28b0 <macroDebugShowTrigger+0xe4>)
    27e6:	f001 fecb 	bl	4580 <_print>
	info_msg("Trigger Macro Index: ");
    27ea:	4832      	ldr	r0, [pc, #200]	; (28b4 <macroDebugShowTrigger+0xe8>)
    27ec:	f001 fec8 	bl	4580 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    27f0:	4628      	mov	r0, r5
    27f2:	f001 ff17 	bl	4624 <printInt16>
	print( NL );
    27f6:	482e      	ldr	r0, [pc, #184]	; (28b0 <macroDebugShowTrigger+0xe4>)
    27f8:	f001 fec2 	bl	4580 <_print>

	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
	uint8_t comboLength = macro->guide[ pos ];
    27fc:	f854 3035 	ldr.w	r3, [r4, r5, lsl #3]
    2800:	781e      	ldrb	r6, [r3, #0]
	info_msg("Trigger Macro Index: ");
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
	print( NL );

	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
    2802:	2400      	movs	r4, #0
	uint8_t comboLength = macro->guide[ pos ];

	// Iterate through and interpret the guide
	while ( comboLength != 0 )
    2804:	b366      	cbz	r6, 2860 <macroDebugShowTrigger+0x94>
	{
		// Initial position of the combo
		var_uint_t comboPos = ++pos;
    2806:	3401      	adds	r4, #1
    2808:	b2e4      	uxtb	r4, r4

		// Iterate through the combo
		while ( pos < comboLength * TriggerGuideSize + comboPos )
    280a:	2303      	movs	r3, #3
    280c:	fb13 4606 	smlabb	r6, r3, r6, r4
    2810:	42b4      	cmp	r4, r6
    2812:	f8d8 7000 	ldr.w	r7, [r8]
    2816:	d21d      	bcs.n	2854 <macroDebugShowTrigger+0x88>
		{
			// Assign TriggerGuide element (key type, state and scancode)
			TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ pos ]);
    2818:	eb07 0b04 	add.w	fp, r7, r4

			// Display guide information about trigger key
			printHex( guide->scanCode );
    281c:	2101      	movs	r1, #1
    281e:	f89b 0002 	ldrb.w	r0, [fp, #2]
    2822:	f001 ff36 	bl	4692 <printHex_op>
			print("|");
    2826:	4824      	ldr	r0, [pc, #144]	; (28b8 <macroDebugShowTrigger+0xec>)
    2828:	f001 feaa 	bl	4580 <_print>
			printHex( guide->type );
    282c:	5d38      	ldrb	r0, [r7, r4]
    282e:	2101      	movs	r1, #1
    2830:	f001 ff2f 	bl	4692 <printHex_op>
			print("|");
			printHex( guide->state );

			// Increment position
			pos += TriggerGuideSize;
    2834:	3403      	adds	r4, #3

			// Display guide information about trigger key
			printHex( guide->scanCode );
			print("|");
			printHex( guide->type );
			print("|");
    2836:	4820      	ldr	r0, [pc, #128]	; (28b8 <macroDebugShowTrigger+0xec>)
    2838:	f001 fea2 	bl	4580 <_print>
			printHex( guide->state );

			// Increment position
			pos += TriggerGuideSize;
    283c:	b2e4      	uxtb	r4, r4
			// Display guide information about trigger key
			printHex( guide->scanCode );
			print("|");
			printHex( guide->type );
			print("|");
			printHex( guide->state );
    283e:	f89b 0001 	ldrb.w	r0, [fp, #1]
    2842:	2101      	movs	r1, #1
    2844:	f001 ff25 	bl	4692 <printHex_op>

			// Increment position
			pos += TriggerGuideSize;

			// Only show combo separator if there are combos left in the sequence element
			if ( pos < comboLength * TriggerGuideSize + comboPos )
    2848:	42b4      	cmp	r4, r6
    284a:	d2e1      	bcs.n	2810 <macroDebugShowTrigger+0x44>
				print("+");
    284c:	481b      	ldr	r0, [pc, #108]	; (28bc <macroDebugShowTrigger+0xf0>)
    284e:	f001 fe97 	bl	4580 <_print>
    2852:	e7dd      	b.n	2810 <macroDebugShowTrigger+0x44>
		}

		// Read the next comboLength
		comboLength = macro->guide[ pos ];
    2854:	5d3e      	ldrb	r6, [r7, r4]

		// Only show sequence separator if there is another combo to process
		if ( comboLength != 0 )
    2856:	b11e      	cbz	r6, 2860 <macroDebugShowTrigger+0x94>
			print(";");
    2858:	4819      	ldr	r0, [pc, #100]	; (28c0 <macroDebugShowTrigger+0xf4>)
    285a:	f001 fe91 	bl	4580 <_print>
    285e:	e7d1      	b.n	2804 <macroDebugShowTrigger+0x38>
	}

	// Display current position
	print( NL "Position: " );
    2860:	4818      	ldr	r0, [pc, #96]	; (28c4 <macroDebugShowTrigger+0xf8>)
    2862:	f001 fe8d 	bl	4580 <_print>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    2866:	f819 0015 	ldrb.w	r0, [r9, r5, lsl #1]
    286a:	f001 fedb 	bl	4624 <printInt16>

	// Display result macro index
	print( NL "Result Macro Index: " );
    286e:	4816      	ldr	r0, [pc, #88]	; (28c8 <macroDebugShowTrigger+0xfc>)
    2870:	f001 fe86 	bl	4580 <_print>
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    2874:	f898 0004 	ldrb.w	r0, [r8, #4]
    2878:	f001 fed4 	bl	4624 <printInt16>

	// Display trigger macro state
	print( NL "Trigger Macro State: " );
    287c:	4813      	ldr	r0, [pc, #76]	; (28cc <macroDebugShowTrigger+0x100>)
    287e:	f001 fe7f 	bl	4580 <_print>
	switch ( record->state )
    2882:	f89a 3001 	ldrb.w	r3, [sl, #1]
    2886:	2b01      	cmp	r3, #1
    2888:	d006      	beq.n	2898 <macroDebugShowTrigger+0xcc>
    288a:	d303      	bcc.n	2894 <macroDebugShowTrigger+0xc8>
    288c:	2b02      	cmp	r3, #2
    288e:	d005      	beq.n	289c <macroDebugShowTrigger+0xd0>
    2890:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
	case TriggerMacro_Press:   print("Press");   break;
    2894:	480e      	ldr	r0, [pc, #56]	; (28d0 <macroDebugShowTrigger+0x104>)
    2896:	e002      	b.n	289e <macroDebugShowTrigger+0xd2>
	case TriggerMacro_Release: print("Release"); break;
    2898:	480e      	ldr	r0, [pc, #56]	; (28d4 <macroDebugShowTrigger+0x108>)
    289a:	e000      	b.n	289e <macroDebugShowTrigger+0xd2>
	case TriggerMacro_Waiting: print("Waiting"); break;
    289c:	480e      	ldr	r0, [pc, #56]	; (28d8 <macroDebugShowTrigger+0x10c>)
	}
}
    289e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	print( NL "Trigger Macro State: " );
	switch ( record->state )
	{
	case TriggerMacro_Press:   print("Press");   break;
	case TriggerMacro_Release: print("Release"); break;
	case TriggerMacro_Waiting: print("Waiting"); break;
    28a2:	f001 be6d 	b.w	4580 <_print>
    28a6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    28aa:	bf00      	nop
    28ac:	00005f28 	.word	0x00005f28
    28b0:	00006caf 	.word	0x00006caf
    28b4:	00005390 	.word	0x00005390
    28b8:	000053b8 	.word	0x000053b8
    28bc:	000053ba 	.word	0x000053ba
    28c0:	000053bc 	.word	0x000053bc
    28c4:	000053be 	.word	0x000053be
    28c8:	000053cb 	.word	0x000053cb
    28cc:	000053e2 	.word	0x000053e2
    28d0:	00005471 	.word	0x00005471
    28d4:	0000547a 	.word	0x0000547a
    28d8:	000053fa 	.word	0x000053fa
    28dc:	1ffffb3d 	.word	0x1ffffb3d

000028e0 <macroDebugShowResult>:
}

void macroDebugShowResult( var_uint_t index )
{
	// Only proceed if the macro exists
	if ( index >= ResultMacroNum )
    28e0:	2860      	cmp	r0, #96	; 0x60
	case TriggerMacro_Waiting: print("Waiting"); break;
	}
}

void macroDebugShowResult( var_uint_t index )
{
    28e2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    28e6:	4604      	mov	r4, r0
	// Only proceed if the macro exists
	if ( index >= ResultMacroNum )
    28e8:	f200 8097 	bhi.w	2a1a <macroDebugShowResult+0x13a>
		return;

	// Trigger Macro Show
	const ResultMacro *macro = &ResultMacroList[ index ];
    28ec:	4d4c      	ldr	r5, [pc, #304]	; (2a20 <macroDebugShowResult+0x140>)
	ResultMacroRecord *record = &ResultMacroRecordList[ index ];
    28ee:	4b4d      	ldr	r3, [pc, #308]	; (2a24 <macroDebugShowResult+0x144>)
    28f0:	eb00 0940 	add.w	r9, r0, r0, lsl #1
    28f4:	444b      	add	r3, r9
	// Only proceed if the macro exists
	if ( index >= ResultMacroNum )
		return;

	// Trigger Macro Show
	const ResultMacro *macro = &ResultMacroList[ index ];
    28f6:	eb05 0880 	add.w	r8, r5, r0, lsl #2
	ResultMacroRecord *record = &ResultMacroRecordList[ index ];

	print( NL );
    28fa:	484b      	ldr	r0, [pc, #300]	; (2a28 <macroDebugShowResult+0x148>)
	if ( index >= ResultMacroNum )
		return;

	// Trigger Macro Show
	const ResultMacro *macro = &ResultMacroList[ index ];
	ResultMacroRecord *record = &ResultMacroRecordList[ index ];
    28fc:	9301      	str	r3, [sp, #4]

	print( NL );
    28fe:	f001 fe3f 	bl	4580 <_print>
	info_msg("Result Macro Index: ");
    2902:	484a      	ldr	r0, [pc, #296]	; (2a2c <macroDebugShowResult+0x14c>)
    2904:	f001 fe3c 	bl	4580 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    2908:	4620      	mov	r0, r4
    290a:	f001 fe8b 	bl	4624 <printInt16>
	print( NL );
    290e:	4846      	ldr	r0, [pc, #280]	; (2a28 <macroDebugShowResult+0x148>)
    2910:	f001 fe36 	bl	4580 <_print>

	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
	uint8_t comboLength = macro->guide[ pos++ ];
    2914:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
    2918:	781d      	ldrb	r5, [r3, #0]
    291a:	2601      	movs	r6, #1

	// Iterate through and interpret the guide
	while ( comboLength != 0 )
    291c:	b9d5      	cbnz	r5, 2954 <macroDebugShowResult+0x74>
		if ( comboLength != 0 )
			print(";");
	}

	// Display current position
	print( NL "Position: " );
    291e:	4844      	ldr	r0, [pc, #272]	; (2a30 <macroDebugShowResult+0x150>)
    2920:	f001 fe2e 	bl	4580 <_print>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    2924:	4a3f      	ldr	r2, [pc, #252]	; (2a24 <macroDebugShowResult+0x144>)
    2926:	f812 0009 	ldrb.w	r0, [r2, r9]
    292a:	f001 fe7b 	bl	4624 <printInt16>

	// Display final trigger state/type
	print( NL "Final Trigger State (State/Type): " );
    292e:	4841      	ldr	r0, [pc, #260]	; (2a34 <macroDebugShowResult+0x154>)
    2930:	f001 fe26 	bl	4580 <_print>
	printHex( record->state );
    2934:	9b01      	ldr	r3, [sp, #4]
    2936:	2101      	movs	r1, #1
    2938:	7858      	ldrb	r0, [r3, #1]
    293a:	f001 feaa 	bl	4692 <printHex_op>
	print("/");
    293e:	483e      	ldr	r0, [pc, #248]	; (2a38 <macroDebugShowResult+0x158>)
    2940:	f001 fe1e 	bl	4580 <_print>
	printHex( record->stateType );
    2944:	9b01      	ldr	r3, [sp, #4]
    2946:	7898      	ldrb	r0, [r3, #2]
    2948:	2101      	movs	r1, #1
}
    294a:	b003      	add	sp, #12
    294c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	// Display final trigger state/type
	print( NL "Final Trigger State (State/Type): " );
	printHex( record->state );
	print("/");
	printHex( record->stateType );
    2950:	f001 be9f 	b.w	4692 <printHex_op>
	// Read the comboLength for combo in the sequence (sequence of combos)
	var_uint_t pos = 0;
	uint8_t comboLength = macro->guide[ pos++ ];

	// Iterate through and interpret the guide
	while ( comboLength != 0 )
    2954:	4634      	mov	r4, r6
    2956:	2600      	movs	r6, #0

		// Iterate through the combo
		while ( funcCount < comboLength )
		{
			// Assign TriggerGuide element (key type, state and scancode)
			ResultGuide *guide = (ResultGuide*)(&macro->guide[ pos ]);
    2958:	f8d8 a000 	ldr.w	sl, [r8]
			// Display Function Index
			printHex( guide->index );
			print("|");

			// Display Function Ptr Address
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    295c:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 2a54 <macroDebugShowResult+0x174>
		{
			// Assign TriggerGuide element (key type, state and scancode)
			ResultGuide *guide = (ResultGuide*)(&macro->guide[ pos ]);

			// Display Function Index
			printHex( guide->index );
    2960:	f81a 0004 	ldrb.w	r0, [sl, r4]
    2964:	2101      	movs	r1, #1
    2966:	f001 fe94 	bl	4692 <printHex_op>
			print("|");
    296a:	4834      	ldr	r0, [pc, #208]	; (2a3c <macroDebugShowResult+0x15c>)
    296c:	f001 fe08 	bl	4580 <_print>

			// Display Function Ptr Address
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    2970:	f81a 2004 	ldrb.w	r2, [sl, r4]
    2974:	2101      	movs	r1, #1
    2976:	f83b 0032 	ldrh.w	r0, [fp, r2, lsl #3]
    297a:	f001 fe8a 	bl	4692 <printHex_op>
			print("|");
    297e:	482f      	ldr	r0, [pc, #188]	; (2a3c <macroDebugShowResult+0x15c>)
    2980:	f001 fdfe 	bl	4580 <_print>

			// Display/Lookup Capability Name (utilize debug mode of capability)
			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
    2984:	f81a 3004 	ldrb.w	r3, [sl, r4]
			capability( 0xFF, 0xFF, 0 );
    2988:	20ff      	movs	r0, #255	; 0xff
    298a:	4601      	mov	r1, r0
    298c:	f85b 3033 	ldr.w	r3, [fp, r3, lsl #3]
    2990:	2200      	movs	r2, #0
    2992:	4798      	blx	r3

			// Display Argument(s)
			print("(");
    2994:	482a      	ldr	r0, [pc, #168]	; (2a40 <macroDebugShowResult+0x160>)
    2996:	f001 fdf3 	bl	4580 <_print>

		// Iterate through the combo
		while ( funcCount < comboLength )
		{
			// Assign TriggerGuide element (key type, state and scancode)
			ResultGuide *guide = (ResultGuide*)(&macro->guide[ pos ]);
    299a:	eb0a 0704 	add.w	r7, sl, r4
			void (*capability)(uint8_t, uint8_t, uint8_t*) = (void(*)(uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
			capability( 0xFF, 0xFF, 0 );

			// Display Argument(s)
			print("(");
			for ( var_uint_t arg = 0; arg < CapabilitiesList[ guide->index ].argCount; arg++ )
    299e:	f04f 0a00 	mov.w	sl, #0
    29a2:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 2a54 <macroDebugShowResult+0x174>
    29a6:	783b      	ldrb	r3, [r7, #0]
    29a8:	eb0b 03c3 	add.w	r3, fp, r3, lsl #3
    29ac:	7919      	ldrb	r1, [r3, #4]
    29ae:	fa5f f38a 	uxtb.w	r3, sl
    29b2:	4299      	cmp	r1, r3
    29b4:	d913      	bls.n	29de <macroDebugShowResult+0xfe>
			{
				// Arguments are only 8 bit values
				printHex( (&guide->args)[ arg ] );
    29b6:	18f9      	adds	r1, r7, r3
    29b8:	7848      	ldrb	r0, [r1, #1]
    29ba:	9300      	str	r3, [sp, #0]
    29bc:	2101      	movs	r1, #1
    29be:	f001 fe68 	bl	4692 <printHex_op>

				// Only show arg separator if there are args left
				if ( arg + 1 < CapabilitiesList[ guide->index ].argCount )
    29c2:	7839      	ldrb	r1, [r7, #0]
    29c4:	9b00      	ldr	r3, [sp, #0]
    29c6:	eb0b 01c1 	add.w	r1, fp, r1, lsl #3
    29ca:	3301      	adds	r3, #1
    29cc:	7909      	ldrb	r1, [r1, #4]
    29ce:	428b      	cmp	r3, r1
    29d0:	da02      	bge.n	29d8 <macroDebugShowResult+0xf8>
					print(",");
    29d2:	481c      	ldr	r0, [pc, #112]	; (2a44 <macroDebugShowResult+0x164>)
    29d4:	f001 fdd4 	bl	4580 <_print>
    29d8:	f10a 0a01 	add.w	sl, sl, #1
    29dc:	e7e1      	b.n	29a2 <macroDebugShowResult+0xc2>
			}
			print(")");
    29de:	481a      	ldr	r0, [pc, #104]	; (2a48 <macroDebugShowResult+0x168>)
    29e0:	f001 fdce 	bl	4580 <_print>

			// Increment position
			pos += ResultGuideSize( guide );
    29e4:	783b      	ldrb	r3, [r7, #0]
    29e6:	eb0b 03c3 	add.w	r3, fp, r3, lsl #3

			// Increment function count
			funcCount++;
    29ea:	3601      	adds	r6, #1
					print(",");
			}
			print(")");

			// Increment position
			pos += ResultGuideSize( guide );
    29ec:	791b      	ldrb	r3, [r3, #4]

			// Increment function count
			funcCount++;
    29ee:	b2f6      	uxtb	r6, r6
					print(",");
			}
			print(")");

			// Increment position
			pos += ResultGuideSize( guide );
    29f0:	3301      	adds	r3, #1
    29f2:	441c      	add	r4, r3

			// Increment function count
			funcCount++;

			// Only show combo separator if there are combos left in the sequence element
			if ( funcCount < comboLength )
    29f4:	42ae      	cmp	r6, r5
					print(",");
			}
			print(")");

			// Increment position
			pos += ResultGuideSize( guide );
    29f6:	b2e4      	uxtb	r4, r4

			// Increment function count
			funcCount++;

			// Only show combo separator if there are combos left in the sequence element
			if ( funcCount < comboLength )
    29f8:	d202      	bcs.n	2a00 <macroDebugShowResult+0x120>
				print("+");
    29fa:	4814      	ldr	r0, [pc, #80]	; (2a4c <macroDebugShowResult+0x16c>)
    29fc:	f001 fdc0 	bl	4580 <_print>
	{
		// Function Counter, used to keep track of the combos processed
		var_uint_t funcCount = 0;

		// Iterate through the combo
		while ( funcCount < comboLength )
    2a00:	42ae      	cmp	r6, r5
    2a02:	d1a9      	bne.n	2958 <macroDebugShowResult+0x78>
			if ( funcCount < comboLength )
				print("+");
		}

		// Read the next comboLength
		comboLength = macro->guide[ pos++ ];
    2a04:	f8d8 3000 	ldr.w	r3, [r8]
    2a08:	5d1d      	ldrb	r5, [r3, r4]
    2a0a:	1c66      	adds	r6, r4, #1
    2a0c:	b2f6      	uxtb	r6, r6

		// Only show sequence separator if there is another combo to process
		if ( comboLength != 0 )
    2a0e:	2d00      	cmp	r5, #0
    2a10:	d085      	beq.n	291e <macroDebugShowResult+0x3e>
			print(";");
    2a12:	480f      	ldr	r0, [pc, #60]	; (2a50 <macroDebugShowResult+0x170>)
    2a14:	f001 fdb4 	bl	4580 <_print>
    2a18:	e780      	b.n	291c <macroDebugShowResult+0x3c>
	// Display final trigger state/type
	print( NL "Final Trigger State (State/Type): " );
	printHex( record->state );
	print("/");
	printHex( record->stateType );
}
    2a1a:	b003      	add	sp, #12
    2a1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2a20:	000057a0 	.word	0x000057a0
    2a24:	1ffff9da 	.word	0x1ffff9da
    2a28:	00006caf 	.word	0x00006caf
    2a2c:	00005402 	.word	0x00005402
    2a30:	000053be 	.word	0x000053be
    2a34:	0000542d 	.word	0x0000542d
    2a38:	00005452 	.word	0x00005452
    2a3c:	000053b8 	.word	0x000053b8
    2a40:	00005429 	.word	0x00005429
    2a44:	0000542b 	.word	0x0000542b
    2a48:	000067a3 	.word	0x000067a3
    2a4c:	000053ba 	.word	0x000053ba
    2a50:	000053bc 	.word	0x000053bc
    2a54:	00004ce8 	.word	0x00004ce8

00002a58 <cliFunc_macroShow>:

void cliFunc_macroShow( char* args )
{
    2a58:	b507      	push	{r0, r1, r2, lr}
	// Parse codes from arguments
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    2a5a:	9001      	str	r0, [sp, #4]

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2a5c:	9801      	ldr	r0, [sp, #4]
    2a5e:	4669      	mov	r1, sp
    2a60:	aa01      	add	r2, sp, #4
    2a62:	f001 fad7 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    2a66:	9800      	ldr	r0, [sp, #0]
    2a68:	7803      	ldrb	r3, [r0, #0]
    2a6a:	b18b      	cbz	r3, 2a90 <cliFunc_macroShow+0x38>
			break;

		// Ignore invalid codes
		switch ( arg1Ptr[0] )
    2a6c:	2b52      	cmp	r3, #82	; 0x52
    2a6e:	d008      	beq.n	2a82 <cliFunc_macroShow+0x2a>
    2a70:	2b54      	cmp	r3, #84	; 0x54
    2a72:	d1f3      	bne.n	2a5c <cliFunc_macroShow+0x4>
		{
		// Indexed Trigger Macro
		case 'T':
			macroDebugShowTrigger( numToInt( &arg1Ptr[1] ) );
    2a74:	3001      	adds	r0, #1
    2a76:	f001 fe61 	bl	473c <numToInt>
    2a7a:	b2c0      	uxtb	r0, r0
    2a7c:	f7ff fea6 	bl	27cc <macroDebugShowTrigger>
			break;
    2a80:	e7ec      	b.n	2a5c <cliFunc_macroShow+0x4>
		// Indexed Result Macro
		case 'R':
			macroDebugShowResult( numToInt( &arg1Ptr[1] ) );
    2a82:	3001      	adds	r0, #1
    2a84:	f001 fe5a 	bl	473c <numToInt>
    2a88:	b2c0      	uxtb	r0, r0
    2a8a:	f7ff ff29 	bl	28e0 <macroDebugShowResult>
			break;
    2a8e:	e7e5      	b.n	2a5c <cliFunc_macroShow+0x4>
		}
	}
}
    2a90:	b003      	add	sp, #12
    2a92:	f85d fb04 	ldr.w	pc, [sp], #4
    2a96:	0000      	movs	r0, r0

00002a98 <cliFunc_sendKeys>:


void cliFunc_sendKeys( char* args )
{
	// Copy USBKeys_KeysCLI to USBKeys_Keys
	for ( uint8_t key = 0; key < USBKeys_SentCLI; ++key )
    2a98:	4b04      	ldr	r3, [pc, #16]	; (2aac <cliFunc_sendKeys+0x14>)
	{
		// TODO
		//USBKeys_Keys[key] = USBKeys_KeysCLI[key];
	}
	USBKeys_Sent = USBKeys_SentCLI;
    2a9a:	781a      	ldrb	r2, [r3, #0]
    2a9c:	4b04      	ldr	r3, [pc, #16]	; (2ab0 <cliFunc_sendKeys+0x18>)
    2a9e:	701a      	strb	r2, [r3, #0]

	// Set modifier byte
	USBKeys_Modifiers = USBKeys_ModifiersCLI;
    2aa0:	4b04      	ldr	r3, [pc, #16]	; (2ab4 <cliFunc_sendKeys+0x1c>)
    2aa2:	781a      	ldrb	r2, [r3, #0]
    2aa4:	4b04      	ldr	r3, [pc, #16]	; (2ab8 <cliFunc_sendKeys+0x20>)
    2aa6:	701a      	strb	r2, [r3, #0]
    2aa8:	4770      	bx	lr
    2aaa:	bf00      	nop
    2aac:	1ffff17d 	.word	0x1ffff17d
    2ab0:	1ffff17c 	.word	0x1ffff17c
    2ab4:	1ffff17f 	.word	0x1ffff17f
    2ab8:	1ffff178 	.word	0x1ffff178

00002abc <cliFunc_kbdProtocol>:


// ----- CLI Command Functions -----

void cliFunc_kbdProtocol( char* args )
{
    2abc:	b508      	push	{r3, lr}
	print( NL );
    2abe:	4806      	ldr	r0, [pc, #24]	; (2ad8 <cliFunc_kbdProtocol+0x1c>)
    2ac0:	f001 fd5e 	bl	4580 <_print>
	info_msg("Keyboard Protocol: ");
    2ac4:	4805      	ldr	r0, [pc, #20]	; (2adc <cliFunc_kbdProtocol+0x20>)
    2ac6:	f001 fd5b 	bl	4580 <_print>
	printInt8( USBKeys_Protocol );
    2aca:	4b05      	ldr	r3, [pc, #20]	; (2ae0 <cliFunc_kbdProtocol+0x24>)
    2acc:	7818      	ldrb	r0, [r3, #0]
}
    2ace:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void cliFunc_kbdProtocol( char* args )
{
	print( NL );
	info_msg("Keyboard Protocol: ");
	printInt8( USBKeys_Protocol );
    2ad2:	f001 bd87 	b.w	45e4 <printInt8>
    2ad6:	bf00      	nop
    2ad8:	00006caf 	.word	0x00006caf
    2adc:	00006640 	.word	0x00006640
    2ae0:	1fffeb81 	.word	0x1fffeb81

00002ae4 <cliFunc_readLEDs>:
	}
}


void cliFunc_readLEDs( char* args )
{
    2ae4:	b508      	push	{r3, lr}
	print( NL );
    2ae6:	4806      	ldr	r0, [pc, #24]	; (2b00 <cliFunc_readLEDs+0x1c>)
    2ae8:	f001 fd4a 	bl	4580 <_print>
	info_msg("LED State: ");
    2aec:	4805      	ldr	r0, [pc, #20]	; (2b04 <cliFunc_readLEDs+0x20>)
    2aee:	f001 fd47 	bl	4580 <_print>
	printInt8( USBKeys_LEDs );
    2af2:	4b05      	ldr	r3, [pc, #20]	; (2b08 <cliFunc_readLEDs+0x24>)
    2af4:	7818      	ldrb	r0, [r3, #0]
}
    2af6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void cliFunc_readLEDs( char* args )
{
	print( NL );
	info_msg("LED State: ");
	printInt8( USBKeys_LEDs );
    2afa:	f001 bd73 	b.w	45e4 <printInt8>
    2afe:	bf00      	nop
    2b00:	00006caf 	.word	0x00006caf
    2b04:	00006666 	.word	0x00006666
    2b08:	1ffff177 	.word	0x1ffff177

00002b0c <cliFunc_setKeys>:
	USBKeys_Modifiers = USBKeys_ModifiersCLI;
}


void cliFunc_setKeys( char* args )
{
    2b0c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Parse up to USBKeys_MaxSize args (whichever is least)
	for ( USBKeys_SentCLI = 0; USBKeys_SentCLI < USB_BOOT_MAX_KEYS; ++USBKeys_SentCLI )
    2b0e:	4b0b      	ldr	r3, [pc, #44]	; (2b3c <cliFunc_setKeys+0x30>)

void cliFunc_setKeys( char* args )
{
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    2b10:	9001      	str	r0, [sp, #4]

	// Parse up to USBKeys_MaxSize args (whichever is least)
	for ( USBKeys_SentCLI = 0; USBKeys_SentCLI < USB_BOOT_MAX_KEYS; ++USBKeys_SentCLI )
    2b12:	2200      	movs	r2, #0
    2b14:	701a      	strb	r2, [r3, #0]
    2b16:	461d      	mov	r5, r3
    2b18:	782b      	ldrb	r3, [r5, #0]
    2b1a:	4c08      	ldr	r4, [pc, #32]	; (2b3c <cliFunc_setKeys+0x30>)
    2b1c:	2b05      	cmp	r3, #5
    2b1e:	d80b      	bhi.n	2b38 <cliFunc_setKeys+0x2c>
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    2b20:	aa01      	add	r2, sp, #4
    2b22:	9801      	ldr	r0, [sp, #4]
    2b24:	4669      	mov	r1, sp
    2b26:	f001 fa75 	bl	4014 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    2b2a:	9a00      	ldr	r2, [sp, #0]
    2b2c:	7813      	ldrb	r3, [r2, #0]
    2b2e:	b11b      	cbz	r3, 2b38 <cliFunc_setKeys+0x2c>
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;

	// Parse up to USBKeys_MaxSize args (whichever is least)
	for ( USBKeys_SentCLI = 0; USBKeys_SentCLI < USB_BOOT_MAX_KEYS; ++USBKeys_SentCLI )
    2b30:	7823      	ldrb	r3, [r4, #0]
    2b32:	3301      	adds	r3, #1
    2b34:	7023      	strb	r3, [r4, #0]
    2b36:	e7ef      	b.n	2b18 <cliFunc_setKeys+0xc>

		// Add the USB code to be sent
		// TODO
		//USBKeys_KeysCLI[USBKeys_SentCLI] = numToInt( arg1Ptr );
	}
}
    2b38:	b003      	add	sp, #12
    2b3a:	bd30      	pop	{r4, r5, pc}
    2b3c:	1ffff17d 	.word	0x1ffff17d

00002b40 <cliFunc_outputDebug>:
	printInt8( USBKeys_Protocol );
}


void cliFunc_outputDebug( char* args )
{
    2b40:	b513      	push	{r0, r1, r4, lr}
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	Output_DebugMode = 1;
    2b42:	4c07      	ldr	r4, [pc, #28]	; (2b60 <cliFunc_outputDebug+0x20>)
{
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    2b44:	4669      	mov	r1, sp
    2b46:	aa01      	add	r2, sp, #4
    2b48:	f001 fa64 	bl	4014 <CLI_argumentIsolation>

	// Default to 1 if no argument is given
	Output_DebugMode = 1;
    2b4c:	2301      	movs	r3, #1

	if ( arg1Ptr[0] != '\0' )
    2b4e:	9800      	ldr	r0, [sp, #0]
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	Output_DebugMode = 1;
    2b50:	7023      	strb	r3, [r4, #0]

	if ( arg1Ptr[0] != '\0' )
    2b52:	7803      	ldrb	r3, [r0, #0]
    2b54:	b113      	cbz	r3, 2b5c <cliFunc_outputDebug+0x1c>
	{
		Output_DebugMode = (uint16_t)numToInt( arg1Ptr );
    2b56:	f001 fdf1 	bl	473c <numToInt>
    2b5a:	7020      	strb	r0, [r4, #0]
	}
}
    2b5c:	b002      	add	sp, #8
    2b5e:	bd10      	pop	{r4, pc}
    2b60:	1ffff17b 	.word	0x1ffff17b

00002b64 <cliFunc_setMod>:
	}
}


void cliFunc_setMod( char* args )
{
    2b64:	b507      	push	{r0, r1, r2, lr}
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    2b66:	4669      	mov	r1, sp
    2b68:	aa01      	add	r2, sp, #4
    2b6a:	f001 fa53 	bl	4014 <CLI_argumentIsolation>

	USBKeys_ModifiersCLI = numToInt( arg1Ptr );
    2b6e:	9800      	ldr	r0, [sp, #0]
    2b70:	f001 fde4 	bl	473c <numToInt>
    2b74:	4b02      	ldr	r3, [pc, #8]	; (2b80 <cliFunc_setMod+0x1c>)
    2b76:	7018      	strb	r0, [r3, #0]
}
    2b78:	b003      	add	sp, #12
    2b7a:	f85d fb04 	ldr.w	pc, [sp], #4
    2b7e:	bf00      	nop
    2b80:	1ffff17f 	.word	0x1ffff17f

00002b84 <Output_consCtrlSend_capability>:

// Sends a Consumer Control code to the USB Output buffer
void Output_consCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2b84:	29ff      	cmp	r1, #255	; 0xff
}


// Sends a Consumer Control code to the USB Output buffer
void Output_consCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    2b86:	b530      	push	{r4, r5, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2b88:	d103      	bne.n	2b92 <Output_consCtrlSend_capability+0xe>
    2b8a:	28ff      	cmp	r0, #255	; 0xff
    2b8c:	d101      	bne.n	2b92 <Output_consCtrlSend_capability+0xe>
	{
		print("Output_consCtrlSend(consCode)");
    2b8e:	480e      	ldr	r0, [pc, #56]	; (2bc8 <Output_consCtrlSend_capability+0x44>)
    2b90:	e003      	b.n	2b9a <Output_consCtrlSend_capability+0x16>
		return;
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
    2b92:	4b0e      	ldr	r3, [pc, #56]	; (2bcc <Output_consCtrlSend_capability+0x48>)
    2b94:	781b      	ldrb	r3, [r3, #0]
    2b96:	b923      	cbnz	r3, 2ba2 <Output_consCtrlSend_capability+0x1e>
	{
		warn_print("Consumer Control is not implemented for Boot Mode");
    2b98:	480d      	ldr	r0, [pc, #52]	; (2bd0 <Output_consCtrlSend_capability+0x4c>)
		return;
	}

	// Set consumer control code
	USBKeys_ConsCtrl = *(uint16_t*)(&args[0]);
}
    2b9a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
	{
		warn_print("Consumer Control is not implemented for Boot Mode");
    2b9e:	f001 bcef 	b.w	4580 <_print>
		return;
	}

	// TODO Analog inputs
	// Only indicate USB has changed if either a press or release has occured
	if ( state == 0x01 || state == 0x03 )
    2ba2:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    2ba6:	2b01      	cmp	r3, #1
    2ba8:	4b0a      	ldr	r3, [pc, #40]	; (2bd4 <Output_consCtrlSend_capability+0x50>)
    2baa:	d109      	bne.n	2bc0 <Output_consCtrlSend_capability+0x3c>
		USBKeys_Changed |= USBKeyChangeState_Consumer;
    2bac:	4c0a      	ldr	r4, [pc, #40]	; (2bd8 <Output_consCtrlSend_capability+0x54>)
    2bae:	7825      	ldrb	r5, [r4, #0]
    2bb0:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    2bb4:	7025      	strb	r5, [r4, #0]

	// Only send keypresses if press or hold state
	if ( stateType == 0x00 && state == 0x03 ) // Release state
    2bb6:	b919      	cbnz	r1, 2bc0 <Output_consCtrlSend_capability+0x3c>
    2bb8:	2803      	cmp	r0, #3
    2bba:	d101      	bne.n	2bc0 <Output_consCtrlSend_capability+0x3c>
	{
		USBKeys_ConsCtrl = 0;
    2bbc:	8019      	strh	r1, [r3, #0]
		return;
    2bbe:	bd30      	pop	{r4, r5, pc}
	}

	// Set consumer control code
	USBKeys_ConsCtrl = *(uint16_t*)(&args[0]);
    2bc0:	8812      	ldrh	r2, [r2, #0]
    2bc2:	801a      	strh	r2, [r3, #0]
    2bc4:	bd30      	pop	{r4, r5, pc}
    2bc6:	bf00      	nop
    2bc8:	00006684 	.word	0x00006684
    2bcc:	1fffeb81 	.word	0x1fffeb81
    2bd0:	000066a2 	.word	0x000066a2
    2bd4:	1ffffc3a 	.word	0x1ffffc3a
    2bd8:	1ffff179 	.word	0x1ffff179

00002bdc <Output_noneSend_capability>:
// Ignores the given key status update
// Used to prevent fall-through, this is the None keyword in KLL
void Output_noneSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2bdc:	29ff      	cmp	r1, #255	; 0xff
    2bde:	d104      	bne.n	2bea <Output_noneSend_capability+0xe>
    2be0:	28ff      	cmp	r0, #255	; 0xff
    2be2:	d102      	bne.n	2bea <Output_noneSend_capability+0xe>
	{
		print("Output_noneSend()");
    2be4:	4801      	ldr	r0, [pc, #4]	; (2bec <Output_noneSend_capability+0x10>)
    2be6:	f001 bccb 	b.w	4580 <_print>
    2bea:	4770      	bx	lr
    2bec:	000066eb 	.word	0x000066eb

00002bf0 <Output_sysCtrlSend_capability>:

// Sends a System Control code to the USB Output buffer
void Output_sysCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2bf0:	29ff      	cmp	r1, #255	; 0xff
}


// Sends a System Control code to the USB Output buffer
void Output_sysCtrlSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    2bf2:	b530      	push	{r4, r5, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2bf4:	d103      	bne.n	2bfe <Output_sysCtrlSend_capability+0xe>
    2bf6:	28ff      	cmp	r0, #255	; 0xff
    2bf8:	d101      	bne.n	2bfe <Output_sysCtrlSend_capability+0xe>
	{
		print("Output_sysCtrlSend(sysCode)");
    2bfa:	480e      	ldr	r0, [pc, #56]	; (2c34 <Output_sysCtrlSend_capability+0x44>)
    2bfc:	e003      	b.n	2c06 <Output_sysCtrlSend_capability+0x16>
		return;
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
    2bfe:	4b0e      	ldr	r3, [pc, #56]	; (2c38 <Output_sysCtrlSend_capability+0x48>)
    2c00:	781b      	ldrb	r3, [r3, #0]
    2c02:	b923      	cbnz	r3, 2c0e <Output_sysCtrlSend_capability+0x1e>
	{
		warn_print("System Control is not implemented for Boot Mode");
    2c04:	480d      	ldr	r0, [pc, #52]	; (2c3c <Output_sysCtrlSend_capability+0x4c>)
		return;
	}

	// Set system control code
	USBKeys_SysCtrl = args[0];
}
    2c06:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	}

	// Not implemented in Boot Mode
	if ( USBKeys_Protocol == 0 )
	{
		warn_print("System Control is not implemented for Boot Mode");
    2c0a:	f001 bcb9 	b.w	4580 <_print>
		return;
	}

	// TODO Analog inputs
	// Only indicate USB has changed if either a press or release has occured
	if ( state == 0x01 || state == 0x03 )
    2c0e:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    2c12:	2b01      	cmp	r3, #1
    2c14:	4b0a      	ldr	r3, [pc, #40]	; (2c40 <Output_sysCtrlSend_capability+0x50>)
    2c16:	d109      	bne.n	2c2c <Output_sysCtrlSend_capability+0x3c>
		USBKeys_Changed |= USBKeyChangeState_System;
    2c18:	4c0a      	ldr	r4, [pc, #40]	; (2c44 <Output_sysCtrlSend_capability+0x54>)
    2c1a:	7825      	ldrb	r5, [r4, #0]
    2c1c:	f045 0520 	orr.w	r5, r5, #32
    2c20:	7025      	strb	r5, [r4, #0]

	// Only send keypresses if press or hold state
	if ( stateType == 0x00 && state == 0x03 ) // Release state
    2c22:	b919      	cbnz	r1, 2c2c <Output_sysCtrlSend_capability+0x3c>
    2c24:	2803      	cmp	r0, #3
    2c26:	d101      	bne.n	2c2c <Output_sysCtrlSend_capability+0x3c>
	{
		USBKeys_SysCtrl = 0;
    2c28:	7019      	strb	r1, [r3, #0]
		return;
    2c2a:	bd30      	pop	{r4, r5, pc}
	}

	// Set system control code
	USBKeys_SysCtrl = args[0];
    2c2c:	7812      	ldrb	r2, [r2, #0]
    2c2e:	701a      	strb	r2, [r3, #0]
    2c30:	bd30      	pop	{r4, r5, pc}
    2c32:	bf00      	nop
    2c34:	000066fd 	.word	0x000066fd
    2c38:	1fffeb81 	.word	0x1fffeb81
    2c3c:	00006719 	.word	0x00006719
    2c40:	1ffffc02 	.word	0x1ffffc02
    2c44:	1ffff179 	.word	0x1ffff179

00002c48 <Output_flashMode_capability>:
}

void Output_flashMode_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2c48:	29ff      	cmp	r1, #255	; 0xff
    2c4a:	d104      	bne.n	2c56 <Output_flashMode_capability+0xe>
    2c4c:	28ff      	cmp	r0, #255	; 0xff
    2c4e:	d102      	bne.n	2c56 <Output_flashMode_capability+0xe>
	{
		print("Output_flashMode()");
    2c50:	4802      	ldr	r0, [pc, #8]	; (2c5c <Output_flashMode_capability+0x14>)
    2c52:	f001 bc95 	b.w	4580 <_print>


// Sets the device into firmware reload mode
inline void Output_firmwareReload()
{
	usb_device_reload();
    2c56:	f000 ba57 	b.w	3108 <usb_device_reload>
    2c5a:	bf00      	nop
    2c5c:	00006760 	.word	0x00006760

00002c60 <Output_flushBuffers>:

// ----- Functions -----

// Flush Key buffers
void Output_flushBuffers()
{
    2c60:	2200      	movs	r2, #0
	// Zero out USBKeys_Keys array
	for ( uint8_t c = 0; c < USB_NKRO_BITFIELD_SIZE_KEYS; c++ )
		USBKeys_Keys[ c ] = 0;
    2c62:	4906      	ldr	r1, [pc, #24]	; (2c7c <Output_flushBuffers+0x1c>)
    2c64:	2300      	movs	r3, #0
    2c66:	5453      	strb	r3, [r2, r1]
    2c68:	3201      	adds	r2, #1

// Flush Key buffers
void Output_flushBuffers()
{
	// Zero out USBKeys_Keys array
	for ( uint8_t c = 0; c < USB_NKRO_BITFIELD_SIZE_KEYS; c++ )
    2c6a:	2a1b      	cmp	r2, #27
    2c6c:	d1f9      	bne.n	2c62 <Output_flushBuffers+0x2>
		USBKeys_Keys[ c ] = 0;

	// Zero out other key buffers
	USBKeys_ConsCtrl = 0;
    2c6e:	4a04      	ldr	r2, [pc, #16]	; (2c80 <Output_flushBuffers+0x20>)
    2c70:	8013      	strh	r3, [r2, #0]
	USBKeys_Modifiers = 0;
    2c72:	4a04      	ldr	r2, [pc, #16]	; (2c84 <Output_flushBuffers+0x24>)
    2c74:	7013      	strb	r3, [r2, #0]
	USBKeys_SysCtrl = 0;
    2c76:	4a04      	ldr	r2, [pc, #16]	; (2c88 <Output_flushBuffers+0x28>)
    2c78:	7013      	strb	r3, [r2, #0]
    2c7a:	4770      	bx	lr
    2c7c:	1ffffc03 	.word	0x1ffffc03
    2c80:	1ffffc3a 	.word	0x1ffffc3a
    2c84:	1ffff178 	.word	0x1ffff178
    2c88:	1ffffc02 	.word	0x1ffffc02

00002c8c <Output_kbdProtocolBoot_capability>:

// Set Boot Keyboard Protocol
void Output_kbdProtocolBoot_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2c8c:	29ff      	cmp	r1, #255	; 0xff

// ----- Capabilities -----

// Set Boot Keyboard Protocol
void Output_kbdProtocolBoot_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    2c8e:	b510      	push	{r4, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2c90:	d106      	bne.n	2ca0 <Output_kbdProtocolBoot_capability+0x14>
    2c92:	28ff      	cmp	r0, #255	; 0xff
    2c94:	d104      	bne.n	2ca0 <Output_kbdProtocolBoot_capability+0x14>
	{
		print("Output_kbdProtocolBoot()");
    2c96:	4807      	ldr	r0, [pc, #28]	; (2cb4 <Output_kbdProtocolBoot_capability+0x28>)
	// Flush the key buffers
	Output_flushBuffers();

	// Set the keyboard protocol to Boot Mode
	USBKeys_Protocol = 0;
}
    2c98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void Output_kbdProtocolBoot_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
	{
		print("Output_kbdProtocolBoot()");
    2c9c:	f001 bc70 	b.w	4580 <_print>
		return;
	}

	// Only set if necessary
	if ( USBKeys_Protocol == 0 )
    2ca0:	4c05      	ldr	r4, [pc, #20]	; (2cb8 <Output_kbdProtocolBoot_capability+0x2c>)
    2ca2:	7823      	ldrb	r3, [r4, #0]
    2ca4:	b12b      	cbz	r3, 2cb2 <Output_kbdProtocolBoot_capability+0x26>
		return;

	// TODO Analog inputs
	// Only set on key press
	if ( stateType != 0x01 )
    2ca6:	2901      	cmp	r1, #1
    2ca8:	d103      	bne.n	2cb2 <Output_kbdProtocolBoot_capability+0x26>
		return;

	// Flush the key buffers
	Output_flushBuffers();
    2caa:	f7ff ffd9 	bl	2c60 <Output_flushBuffers>

	// Set the keyboard protocol to Boot Mode
	USBKeys_Protocol = 0;
    2cae:	2300      	movs	r3, #0
    2cb0:	7023      	strb	r3, [r4, #0]
    2cb2:	bd10      	pop	{r4, pc}
    2cb4:	00006773 	.word	0x00006773
    2cb8:	1fffeb81 	.word	0x1fffeb81

00002cbc <Output_kbdProtocolNKRO_capability>:

// Set NKRO Keyboard Protocol
void Output_kbdProtocolNKRO_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2cbc:	29ff      	cmp	r1, #255	; 0xff
}


// Set NKRO Keyboard Protocol
void Output_kbdProtocolNKRO_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    2cbe:	b538      	push	{r3, r4, r5, lr}
    2cc0:	460c      	mov	r4, r1
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2cc2:	d106      	bne.n	2cd2 <Output_kbdProtocolNKRO_capability+0x16>
    2cc4:	28ff      	cmp	r0, #255	; 0xff
    2cc6:	d104      	bne.n	2cd2 <Output_kbdProtocolNKRO_capability+0x16>
	{
		print("Output_kbdProtocolNKRO()");
    2cc8:	4807      	ldr	r0, [pc, #28]	; (2ce8 <Output_kbdProtocolNKRO_capability+0x2c>)
	// Flush the key buffers
	Output_flushBuffers();

	// Set the keyboard protocol to NKRO Mode
	USBKeys_Protocol = 1;
}
    2cca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void Output_kbdProtocolNKRO_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
	{
		print("Output_kbdProtocolNKRO()");
    2cce:	f001 bc57 	b.w	4580 <_print>
		return;
	}

	// Only set if necessary
	if ( USBKeys_Protocol == 1 )
    2cd2:	4d06      	ldr	r5, [pc, #24]	; (2cec <Output_kbdProtocolNKRO_capability+0x30>)
    2cd4:	782b      	ldrb	r3, [r5, #0]
    2cd6:	2b01      	cmp	r3, #1
    2cd8:	d004      	beq.n	2ce4 <Output_kbdProtocolNKRO_capability+0x28>
		return;

	// TODO Analog inputs
	// Only set on key press
	if ( stateType != 0x01 )
    2cda:	2c01      	cmp	r4, #1
    2cdc:	d102      	bne.n	2ce4 <Output_kbdProtocolNKRO_capability+0x28>
		return;

	// Flush the key buffers
	Output_flushBuffers();
    2cde:	f7ff ffbf 	bl	2c60 <Output_flushBuffers>

	// Set the keyboard protocol to NKRO Mode
	USBKeys_Protocol = 1;
    2ce2:	702c      	strb	r4, [r5, #0]
    2ce4:	bd38      	pop	{r3, r4, r5, pc}
    2ce6:	bf00      	nop
    2ce8:	0000678c 	.word	0x0000678c
    2cec:	1fffeb81 	.word	0x1fffeb81

00002cf0 <Output_usbCodeSend_capability>:
// Adds a single USB Code to the USB Output buffer
// Argument #1: USB Code
void Output_usbCodeSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2cf0:	29ff      	cmp	r1, #255	; 0xff


// Adds a single USB Code to the USB Output buffer
// Argument #1: USB Code
void Output_usbCodeSend_capability( uint8_t state, uint8_t stateType, uint8_t *args )
{
    2cf2:	b570      	push	{r4, r5, r6, lr}
	// Display capability name
	if ( stateType == 0xFF && state == 0xFF )
    2cf4:	d103      	bne.n	2cfe <Output_usbCodeSend_capability+0xe>
    2cf6:	28ff      	cmp	r0, #255	; 0xff
    2cf8:	d101      	bne.n	2cfe <Output_usbCodeSend_capability+0xe>
	{
		print("Output_usbCodeSend(usbCode)");
    2cfa:	4863      	ldr	r0, [pc, #396]	; (2e88 <Output_usbCodeSend_capability+0x198>)
    2cfc:	e0ab      	b.n	2e56 <Output_usbCodeSend_capability+0x166>
		return;
	}

	// Depending on which mode the keyboard is in the USB needs Press/Hold/Release events
	uint8_t keyPress = 0; // Default to key release, only used for NKRO
	switch ( USBKeys_Protocol )
    2cfe:	4c63      	ldr	r4, [pc, #396]	; (2e8c <Output_usbCodeSend_capability+0x19c>)
    2d00:	7823      	ldrb	r3, [r4, #0]
    2d02:	4625      	mov	r5, r4
    2d04:	f003 06ff 	and.w	r6, r3, #255	; 0xff
    2d08:	b113      	cbz	r3, 2d10 <Output_usbCodeSend_capability+0x20>
    2d0a:	2e01      	cmp	r6, #1
    2d0c:	d00b      	beq.n	2d26 <Output_usbCodeSend_capability+0x36>
    2d0e:	e012      	b.n	2d36 <Output_usbCodeSend_capability+0x46>
	{
	case 0: // Boot Mode
		// TODO Analog inputs
		// Only indicate USB has changed if either a press or release has occured
		if ( state == 0x01 || state == 0x03 )
    2d10:	f000 03fd 	and.w	r3, r0, #253	; 0xfd
    2d14:	2b01      	cmp	r3, #1
    2d16:	d10e      	bne.n	2d36 <Output_usbCodeSend_capability+0x46>
			USBKeys_Changed = USBKeyChangeState_MainKeys;
    2d18:	4b5d      	ldr	r3, [pc, #372]	; (2e90 <Output_usbCodeSend_capability+0x1a0>)
    2d1a:	2402      	movs	r4, #2
    2d1c:	701c      	strb	r4, [r3, #0]

		// Only send keypresses if press or hold state
		if ( stateType == 0x00 && state == 0x03 ) // Release state
    2d1e:	b951      	cbnz	r1, 2d36 <Output_usbCodeSend_capability+0x46>
    2d20:	2803      	cmp	r0, #3
    2d22:	d108      	bne.n	2d36 <Output_usbCodeSend_capability+0x46>
    2d24:	bd70      	pop	{r4, r5, r6, pc}
			return;
		break;
	case 1: // NKRO Mode
		// Only send press and release events
		if ( stateType == 0x00 && state == 0x02 ) // Hold state
    2d26:	b931      	cbnz	r1, 2d36 <Output_usbCodeSend_capability+0x46>
    2d28:	2802      	cmp	r0, #2
    2d2a:	f000 80ab 	beq.w	2e84 <Output_usbCodeSend_capability+0x194>
		print("Output_usbCodeSend(usbCode)");
		return;
	}

	// Depending on which mode the keyboard is in the USB needs Press/Hold/Release events
	uint8_t keyPress = 0; // Default to key release, only used for NKRO
    2d2e:	1e43      	subs	r3, r0, #1
    2d30:	4258      	negs	r0, r3
    2d32:	4158      	adcs	r0, r3
    2d34:	e000      	b.n	2d38 <Output_usbCodeSend_capability+0x48>
    2d36:	2000      	movs	r0, #0
	//  Bits  48 - 161 (bytes  6 - 20) correspond to USB Codes  51 - 164 (Secondary)
	//  Bits 168 - 213 (bytes 21 - 26) correspond to USB Codes 176 - 221 (Tertiary)
	//  Bits 214 - 216                 unused
	uint8_t bytePosition = 0;
	uint8_t byteShift = 0;
	switch ( USBKeys_Protocol )
    2d38:	782b      	ldrb	r3, [r5, #0]
			keyPress = 1;
		break;
	}

	// Get the keycode from arguments
	uint8_t key = args[0];
    2d3a:	7814      	ldrb	r4, [r2, #0]
	//  Bits  48 - 161 (bytes  6 - 20) correspond to USB Codes  51 - 164 (Secondary)
	//  Bits 168 - 213 (bytes 21 - 26) correspond to USB Codes 176 - 221 (Tertiary)
	//  Bits 214 - 216                 unused
	uint8_t bytePosition = 0;
	uint8_t byteShift = 0;
	switch ( USBKeys_Protocol )
    2d3c:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    2d40:	b113      	cbz	r3, 2d48 <Output_usbCodeSend_capability+0x58>
    2d42:	2d01      	cmp	r5, #1
    2d44:	d021      	beq.n	2d8a <Output_usbCodeSend_capability+0x9a>
    2d46:	bd70      	pop	{r4, r5, r6, pc}
	{
	case 0: // Boot Mode
		// Set the modifier bit if this key is a modifier
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    2d48:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    2d4c:	2be0      	cmp	r3, #224	; 0xe0
    2d4e:	d109      	bne.n	2d64 <Output_usbCodeSend_capability+0x74>
		{
			USBKeys_Modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    2d50:	4b50      	ldr	r3, [pc, #320]	; (2e94 <Output_usbCodeSend_capability+0x1a4>)
    2d52:	2201      	movs	r2, #1
    2d54:	f084 04e0 	eor.w	r4, r4, #224	; 0xe0
    2d58:	fa02 f404 	lsl.w	r4, r2, r4
    2d5c:	781a      	ldrb	r2, [r3, #0]
    2d5e:	4314      	orrs	r4, r2
    2d60:	701c      	strb	r4, [r3, #0]
    2d62:	bd70      	pop	{r4, r5, r6, pc}
		}
		// Normal USB Code
		else
		{
			// USB Key limit reached
			if ( USBKeys_Sent >= USB_BOOT_MAX_KEYS )
    2d64:	4a4c      	ldr	r2, [pc, #304]	; (2e98 <Output_usbCodeSend_capability+0x1a8>)
    2d66:	7813      	ldrb	r3, [r2, #0]
    2d68:	2b05      	cmp	r3, #5
    2d6a:	d901      	bls.n	2d70 <Output_usbCodeSend_capability+0x80>
			{
				warn_print("USB Key limit reached");
    2d6c:	484b      	ldr	r0, [pc, #300]	; (2e9c <Output_usbCodeSend_capability+0x1ac>)
    2d6e:	e072      	b.n	2e56 <Output_usbCodeSend_capability+0x166>
				return;
			}

			// Make sure key is within the USB HID range
			if ( key <= 104 )
    2d70:	2c68      	cmp	r4, #104	; 0x68
    2d72:	d804      	bhi.n	2d7e <Output_usbCodeSend_capability+0x8e>
			{
				USBKeys_Keys[USBKeys_Sent++] = key;
    2d74:	1c59      	adds	r1, r3, #1
    2d76:	7011      	strb	r1, [r2, #0]
    2d78:	4a49      	ldr	r2, [pc, #292]	; (2ea0 <Output_usbCodeSend_capability+0x1b0>)
    2d7a:	54d4      	strb	r4, [r2, r3]
    2d7c:	bd70      	pop	{r4, r5, r6, pc}
			}
			// Invalid key
			else
			{
				warn_msg("USB Code above 104/0x68 in Boot Mode: ");
    2d7e:	4849      	ldr	r0, [pc, #292]	; (2ea4 <Output_usbCodeSend_capability+0x1b4>)
    2d80:	f001 fbfe 	bl	4580 <_print>
				printHex( key );
    2d84:	4620      	mov	r0, r4
    2d86:	2101      	movs	r1, #1
    2d88:	e062      	b.n	2e50 <Output_usbCodeSend_capability+0x160>
		}
		break;

	case 1: // NKRO Mode
		// Set the modifier bit if this key is a modifier
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    2d8a:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    2d8e:	2be0      	cmp	r3, #224	; 0xe0
    2d90:	d111      	bne.n	2db6 <Output_usbCodeSend_capability+0xc6>
    2d92:	4b40      	ldr	r3, [pc, #256]	; (2e94 <Output_usbCodeSend_capability+0x1a4>)
    2d94:	f084 04e0 	eor.w	r4, r4, #224	; 0xe0
		{
			if ( keyPress )
			{
				USBKeys_Modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    2d98:	fa05 f404 	lsl.w	r4, r5, r4
    2d9c:	781a      	ldrb	r2, [r3, #0]

	case 1: // NKRO Mode
		// Set the modifier bit if this key is a modifier
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
		{
			if ( keyPress )
    2d9e:	b108      	cbz	r0, 2da4 <Output_usbCodeSend_capability+0xb4>
			{
				USBKeys_Modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    2da0:	4314      	orrs	r4, r2
    2da2:	e001      	b.n	2da8 <Output_usbCodeSend_capability+0xb8>
			}
			else // Release
			{
				USBKeys_Modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    2da4:	ea22 0404 	bic.w	r4, r2, r4
    2da8:	701c      	strb	r4, [r3, #0]
			}

			USBKeys_Changed |= USBKeyChangeState_Modifiers;
    2daa:	4b39      	ldr	r3, [pc, #228]	; (2e90 <Output_usbCodeSend_capability+0x1a0>)
    2dac:	781a      	ldrb	r2, [r3, #0]
    2dae:	f042 0201 	orr.w	r2, r2, #1
    2db2:	701a      	strb	r2, [r3, #0]
			break;
    2db4:	bd70      	pop	{r4, r5, r6, pc}
		}
		// First 6 bytes
		else if ( key >= 4 && key <= 49 )
    2db6:	1f23      	subs	r3, r4, #4
    2db8:	2b2d      	cmp	r3, #45	; 0x2d
    2dba:	d80f      	bhi.n	2ddc <Output_usbCodeSend_capability+0xec>
    2dbc:	3c05      	subs	r4, #5
    2dbe:	b2e4      	uxtb	r4, r4
    2dc0:	2c2e      	cmp	r4, #46	; 0x2e
    2dc2:	d804      	bhi.n	2dce <Output_usbCodeSend_capability+0xde>
    2dc4:	4b38      	ldr	r3, [pc, #224]	; (2ea8 <Output_usbCodeSend_capability+0x1b8>)
    2dc6:	4a39      	ldr	r2, [pc, #228]	; (2eac <Output_usbCodeSend_capability+0x1bc>)
    2dc8:	5d1b      	ldrb	r3, [r3, r4]
    2dca:	5d12      	ldrb	r2, [r2, r4]
    2dcc:	e001      	b.n	2dd2 <Output_usbCodeSend_capability+0xe2>
    2dce:	2200      	movs	r2, #0
    2dd0:	4613      	mov	r3, r2
				byteLookup( 3 );
				byteLookup( 4 );
				byteLookup( 5 );
			}

			USBKeys_Changed |= USBKeyChangeState_MainKeys;
    2dd2:	492f      	ldr	r1, [pc, #188]	; (2e90 <Output_usbCodeSend_capability+0x1a0>)
    2dd4:	780c      	ldrb	r4, [r1, #0]
    2dd6:	f044 0402 	orr.w	r4, r4, #2
    2dda:	e00c      	b.n	2df6 <Output_usbCodeSend_capability+0x106>
		}
		// Next 14 bytes
		else if ( key >= 51 && key <= 155 )
    2ddc:	f1a4 0233 	sub.w	r2, r4, #51	; 0x33
    2de0:	b2d2      	uxtb	r2, r2
    2de2:	2a68      	cmp	r2, #104	; 0x68
    2de4:	d809      	bhi.n	2dfa <Output_usbCodeSend_capability+0x10a>
    2de6:	4932      	ldr	r1, [pc, #200]	; (2eb0 <Output_usbCodeSend_capability+0x1c0>)
    2de8:	4b32      	ldr	r3, [pc, #200]	; (2eb4 <Output_usbCodeSend_capability+0x1c4>)
    2dea:	5c9b      	ldrb	r3, [r3, r2]
    2dec:	5c8a      	ldrb	r2, [r1, r2]
				byteLookup( 17 );
				byteLookup( 18 );
				byteLookup( 19 );
			}

			USBKeys_Changed |= USBKeyChangeState_SecondaryKeys;
    2dee:	4928      	ldr	r1, [pc, #160]	; (2e90 <Output_usbCodeSend_capability+0x1a0>)
    2df0:	780c      	ldrb	r4, [r1, #0]
    2df2:	f044 0404 	orr.w	r4, r4, #4
    2df6:	700c      	strb	r4, [r1, #0]
    2df8:	e031      	b.n	2e5e <Output_usbCodeSend_capability+0x16e>
		}
		// Next byte
		else if ( key >= 157 && key <= 164 )
    2dfa:	f104 0363 	add.w	r3, r4, #99	; 0x63
    2dfe:	b2db      	uxtb	r3, r3
    2e00:	2b07      	cmp	r3, #7
    2e02:	d808      	bhi.n	2e16 <Output_usbCodeSend_capability+0x126>
    2e04:	4a2c      	ldr	r2, [pc, #176]	; (2eb8 <Output_usbCodeSend_capability+0x1c8>)
    2e06:	5cd2      	ldrb	r2, [r2, r3]
			switch ( keyPos )
			{
				byteLookup( 20 );
			}

			USBKeys_Changed |= USBKeyChangeState_TertiaryKeys;
    2e08:	4b21      	ldr	r3, [pc, #132]	; (2e90 <Output_usbCodeSend_capability+0x1a0>)
    2e0a:	7819      	ldrb	r1, [r3, #0]
    2e0c:	f041 0108 	orr.w	r1, r1, #8
    2e10:	7019      	strb	r1, [r3, #0]
    2e12:	2314      	movs	r3, #20
    2e14:	e023      	b.n	2e5e <Output_usbCodeSend_capability+0x16e>
		}
		// Last 6 bytes
		else if ( key >= 176 && key <= 221 )
    2e16:	f104 0250 	add.w	r2, r4, #80	; 0x50
    2e1a:	b2d2      	uxtb	r2, r2
    2e1c:	2a2d      	cmp	r2, #45	; 0x2d
    2e1e:	d808      	bhi.n	2e32 <Output_usbCodeSend_capability+0x142>
    2e20:	4926      	ldr	r1, [pc, #152]	; (2ebc <Output_usbCodeSend_capability+0x1cc>)
    2e22:	4b27      	ldr	r3, [pc, #156]	; (2ec0 <Output_usbCodeSend_capability+0x1d0>)
    2e24:	5c9b      	ldrb	r3, [r3, r2]
    2e26:	5c8a      	ldrb	r2, [r1, r2]
				byteLookup( 24 );
				byteLookup( 25 );
				byteLookup( 26 );
			}

			USBKeys_Changed |= USBKeyChangeState_QuartiaryKeys;
    2e28:	4919      	ldr	r1, [pc, #100]	; (2e90 <Output_usbCodeSend_capability+0x1a0>)
    2e2a:	780c      	ldrb	r4, [r1, #0]
    2e2c:	f044 0410 	orr.w	r4, r4, #16
    2e30:	e7e1      	b.n	2df6 <Output_usbCodeSend_capability+0x106>
		}
		// Received 0x00
		// This is a special USB Code that internally indicates a "break"
		// It is used to send "nothing" in order to break up sequences of USB Codes
		else if ( key == 0x00 )
    2e32:	b944      	cbnz	r4, 2e46 <Output_usbCodeSend_capability+0x156>
		{
			USBKeys_Changed |= USBKeyChangeState_MainKeys;
    2e34:	4b16      	ldr	r3, [pc, #88]	; (2e90 <Output_usbCodeSend_capability+0x1a0>)
    2e36:	781a      	ldrb	r2, [r3, #0]
			USBKeys_Sent++;
		}

		break;
	}
}
    2e38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		// Received 0x00
		// This is a special USB Code that internally indicates a "break"
		// It is used to send "nothing" in order to break up sequences of USB Codes
		else if ( key == 0x00 )
		{
			USBKeys_Changed |= USBKeyChangeState_MainKeys;
    2e3c:	f042 0202 	orr.w	r2, r2, #2
    2e40:	701a      	strb	r2, [r3, #0]

			// Also flush out buffers just in case
			Output_flushBuffers();
    2e42:	f7ff bf0d 	b.w	2c60 <Output_flushBuffers>
			break;
		}
		// Invalid key
		else
		{
			warn_msg("USB Code not within 4-49 (0x4-0x31), 51-155 (0x33-0x9B), 157-164 (0x9D-0xA4), 176-221 (0xB0-0xDD) or 224-231 (0xE0-0xE7) NKRO Mode: ");
    2e46:	481f      	ldr	r0, [pc, #124]	; (2ec4 <Output_usbCodeSend_capability+0x1d4>)
    2e48:	f001 fb9a 	bl	4580 <_print>
			printHex( key );
    2e4c:	4620      	mov	r0, r4
    2e4e:	4629      	mov	r1, r5
    2e50:	f001 fc1f 	bl	4692 <printHex_op>
			print( NL );
    2e54:	481c      	ldr	r0, [pc, #112]	; (2ec8 <Output_usbCodeSend_capability+0x1d8>)
			USBKeys_Sent++;
		}

		break;
	}
}
    2e56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		// Invalid key
		else
		{
			warn_msg("USB Code not within 4-49 (0x4-0x31), 51-155 (0x33-0x9B), 157-164 (0x9D-0xA4), 176-221 (0xB0-0xDD) or 224-231 (0xE0-0xE7) NKRO Mode: ");
			printHex( key );
			print( NL );
    2e5a:	f001 bb91 	b.w	4580 <_print>
    2e5e:	2501      	movs	r5, #1
    2e60:	490d      	ldr	r1, [pc, #52]	; (2e98 <Output_usbCodeSend_capability+0x1a8>)
    2e62:	4c0f      	ldr	r4, [pc, #60]	; (2ea0 <Output_usbCodeSend_capability+0x1b0>)
		}

		// Set/Unset
		if ( keyPress )
		{
			USBKeys_Keys[bytePosition] |= (1 << byteShift);
    2e64:	fa05 f202 	lsl.w	r2, r5, r2
			print( NL );
			break;
		}

		// Set/Unset
		if ( keyPress )
    2e68:	b128      	cbz	r0, 2e76 <Output_usbCodeSend_capability+0x186>
		{
			USBKeys_Keys[bytePosition] |= (1 << byteShift);
    2e6a:	5ce0      	ldrb	r0, [r4, r3]
    2e6c:	4302      	orrs	r2, r0
    2e6e:	54e2      	strb	r2, [r4, r3]
			USBKeys_Sent++;
    2e70:	780b      	ldrb	r3, [r1, #0]
    2e72:	442b      	add	r3, r5
    2e74:	e005      	b.n	2e82 <Output_usbCodeSend_capability+0x192>
		}
		else // Release
		{
			USBKeys_Keys[bytePosition] &= ~(1 << byteShift);
    2e76:	5ce0      	ldrb	r0, [r4, r3]
    2e78:	ea20 0202 	bic.w	r2, r0, r2
    2e7c:	54e2      	strb	r2, [r4, r3]
			USBKeys_Sent++;
    2e7e:	780b      	ldrb	r3, [r1, #0]
    2e80:	3301      	adds	r3, #1
    2e82:	700b      	strb	r3, [r1, #0]
    2e84:	bd70      	pop	{r4, r5, r6, pc}
    2e86:	bf00      	nop
    2e88:	000067a5 	.word	0x000067a5
    2e8c:	1fffeb81 	.word	0x1fffeb81
    2e90:	1ffff179 	.word	0x1ffff179
    2e94:	1ffff178 	.word	0x1ffff178
    2e98:	1ffff17c 	.word	0x1ffff17c
    2e9c:	000067c1 	.word	0x000067c1
    2ea0:	1ffffc03 	.word	0x1ffffc03
    2ea4:	000067ee 	.word	0x000067ee
    2ea8:	000064f5 	.word	0x000064f5
    2eac:	00006957 	.word	0x00006957
    2eb0:	000069f6 	.word	0x000069f6
    2eb4:	00006986 	.word	0x00006986
    2eb8:	00006a66 	.word	0x00006a66
    2ebc:	00006428 	.word	0x00006428
    2ec0:	00006524 	.word	0x00006524
    2ec4:	0000682a 	.word	0x0000682a
    2ec8:	00006caf 	.word	0x00006caf

00002ecc <Output_setup>:
}


// USB Module Setup
inline void Output_setup()
{
    2ecc:	b508      	push	{r3, lr}
	// Initialize the USB
	// If a USB connection does not exist, just ignore it
	// All usb related functions will non-fatally fail if called
	// If the USB initialization is delayed, then functionality will just be delayed
	usb_init();
    2ece:	f000 fccb 	bl	3868 <usb_init>

	// Register USB Output CLI dictionary
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    2ed2:	4804      	ldr	r0, [pc, #16]	; (2ee4 <Output_setup+0x18>)
    2ed4:	4904      	ldr	r1, [pc, #16]	; (2ee8 <Output_setup+0x1c>)
    2ed6:	f001 f913 	bl	4100 <CLI_registerDictionary>

	// Flush key buffers
	Output_flushBuffers();
}
    2eda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	// Register USB Output CLI dictionary
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );

	// Flush key buffers
	Output_flushBuffers();
    2ede:	f7ff bebf 	b.w	2c60 <Output_flushBuffers>
    2ee2:	bf00      	nop
    2ee4:	00006554 	.word	0x00006554
    2ee8:	000064e1 	.word	0x000064e1

00002eec <Output_send>:
}


// USB Data Send
inline void Output_send()
{
    2eec:	b510      	push	{r4, lr}
	// Boot Mode Only, unset stale keys
	if ( USBKeys_Protocol == 0 )
    2eee:	4b12      	ldr	r3, [pc, #72]	; (2f38 <Output_send+0x4c>)
    2ef0:	781a      	ldrb	r2, [r3, #0]
    2ef2:	461c      	mov	r4, r3
    2ef4:	b94a      	cbnz	r2, 2f0a <Output_send+0x1e>
		for ( uint8_t c = USBKeys_Sent; c < USB_BOOT_MAX_KEYS; c++ )
    2ef6:	4b11      	ldr	r3, [pc, #68]	; (2f3c <Output_send+0x50>)
    2ef8:	781b      	ldrb	r3, [r3, #0]
    2efa:	2b05      	cmp	r3, #5
    2efc:	d805      	bhi.n	2f0a <Output_send+0x1e>
			USBKeys_Keys[c] = 0;
    2efe:	4a10      	ldr	r2, [pc, #64]	; (2f40 <Output_send+0x54>)
    2f00:	2100      	movs	r1, #0
    2f02:	54d1      	strb	r1, [r2, r3]
// USB Data Send
inline void Output_send()
{
	// Boot Mode Only, unset stale keys
	if ( USBKeys_Protocol == 0 )
		for ( uint8_t c = USBKeys_Sent; c < USB_BOOT_MAX_KEYS; c++ )
    2f04:	3301      	adds	r3, #1
    2f06:	b2db      	uxtb	r3, r3
    2f08:	e7f7      	b.n	2efa <Output_send+0xe>
			USBKeys_Keys[c] = 0;

	// Send keypresses while there are pending changes
	while ( USBKeys_Changed )
    2f0a:	4b0e      	ldr	r3, [pc, #56]	; (2f44 <Output_send+0x58>)
    2f0c:	781b      	ldrb	r3, [r3, #0]
    2f0e:	b113      	cbz	r3, 2f16 <Output_send+0x2a>
		usb_keyboard_send();
    2f10:	f000 fcf8 	bl	3904 <usb_keyboard_send>
    2f14:	e7f9      	b.n	2f0a <Output_send+0x1e>

	// Clear keys sent
	USBKeys_Sent = 0;
    2f16:	4a09      	ldr	r2, [pc, #36]	; (2f3c <Output_send+0x50>)
    2f18:	7013      	strb	r3, [r2, #0]

	// Signal Scan Module we are finished
	switch ( USBKeys_Protocol )
    2f1a:	7822      	ldrb	r2, [r4, #0]
    2f1c:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    2f20:	b112      	cbz	r2, 2f28 <Output_send+0x3c>
    2f22:	2801      	cmp	r0, #1
    2f24:	d003      	beq.n	2f2e <Output_send+0x42>
    2f26:	bd10      	pop	{r4, pc}
	{
	case 0: // Boot Mode
		// Clear modifiers only in boot mode
		USBKeys_Modifiers = 0;
    2f28:	4b07      	ldr	r3, [pc, #28]	; (2f48 <Output_send+0x5c>)
    2f2a:	7018      	strb	r0, [r3, #0]
    2f2c:	e000      	b.n	2f30 <Output_send+0x44>
		Scan_finishedWithOutput( USBKeys_Sent <= USB_BOOT_MAX_KEYS ? USBKeys_Sent : USB_BOOT_MAX_KEYS );
		break;
	case 1: // NKRO Mode
		Scan_finishedWithOutput( USBKeys_Sent );
    2f2e:	4618      	mov	r0, r3
		break;
	}
}
    2f30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		// Clear modifiers only in boot mode
		USBKeys_Modifiers = 0;
		Scan_finishedWithOutput( USBKeys_Sent <= USB_BOOT_MAX_KEYS ? USBKeys_Sent : USB_BOOT_MAX_KEYS );
		break;
	case 1: // NKRO Mode
		Scan_finishedWithOutput( USBKeys_Sent );
    2f34:	f7fe bcb8 	b.w	18a8 <Scan_finishedWithOutput>
    2f38:	1fffeb81 	.word	0x1fffeb81
    2f3c:	1ffff17c 	.word	0x1ffff17c
    2f40:	1ffffc03 	.word	0x1ffffc03
    2f44:	1ffff179 	.word	0x1ffff179
    2f48:	1ffff178 	.word	0x1ffff178

00002f4c <Output_availablechar>:


// USB Input buffer available
inline unsigned int Output_availablechar()
{
	return usb_serial_available();
    2f4c:	f000 bea2 	b.w	3c94 <usb_serial_available>

00002f50 <Output_getchar>:

// USB Get Character from input buffer
inline int Output_getchar()
{
	// XXX Make sure to check output_availablechar() first! Information is lost with the cast (error codes) (AVR)
	return (int)usb_serial_getchar();
    2f50:	f000 be7a 	b.w	3c48 <usb_serial_getchar>

00002f54 <Output_putstr>:
inline int Output_putstr( char* str )
{
#if defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_) // AVR
	uint16_t count = 0;
#elif defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_) // ARM
	uint32_t count = 0;
    2f54:	2100      	movs	r1, #0
#endif
	// Count characters until NULL character, then send the amount counted
	while ( str[count] != '\0' )
    2f56:	5c43      	ldrb	r3, [r0, r1]
    2f58:	b10b      	cbz	r3, 2f5e <Output_putstr+0xa>
		count++;
    2f5a:	3101      	adds	r1, #1
    2f5c:	e7fb      	b.n	2f56 <Output_putstr+0x2>

	return usb_serial_write( str, count );
    2f5e:	f000 bea7 	b.w	3cb0 <usb_serial_write>
    2f62:	0000      	movs	r0, r0

00002f64 <Output_softReset>:


// Soft Chip Reset
inline void Output_softReset()
{
	usb_device_software_reset();
    2f64:	4b01      	ldr	r3, [pc, #4]	; (2f6c <Output_softReset+0x8>)
    2f66:	4a02      	ldr	r2, [pc, #8]	; (2f70 <Output_softReset+0xc>)
    2f68:	601a      	str	r2, [r3, #0]
    2f6a:	4770      	bx	lr
    2f6c:	e000ed0c 	.word	0xe000ed0c
    2f70:	05fa0004 	.word	0x05fa0004

00002f74 <endpoint0_transmit>:
	#endif
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
    2f74:	b5f0      	push	{r4, r5, r6, r7, lr}
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2f76:	4b0c      	ldr	r3, [pc, #48]	; (2fa8 <endpoint0_transmit+0x34>)
    2f78:	4c0c      	ldr	r4, [pc, #48]	; (2fac <endpoint0_transmit+0x38>)
    2f7a:	781a      	ldrb	r2, [r3, #0]
    2f7c:	f042 0502 	orr.w	r5, r2, #2
    2f80:	eb04 06c5 	add.w	r6, r4, r5, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2f84:	f082 0201 	eor.w	r2, r2, #1
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2f88:	6070      	str	r0, [r6, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2f8a:	4809      	ldr	r0, [pc, #36]	; (2fb0 <endpoint0_transmit+0x3c>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2f8c:	701a      	strb	r2, [r3, #0]
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2f8e:	7806      	ldrb	r6, [r0, #0]
    2f90:	2e00      	cmp	r6, #0
    2f92:	bf0c      	ite	eq
    2f94:	2788      	moveq	r7, #136	; 0x88
    2f96:	27c8      	movne	r7, #200	; 0xc8
	ep0_tx_data_toggle ^= 1;
    2f98:	f086 0601 	eor.w	r6, r6, #1
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2f9c:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    2fa0:	7006      	strb	r6, [r0, #0]
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2fa2:	f844 1035 	str.w	r1, [r4, r5, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2fa6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2fa8:	1ffff210 	.word	0x1ffff210
    2fac:	1fffe000 	.word	0x1fffe000
    2fb0:	1ffff2a8 	.word	0x1ffff2a8

00002fb4 <usb_rx>:

usb_packet_t *usb_rx( uint32_t endpoint )
{
	//print("USB RX");
	usb_packet_t *ret;
	endpoint--;
    2fb4:	1e43      	subs	r3, r0, #1
	if ( endpoint >= NUM_ENDPOINTS )
    2fb6:	2b07      	cmp	r3, #7
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
}

usb_packet_t *usb_rx( uint32_t endpoint )
{
    2fb8:	b510      	push	{r4, lr}
	//print("USB RX");
	usb_packet_t *ret;
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
    2fba:	d810      	bhi.n	2fde <usb_rx+0x2a>
		return NULL;
	__disable_irq();
    2fbc:	b672      	cpsid	i
	ret = rx_first[endpoint];
    2fbe:	4a09      	ldr	r2, [pc, #36]	; (2fe4 <usb_rx+0x30>)
    2fc0:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
	if ( ret )
    2fc4:	b110      	cbz	r0, 2fcc <usb_rx+0x18>
		rx_first[ endpoint ] = ret->next;
    2fc6:	6841      	ldr	r1, [r0, #4]
    2fc8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	usb_rx_byte_count_data[ endpoint ] -= ret->len;
    2fcc:	4a06      	ldr	r2, [pc, #24]	; (2fe8 <usb_rx+0x34>)
    2fce:	8801      	ldrh	r1, [r0, #0]
    2fd0:	f832 4013 	ldrh.w	r4, [r2, r3, lsl #1]
    2fd4:	1a61      	subs	r1, r4, r1
    2fd6:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	__enable_irq();
    2fda:	b662      	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    2fdc:	bd10      	pop	{r4, pc}
{
	//print("USB RX");
	usb_packet_t *ret;
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return NULL;
    2fde:	2000      	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    2fe0:	bd10      	pop	{r4, pc}
    2fe2:	bf00      	nop
    2fe4:	1ffff1f0 	.word	0x1ffff1f0
    2fe8:	1ffffc3c 	.word	0x1ffffc3c

00002fec <usb_tx_packet_count>:
uint32_t usb_tx_packet_count( uint32_t endpoint )
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    2fec:	3801      	subs	r0, #1
	if ( endpoint >= NUM_ENDPOINTS )
    2fee:	2807      	cmp	r0, #7
    2ff0:	d80a      	bhi.n	3008 <usb_tx_packet_count+0x1c>
		return 0;
	__disable_irq();
    2ff2:	b672      	cpsid	i
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    2ff4:	4b05      	ldr	r3, [pc, #20]	; (300c <usb_tx_packet_count+0x20>)
    2ff6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
}

uint32_t usb_tx_packet_count( uint32_t endpoint )
{
	const usb_packet_t *p;
	uint32_t count=0;
    2ffa:	2000      	movs	r0, #0

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
	__disable_irq();
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    2ffc:	b113      	cbz	r3, 3004 <usb_tx_packet_count+0x18>
		count++;
    2ffe:	3001      	adds	r0, #1

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
	__disable_irq();
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    3000:	685b      	ldr	r3, [r3, #4]
    3002:	e7fb      	b.n	2ffc <usb_tx_packet_count+0x10>
		count++;
	__enable_irq();
    3004:	b662      	cpsie	i
	return count;
    3006:	4770      	bx	lr
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
    3008:	2000      	movs	r0, #0
	__disable_irq();
	for ( p = tx_first[ endpoint ]; p; p = p->next )
		count++;
	__enable_irq();
	return count;
}
    300a:	4770      	bx	lr
    300c:	1ffff254 	.word	0x1ffff254

00003010 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory( usb_packet_t *packet )
{
    3010:	b510      	push	{r4, lr}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    3012:	b672      	cpsid	i
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    3014:	2301      	movs	r3, #1
    3016:	4a17      	ldr	r2, [pc, #92]	; (3074 <usb_rx_memory+0x64>)
    3018:	441a      	add	r2, r3
	{
		if ( *cfg++ & USB_ENDPT_EPRXEN )
    301a:	f812 2c01 	ldrb.w	r2, [r2, #-1]
    301e:	0712      	lsls	r2, r2, #28
    3020:	d51c      	bpl.n	305c <usb_rx_memory+0x4c>
		{
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    3022:	0099      	lsls	r1, r3, #2
    3024:	4a14      	ldr	r2, [pc, #80]	; (3078 <usb_rx_memory+0x68>)
    3026:	f852 4031 	ldr.w	r4, [r2, r1, lsl #3]
    302a:	b92c      	cbnz	r4, 3038 <usb_rx_memory+0x28>
			{
				table[ index( i, RX, EVEN ) ].addr = packet->buf;
    302c:	eb02 1343 	add.w	r3, r2, r3, lsl #5
    3030:	3008      	adds	r0, #8
    3032:	6058      	str	r0, [r3, #4]
				table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    3034:	4b11      	ldr	r3, [pc, #68]	; (307c <usb_rx_memory+0x6c>)
    3036:	e009      	b.n	304c <usb_rx_memory+0x3c>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
    3038:	f041 0101 	orr.w	r1, r1, #1
    303c:	f852 4031 	ldr.w	r4, [r2, r1, lsl #3]
    3040:	b964      	cbnz	r4, 305c <usb_rx_memory+0x4c>
			{
				table[ index( i, RX, ODD ) ].addr = packet->buf;
    3042:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
    3046:	3008      	adds	r0, #8
    3048:	6058      	str	r0, [r3, #4]
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    304a:	4b0d      	ldr	r3, [pc, #52]	; (3080 <usb_rx_memory+0x70>)
    304c:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
				usb_rx_memory_needed--;
    3050:	4b0c      	ldr	r3, [pc, #48]	; (3084 <usb_rx_memory+0x74>)
    3052:	781a      	ldrb	r2, [r3, #0]
    3054:	3a01      	subs	r2, #1
    3056:	701a      	strb	r2, [r3, #0]
				__enable_irq();
    3058:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",odd\n");
				return;
    305a:	bd10      	pop	{r4, pc}
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    305c:	3301      	adds	r3, #1
    305e:	2b09      	cmp	r3, #9
    3060:	d1d9      	bne.n	3016 <usb_rx_memory+0x6>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    3062:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    3064:	4b07      	ldr	r3, [pc, #28]	; (3084 <usb_rx_memory+0x74>)
    3066:	2200      	movs	r2, #0
    3068:	701a      	strb	r2, [r3, #0]
	usb_free( packet );
	return;
}
    306a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free( packet );
    306e:	f000 bdc9 	b.w	3c04 <usb_free>
    3072:	bf00      	nop
    3074:	00006a6e 	.word	0x00006a6e
    3078:	1fffe000 	.word	0x1fffe000
    307c:	00400088 	.word	0x00400088
    3080:	004000c8 	.word	0x004000c8
    3084:	1ffff29e 	.word	0x1ffff29e

00003088 <usb_tx>:
void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
	uint8_t next;

	endpoint--;
    3088:	1e43      	subs	r3, r0, #1
	if ( endpoint >= NUM_ENDPOINTS )
    308a:	2b07      	cmp	r3, #7

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
    308c:	b530      	push	{r4, r5, lr}
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
	uint8_t next;

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
    308e:	d832      	bhi.n	30f6 <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
    3090:	4a19      	ldr	r2, [pc, #100]	; (30f8 <usb_tx+0x70>)
    3092:	0140      	lsls	r0, r0, #5
    3094:	f040 0010 	orr.w	r0, r0, #16
    3098:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return;
	__disable_irq();
    309a:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[ endpoint ]);
	//serial_print("\n");
	switch ( tx_state[ endpoint ] )
    309c:	4c17      	ldr	r4, [pc, #92]	; (30fc <usb_tx+0x74>)
    309e:	5ce2      	ldrb	r2, [r4, r3]
    30a0:	2a03      	cmp	r2, #3
    30a2:	d809      	bhi.n	30b8 <usb_tx+0x30>
    30a4:	e8df f002 	tbb	[pc, r2]
    30a8:	05180216 	.word	0x05180216
	{
	case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    30ac:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    30ae:	2202      	movs	r2, #2
		break;
    30b0:	e013      	b.n	30da <usb_tx+0x52>
	case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	case TX_STATE_ODD_FREE:
		b++;
    30b2:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    30b4:	2204      	movs	r2, #4
		break;
    30b6:	e010      	b.n	30da <usb_tx+0x52>
	default:
		if (tx_first[ endpoint ] == NULL)
    30b8:	4811      	ldr	r0, [pc, #68]	; (3100 <usb_tx+0x78>)
    30ba:	4a12      	ldr	r2, [pc, #72]	; (3104 <usb_tx+0x7c>)
    30bc:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    30c0:	b914      	cbnz	r4, 30c8 <usb_tx+0x40>
		{
			tx_first[ endpoint ] = packet;
    30c2:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
    30c6:	e002      	b.n	30ce <usb_tx+0x46>
		}
		else
		{
			tx_last[ endpoint ]->next = packet;
    30c8:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    30cc:	6041      	str	r1, [r0, #4]
		}
		tx_last[ endpoint ] = packet;
    30ce:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    30d2:	e00f      	b.n	30f4 <usb_tx+0x6c>
	//serial_phex(tx_state[ endpoint ]);
	//serial_print("\n");
	switch ( tx_state[ endpoint ] )
	{
	case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    30d4:	2203      	movs	r2, #3
    30d6:	e000      	b.n	30da <usb_tx+0x52>
	case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    30d8:	2205      	movs	r2, #5
		tx_last[ endpoint ] = packet;
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
    30da:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    30dc:	f010 0f08 	tst.w	r0, #8
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
	b->addr = packet->buf;
    30e0:	f101 0308 	add.w	r3, r1, #8
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    30e4:	880a      	ldrh	r2, [r1, #0]
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
	b->addr = packet->buf;
    30e6:	6043      	str	r3, [r0, #4]
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    30e8:	bf0c      	ite	eq
    30ea:	2388      	moveq	r3, #136	; 0x88
    30ec:	23c8      	movne	r3, #200	; 0xc8
    30ee:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    30f2:	6003      	str	r3, [r0, #0]
	__enable_irq();
    30f4:	b662      	cpsie	i
    30f6:	bd30      	pop	{r4, r5, pc}
    30f8:	1fffe000 	.word	0x1fffe000
    30fc:	1ffff1a8 	.word	0x1ffff1a8
    3100:	1ffff254 	.word	0x1ffff254
    3104:	1ffff274 	.word	0x1ffff274

00003108 <usb_device_reload>:
}


void usb_device_reload()
{
    3108:	4b05      	ldr	r3, [pc, #20]	; (3120 <usb_device_reload+0x18>)
// MCHCK
// Kiibohd mk20dx256vlh7
#if defined(_mk20dx128vlf5_) || defined(_mk20dx256vlh7_)
	// Copies variable into the VBAT register, must be identical to the variable in the bootloader to jump to the bootloader flash mode
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    310a:	4a06      	ldr	r2, [pc, #24]	; (3124 <usb_device_reload+0x1c>)
    310c:	5c9a      	ldrb	r2, [r3, r2]
    310e:	f803 2b01 	strb.w	r2, [r3], #1
{
// MCHCK
// Kiibohd mk20dx256vlh7
#if defined(_mk20dx128vlf5_) || defined(_mk20dx256vlh7_)
	// Copies variable into the VBAT register, must be identical to the variable in the bootloader to jump to the bootloader flash mode
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    3112:	4a05      	ldr	r2, [pc, #20]	; (3128 <usb_device_reload+0x20>)
    3114:	4293      	cmp	r3, r2
    3116:	d1f8      	bne.n	310a <usb_device_reload+0x2>
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
	SOFTWARE_RESET();
    3118:	4b04      	ldr	r3, [pc, #16]	; (312c <usb_device_reload+0x24>)
    311a:	4a05      	ldr	r2, [pc, #20]	; (3130 <usb_device_reload+0x28>)
    311c:	601a      	str	r2, [r3, #0]
    311e:	4770      	bx	lr
    3120:	4003e000 	.word	0x4003e000
    3124:	bffc6854 	.word	0xbffc6854
    3128:	4003e016 	.word	0x4003e016
    312c:	e000ed0c 	.word	0xe000ed0c
    3130:	05fa0004 	.word	0x05fa0004

00003134 <usb_isr>:
#endif
}


void usb_isr()
{
    3134:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
restart:
	status = USB0_ISTAT;
    3138:	4eb2      	ldr	r6, [pc, #712]	; (3404 <usb_isr+0x2d0>)
    313a:	7834      	ldrb	r4, [r6, #0]
    313c:	b2e4      	uxtb	r4, r4
	print("USB ISR STATUS: ");
	printHex( status );
	print( NL );
	*/

	if ( (status & USB_INTEN_SOFTOKEN /* 04 */ ) )
    313e:	f014 0f04 	tst.w	r4, #4
    3142:	4635      	mov	r5, r6
    3144:	d01a      	beq.n	317c <usb_isr+0x48>
	{
		if ( usb_configuration )
    3146:	4bb0      	ldr	r3, [pc, #704]	; (3408 <usb_isr+0x2d4>)
    3148:	781b      	ldrb	r3, [r3, #0]
    314a:	b1ab      	cbz	r3, 3178 <usb_isr+0x44>
		{
			t = usb_reboot_timer;
    314c:	4aaf      	ldr	r2, [pc, #700]	; (340c <usb_isr+0x2d8>)
    314e:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    3150:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    3154:	b129      	cbz	r1, 3162 <usb_isr+0x2e>
			{
				usb_reboot_timer = --t;
    3156:	3b01      	subs	r3, #1
    3158:	b2db      	uxtb	r3, r3
    315a:	7013      	strb	r3, [r2, #0]
				if ( !t )
    315c:	b90b      	cbnz	r3, 3162 <usb_isr+0x2e>
					usb_device_reload();
    315e:	f7ff ffd3 	bl	3108 <usb_device_reload>
			}

			// CDC Interface
			t = usb_cdc_transmit_flush_timer;
    3162:	4aab      	ldr	r2, [pc, #684]	; (3410 <usb_isr+0x2dc>)
    3164:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    3166:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    316a:	b129      	cbz	r1, 3178 <usb_isr+0x44>
			{
				usb_cdc_transmit_flush_timer = --t;
    316c:	3b01      	subs	r3, #1
    316e:	b2db      	uxtb	r3, r3
    3170:	7013      	strb	r3, [r2, #0]
				if ( t == 0 )
    3172:	b90b      	cbnz	r3, 3178 <usb_isr+0x44>
					usb_serial_flush_callback();
    3174:	f000 fe04 	bl	3d80 <usb_serial_flush_callback>
			}

		}
		USB0_ISTAT = USB_INTEN_SOFTOKEN;
    3178:	2304      	movs	r3, #4
    317a:	7033      	strb	r3, [r6, #0]
	}

	if ( (status & USB_ISTAT_TOKDNE /* 08 */ ) )
    317c:	f004 0308 	and.w	r3, r4, #8
    3180:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    3184:	2b00      	cmp	r3, #0
    3186:	f000 831a 	beq.w	37be <usb_isr+0x68a>
	{
		uint8_t endpoint;
		stat = USB0_STAT;
    318a:	4ba2      	ldr	r3, [pc, #648]	; (3414 <usb_isr+0x2e0>)
    318c:	4ca2      	ldr	r4, [pc, #648]	; (3418 <usb_isr+0x2e4>)
    318e:	781a      	ldrb	r2, [r3, #0]
    3190:	b2d2      	uxtb	r2, r2
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if ( endpoint == 0 )
    3192:	0915      	lsrs	r5, r2, #4
    3194:	ea4f 0892 	mov.w	r8, r2, lsr #2
    3198:	f040 8270 	bne.w	367c <usb_isr+0x548>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor( stat );
    319c:	eb04 03c8 	add.w	r3, r4, r8, lsl #3
	pid = BDT_PID( b->desc );
	buf = b->addr;
    31a0:	685a      	ldr	r2, [r3, #4]
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor( stat );
	pid = BDT_PID( b->desc );
    31a2:	f854 3038 	ldr.w	r3, [r4, r8, lsl #3]
    31a6:	f3c3 0383 	ubfx	r3, r3, #2, #4
	print(", count:");
	printHex32(b->desc);
	print(" - ");
	#endif

	switch (pid)
    31aa:	3b01      	subs	r3, #1
    31ac:	2b0c      	cmp	r3, #12
    31ae:	f200 8262 	bhi.w	3676 <usb_isr+0x542>
    31b2:	e8df f013 	tbh	[pc, r3, lsl #1]
    31b6:	0204      	.short	0x0204
    31b8:	02600204 	.word	0x02600204
    31bc:	02600260 	.word	0x02600260
    31c0:	02600260 	.word	0x02600260
    31c4:	023c0260 	.word	0x023c0260
    31c8:	02600260 	.word	0x02600260
    31cc:	000d0260 	.word	0x000d0260
	{
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    31d0:	4d92      	ldr	r5, [pc, #584]	; (341c <usb_isr+0x2e8>)
    31d2:	6813      	ldr	r3, [r2, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    31d4:	6852      	ldr	r2, [r2, #4]
    31d6:	606a      	str	r2, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    31d8:	4a91      	ldr	r2, [pc, #580]	; (3420 <usb_isr+0x2ec>)
    31da:	f844 2038 	str.w	r2, [r4, r8, lsl #3]
	{
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    31de:	602b      	str	r3, [r5, #0]
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    31e0:	4f90      	ldr	r7, [pc, #576]	; (3424 <usb_isr+0x2f0>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    31e2:	4a91      	ldr	r2, [pc, #580]	; (3428 <usb_isr+0x2f4>)
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    31e4:	b29b      	uxth	r3, r3
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    31e6:	2100      	movs	r1, #0
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    31e8:	f04f 0801 	mov.w	r8, #1
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    31ec:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    31f0:	6039      	str	r1, [r7, #0]
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    31f2:	6121      	str	r1, [r4, #16]
		table[index(0, TX, ODD)].desc = 0;
    31f4:	61a1      	str	r1, [r4, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    31f6:	f882 8000 	strb.w	r8, [r2]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    31fa:	f000 81b1 	beq.w	3560 <usb_isr+0x42c>
    31fe:	d82b      	bhi.n	3258 <usb_isr+0x124>
    3200:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    3204:	f000 8146 	beq.w	3494 <usb_isr+0x360>
    3208:	d810      	bhi.n	322c <usb_isr+0xf8>
    320a:	2b82      	cmp	r3, #130	; 0x82
    320c:	f000 8134 	beq.w	3478 <usb_isr+0x344>
    3210:	d806      	bhi.n	3220 <usb_isr+0xec>
    3212:	2b80      	cmp	r3, #128	; 0x80
    3214:	f040 819d 	bne.w	3552 <usb_isr+0x41e>
		datalen = 1;
		data = reply_buffer;
		goto send;

	case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    3218:	4c84      	ldr	r4, [pc, #528]	; (342c <usb_isr+0x2f8>)
    321a:	7021      	strb	r1, [r4, #0]
		reply_buffer[1] = 0;
    321c:	7061      	strb	r1, [r4, #1]
    321e:	e1a1      	b.n	3564 <usb_isr+0x430>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    3220:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    3224:	f0c0 8195 	bcc.w	3552 <usb_isr+0x41e>
		goto send;

	case 0x0100: // CLEAR_FEATURE (device)
	case 0x0101: // CLEAR_FEATURE (interface)
		// TODO: Currently ignoring, perhaps useful? -HaaTa
		warn_print("CLEAR_FEATURE - Device/Interface");
    3228:	4881      	ldr	r0, [pc, #516]	; (3430 <usb_isr+0x2fc>)
    322a:	e174      	b.n	3516 <usb_isr+0x3e2>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    322c:	f240 3201 	movw	r2, #769	; 0x301
    3230:	4293      	cmp	r3, r2
    3232:	d80b      	bhi.n	324c <usb_isr+0x118>
    3234:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    3238:	f080 813b 	bcs.w	34b2 <usb_isr+0x37e>
    323c:	f240 12a1 	movw	r2, #417	; 0x1a1
    3240:	4293      	cmp	r3, r2
    3242:	f040 8186 	bne.w	3552 <usb_isr+0x41e>
		{
			if ( list->addr == NULL )
				break;
			if ( list->wValue != 0x2200 )
				continue;
			if ( setup.wIndex == list->wIndex )
    3246:	88aa      	ldrh	r2, [r5, #4]
    3248:	4b7a      	ldr	r3, [pc, #488]	; (3434 <usb_isr+0x300>)
    324a:	e16d      	b.n	3528 <usb_isr+0x3f4>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    324c:	f240 3202 	movw	r2, #770	; 0x302
    3250:	4293      	cmp	r3, r2
    3252:	f000 8130 	beq.w	34b6 <usb_isr+0x382>
    3256:	e17c      	b.n	3552 <usb_isr+0x41e>
    3258:	f640 1221 	movw	r2, #2337	; 0x921
    325c:	4293      	cmp	r3, r2
    325e:	f000 814f 	beq.w	3500 <usb_isr+0x3cc>
    3262:	d81d      	bhi.n	32a0 <usb_isr+0x16c>
    3264:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    3268:	f000 8100 	beq.w	346c <usb_isr+0x338>
    326c:	d808      	bhi.n	3280 <usb_isr+0x14c>
    326e:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    3272:	2b01      	cmp	r3, #1
    3274:	f200 816d 	bhi.w	3552 <usb_isr+0x41e>
		#endif
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
				break;
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    3278:	886a      	ldrh	r2, [r5, #2]
    327a:	88a9      	ldrh	r1, [r5, #4]
    327c:	4b6d      	ldr	r3, [pc, #436]	; (3434 <usb_isr+0x300>)
    327e:	e12e      	b.n	34de <usb_isr+0x3aa>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    3280:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    3284:	f040 8165 	bne.w	3552 <usb_isr+0x41e>

	case 0x0900: // SET_CONFIGURATION
		#ifdef UART_DEBUG
		print("CONFIGURE - ");
		#endif
		usb_configuration = setup.wValue;
    3288:	4b5f      	ldr	r3, [pc, #380]	; (3408 <usb_isr+0x2d4>)
    328a:	78aa      	ldrb	r2, [r5, #2]
    328c:	701a      	strb	r2, [r3, #0]
		Output_Available = usb_configuration;
    328e:	781a      	ldrb	r2, [r3, #0]
    3290:	f8df 8184 	ldr.w	r8, [pc, #388]	; 3418 <usb_isr+0x2e4>
    3294:	4b68      	ldr	r3, [pc, #416]	; (3438 <usb_isr+0x304>)
    3296:	b2d2      	uxtb	r2, r2
    3298:	701a      	strb	r2, [r3, #0]
    329a:	f508 7980 	add.w	r9, r8, #256	; 0x100
    329e:	e01f      	b.n	32e0 <usb_isr+0x1ac>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    32a0:	f242 0221 	movw	r2, #8225	; 0x2021
    32a4:	4293      	cmp	r3, r2
    32a6:	f000 8187 	beq.w	35b8 <usb_isr+0x484>
    32aa:	d80c      	bhi.n	32c6 <usb_isr+0x192>
    32ac:	f640 2221 	movw	r2, #2593	; 0xa21
    32b0:	4293      	cmp	r3, r2
    32b2:	f000 8145 	beq.w	3540 <usb_isr+0x40c>
    32b6:	f640 3221 	movw	r2, #2849	; 0xb21
    32ba:	4293      	cmp	r3, r2
    32bc:	f040 8149 	bne.w	3552 <usb_isr+0x41e>
		printHex( setup.wValue );
		print(" - ");
		printHex( setup.wValue & 0xFF );
		print(NL);
		#endif
		USBKeys_Protocol = setup.wValue & 0xFF; // 0 - Boot Mode, 1 - NKRO Mode
    32c0:	78aa      	ldrb	r2, [r5, #2]
    32c2:	4b5e      	ldr	r3, [pc, #376]	; (343c <usb_isr+0x308>)
    32c4:	e143      	b.n	354e <usb_isr+0x41a>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch ( setup.wRequestAndType )
    32c6:	f242 12a1 	movw	r2, #8609	; 0x21a1
    32ca:	4293      	cmp	r3, r2
    32cc:	f000 8145 	beq.w	355a <usb_isr+0x426>
    32d0:	f242 2221 	movw	r2, #8737	; 0x2221
    32d4:	4293      	cmp	r3, r2
    32d6:	f040 813c 	bne.w	3552 <usb_isr+0x41e>
		#endif
		endpoint0_stall();
		return;

	case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr = setup.wValue;
    32da:	78aa      	ldrb	r2, [r5, #2]
    32dc:	4b58      	ldr	r3, [pc, #352]	; (3440 <usb_isr+0x30c>)
    32de:	e136      	b.n	354e <usb_isr+0x41a>
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
		{
			if ( table[i].desc & BDT_OWN )
    32e0:	f8d8 3020 	ldr.w	r3, [r8, #32]
    32e4:	061a      	lsls	r2, r3, #24
    32e6:	d504      	bpl.n	32f2 <usb_isr+0x1be>
			{
				usb_free( (usb_packet_t *)((uint8_t *)(table[ i ].addr) - 8) );
    32e8:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
    32ec:	3808      	subs	r0, #8
    32ee:	f000 fc89 	bl	3c04 <usb_free>
    32f2:	f108 0808 	add.w	r8, r8, #8
		usb_configuration = setup.wValue;
		Output_Available = usb_configuration;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    32f6:	45c8      	cmp	r8, r9
    32f8:	d1f2      	bne.n	32e0 <usb_isr+0x1ac>
    32fa:	f04f 0800 	mov.w	r8, #0
    32fe:	46c1      	mov	r9, r8
		}
		// free all queued packets
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
		{
			usb_packet_t *p, *n;
			p = rx_first[i];
    3300:	f8df a160 	ldr.w	sl, [pc, #352]	; 3464 <usb_isr+0x330>
    3304:	f858 000a 	ldr.w	r0, [r8, sl]
			while ( p )
    3308:	b128      	cbz	r0, 3316 <usb_isr+0x1e2>
			{
				n = p->next;
    330a:	f8d0 b004 	ldr.w	fp, [r0, #4]
				usb_free(p);
    330e:	f000 fc79 	bl	3c04 <usb_free>
				p = n;
    3312:	4658      	mov	r0, fp
    3314:	e7f8      	b.n	3308 <usb_isr+0x1d4>
			}
			rx_first[ i ] = NULL;
    3316:	f84a 0008 	str.w	r0, [sl, r8]
			rx_last[ i ] = NULL;
    331a:	4b4a      	ldr	r3, [pc, #296]	; (3444 <usb_isr+0x310>)
			p = tx_first[i];
    331c:	f8df a148 	ldr.w	sl, [pc, #328]	; 3468 <usb_isr+0x334>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[ i ] = NULL;
			rx_last[ i ] = NULL;
    3320:	f848 0003 	str.w	r0, [r8, r3]
			p = tx_first[i];
    3324:	f858 000a 	ldr.w	r0, [r8, sl]
			while (p)
    3328:	b128      	cbz	r0, 3336 <usb_isr+0x202>
			{
				n = p->next;
    332a:	f8d0 b004 	ldr.w	fp, [r0, #4]
				usb_free(p);
    332e:	f000 fc69 	bl	3c04 <usb_free>
				p = n;
    3332:	4658      	mov	r0, fp
    3334:	e7f8      	b.n	3328 <usb_isr+0x1f4>
			}
			tx_first[ i ] = NULL;
			tx_last[ i ] = NULL;
    3336:	4b44      	ldr	r3, [pc, #272]	; (3448 <usb_isr+0x314>)
			{
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[ i ] = NULL;
    3338:	f84a 0008 	str.w	r0, [sl, r8]
			tx_last[ i ] = NULL;
    333c:	f848 0003 	str.w	r0, [r8, r3]
			usb_rx_byte_count_data[i] = 0;
    3340:	4b42      	ldr	r3, [pc, #264]	; (344c <usb_isr+0x318>)
    3342:	f823 0019 	strh.w	r0, [r3, r9, lsl #1]

			switch ( tx_state[ i ] )
    3346:	4b42      	ldr	r3, [pc, #264]	; (3450 <usb_isr+0x31c>)
    3348:	f819 2003 	ldrb.w	r2, [r9, r3]
    334c:	3a02      	subs	r2, #2
    334e:	2a03      	cmp	r2, #3
    3350:	d808      	bhi.n	3364 <usb_isr+0x230>
    3352:	e8df f002 	tbb	[pc, r2]
    3356:	0402      	.short	0x0402
    3358:	0402      	.short	0x0402
			{
			case TX_STATE_EVEN_FREE:
			case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[ i ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    335a:	2200      	movs	r2, #0
    335c:	e000      	b.n	3360 <usb_isr+0x22c>
				break;
			case TX_STATE_ODD_FREE:
			case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    335e:	2201      	movs	r2, #1
    3360:	f803 2009 	strb.w	r2, [r3, r9]
			{
				usb_free( (usb_packet_t *)((uint8_t *)(table[ i ].addr) - 8) );
			}
		}
		// free all queued packets
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    3364:	f109 0901 	add.w	r9, r9, #1
    3368:	f1b9 0f08 	cmp.w	r9, #8
    336c:	f108 0804 	add.w	r8, r8, #4
    3370:	d1c6      	bne.n	3300 <usb_isr+0x1cc>
				break;
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    3372:	4b38      	ldr	r3, [pc, #224]	; (3454 <usb_isr+0x320>)
    3374:	2200      	movs	r2, #0
    3376:	701a      	strb	r2, [r3, #0]
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    3378:	f04f 0801 	mov.w	r8, #1
    337c:	469a      	mov	sl, r3
    337e:	4a36      	ldr	r2, [pc, #216]	; (3458 <usb_isr+0x324>)
    3380:	4b36      	ldr	r3, [pc, #216]	; (345c <usb_isr+0x328>)
    3382:	4442      	add	r2, r8
    3384:	4443      	add	r3, r8
		{
			epconf = *cfg++;
    3386:	f812 2c01 	ldrb.w	r2, [r2, #-1]
    338a:	009b      	lsls	r3, r3, #2
			*reg = epconf;
			reg += 4;
			if ( epconf & USB_ENDPT_EPRXEN )
    338c:	f012 0f08 	tst.w	r2, #8
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
		{
			epconf = *cfg++;
			*reg = epconf;
    3390:	701a      	strb	r2, [r3, #0]
    3392:	ea4f 0988 	mov.w	r9, r8, lsl #2
			reg += 4;
			if ( epconf & USB_ENDPT_EPRXEN )
    3396:	d025      	beq.n	33e4 <usb_isr+0x2b0>
			{
				usb_packet_t *p;
				p = usb_malloc();
    3398:	f000 fc16 	bl	3bc8 <usb_malloc>
				if ( p )
    339c:	b138      	cbz	r0, 33ae <usb_isr+0x27a>
				{
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    339e:	eb04 1348 	add.w	r3, r4, r8, lsl #5
    33a2:	3008      	adds	r0, #8
    33a4:	6058      	str	r0, [r3, #4]
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    33a6:	4b2e      	ldr	r3, [pc, #184]	; (3460 <usb_isr+0x32c>)
    33a8:	f844 3039 	str.w	r3, [r4, r9, lsl #3]
    33ac:	e006      	b.n	33bc <usb_isr+0x288>
				}
				else
				{
					table[ index( i, RX, EVEN ) ].desc = 0;
					usb_rx_memory_needed++;
    33ae:	f89a 3000 	ldrb.w	r3, [sl]
					table[ index( i, RX, EVEN ) ].addr = p->buf;
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
				}
				else
				{
					table[ index( i, RX, EVEN ) ].desc = 0;
    33b2:	f844 0039 	str.w	r0, [r4, r9, lsl #3]
					usb_rx_memory_needed++;
    33b6:	3301      	adds	r3, #1
    33b8:	f88a 3000 	strb.w	r3, [sl]
				}
				p = usb_malloc();
    33bc:	f000 fc04 	bl	3bc8 <usb_malloc>
				if ( p )
				{
					table[ index( i, RX, ODD ) ].addr = p->buf;
    33c0:	f049 0301 	orr.w	r3, r9, #1
				{
					table[ index( i, RX, EVEN ) ].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if ( p )
    33c4:	b138      	cbz	r0, 33d6 <usb_isr+0x2a2>
				{
					table[ index( i, RX, ODD ) ].addr = p->buf;
    33c6:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    33ca:	3008      	adds	r0, #8
    33cc:	6050      	str	r0, [r2, #4]
					table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    33ce:	4a14      	ldr	r2, [pc, #80]	; (3420 <usb_isr+0x2ec>)
    33d0:	f844 2033 	str.w	r2, [r4, r3, lsl #3]
    33d4:	e006      	b.n	33e4 <usb_isr+0x2b0>
				}
				else
				{
					table[ index( i, RX, ODD ) ].desc = 0;
    33d6:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
					usb_rx_memory_needed++;
    33da:	f89a 3000 	ldrb.w	r3, [sl]
    33de:	3301      	adds	r3, #1
    33e0:	f88a 3000 	strb.w	r3, [sl]
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
    33e4:	f049 0302 	orr.w	r3, r9, #2
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    33e8:	f108 0801 	add.w	r8, r8, #1
					table[ index( i, RX, ODD ) ].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
			table[ index( i, TX, ODD ) ].desc = 0;
    33ec:	f049 0903 	orr.w	r9, r9, #3
				{
					table[ index( i, RX, ODD ) ].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
    33f0:	2100      	movs	r1, #0
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    33f2:	f1b8 0f09 	cmp.w	r8, #9
				{
					table[ index( i, RX, ODD ) ].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[ index( i, TX, EVEN ) ].desc = 0;
    33f6:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
			table[ index( i, TX, ODD ) ].desc = 0;
    33fa:	f844 1039 	str.w	r1, [r4, r9, lsl #3]
			default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    33fe:	d1be      	bne.n	337e <usb_isr+0x24a>
    3400:	e0ae      	b.n	3560 <usb_isr+0x42c>
    3402:	bf00      	nop
    3404:	40072080 	.word	0x40072080
    3408:	1ffff2a7 	.word	0x1ffff2a7
    340c:	1ffff211 	.word	0x1ffff211
    3410:	1ffff2aa 	.word	0x1ffff2aa
    3414:	40072090 	.word	0x40072090
    3418:	1fffe000 	.word	0x1fffe000
    341c:	1ffff294 	.word	0x1ffff294
    3420:	004000c8 	.word	0x004000c8
    3424:	1ffff184 	.word	0x1ffff184
    3428:	1ffff2a8 	.word	0x1ffff2a8
    342c:	1ffff29f 	.word	0x1ffff29f
    3430:	00006bb0 	.word	0x00006bb0
    3434:	00006a84 	.word	0x00006a84
    3438:	1ffff17e 	.word	0x1ffff17e
    343c:	1fffeb81 	.word	0x1fffeb81
    3440:	1ffff2b8 	.word	0x1ffff2b8
    3444:	1ffff188 	.word	0x1ffff188
    3448:	1ffff274 	.word	0x1ffff274
    344c:	1ffffc3c 	.word	0x1ffffc3c
    3450:	1ffff1a8 	.word	0x1ffff1a8
    3454:	1ffff29e 	.word	0x1ffff29e
    3458:	00006a6e 	.word	0x00006a6e
    345c:	1001c830 	.word	0x1001c830
    3460:	00400088 	.word	0x00400088
    3464:	1ffff1f0 	.word	0x1ffff1f0
    3468:	1ffff254 	.word	0x1ffff254
			table[ index( i, TX, ODD ) ].desc = 0;
		}
		goto send;

	case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    346c:	4ba2      	ldr	r3, [pc, #648]	; (36f8 <usb_isr+0x5c4>)
    346e:	4ca3      	ldr	r4, [pc, #652]	; (36fc <usb_isr+0x5c8>)
    3470:	781b      	ldrb	r3, [r3, #0]
    3472:	7023      	strb	r3, [r4, #0]
		datalen = 1;
    3474:	4641      	mov	r1, r8
    3476:	e076      	b.n	3566 <usb_isr+0x432>
		datalen = 2;
		data = reply_buffer;
		goto send;

	case 0x0082: // GET_STATUS (endpoint)
		if ( setup.wIndex > NUM_ENDPOINTS )
    3478:	88ab      	ldrh	r3, [r5, #4]
    347a:	2b08      	cmp	r3, #8
    347c:	d869      	bhi.n	3552 <usb_isr+0x41e>
		{
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    347e:	4c9f      	ldr	r4, [pc, #636]	; (36fc <usb_isr+0x5c8>)
		reply_buffer[1] = 0;
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
    3480:	009a      	lsls	r2, r3, #2
    3482:	4b9f      	ldr	r3, [pc, #636]	; (3700 <usb_isr+0x5cc>)
		{
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    3484:	7021      	strb	r1, [r4, #0]
		reply_buffer[1] = 0;
    3486:	7061      	strb	r1, [r4, #1]
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
    3488:	5c9b      	ldrb	r3, [r3, r2]
    348a:	079b      	lsls	r3, r3, #30
    348c:	d56a      	bpl.n	3564 <usb_isr+0x430>
			reply_buffer[0] = 1;
    348e:	f884 8000 	strb.w	r8, [r4]
    3492:	e067      	b.n	3564 <usb_isr+0x430>
		warn_print("CLEAR_FEATURE - Device/Interface");
		endpoint0_stall();
		return;

	case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
    3494:	88ab      	ldrh	r3, [r5, #4]
    3496:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if ( i > NUM_ENDPOINTS || setup.wValue != 0 )
    349a:	2a08      	cmp	r2, #8
    349c:	dc59      	bgt.n	3552 <usb_isr+0x41e>
    349e:	8869      	ldrh	r1, [r5, #2]
    34a0:	2900      	cmp	r1, #0
    34a2:	d156      	bne.n	3552 <usb_isr+0x41e>
		{
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4)) &= ~0x02;
    34a4:	009a      	lsls	r2, r3, #2
    34a6:	4b96      	ldr	r3, [pc, #600]	; (3700 <usb_isr+0x5cc>)
    34a8:	4413      	add	r3, r2
    34aa:	781a      	ldrb	r2, [r3, #0]
    34ac:	f022 0202 	bic.w	r2, r2, #2
    34b0:	e04d      	b.n	354e <usb_isr+0x41a>
		goto send;

	case 0x0300: // SET_FEATURE (device)
	case 0x0301: // SET_FEATURE (interface)
		// TODO: Currently ignoring, perhaps useful? -HaaTa
		warn_print("SET_FEATURE - Device/Interface");
    34b2:	4894      	ldr	r0, [pc, #592]	; (3704 <usb_isr+0x5d0>)
    34b4:	e02f      	b.n	3516 <usb_isr+0x3e2>
		endpoint0_stall();
		return;

	case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
    34b6:	88ab      	ldrh	r3, [r5, #4]
    34b8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
		if ( i > NUM_ENDPOINTS || setup.wValue != 0 )
    34bc:	2a08      	cmp	r2, #8
    34be:	dc48      	bgt.n	3552 <usb_isr+0x41e>
    34c0:	8869      	ldrh	r1, [r5, #2]
    34c2:	2900      	cmp	r1, #0
    34c4:	d145      	bne.n	3552 <usb_isr+0x41e>
		{
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4)) |= 0x02;
    34c6:	009a      	lsls	r2, r3, #2
    34c8:	4b8d      	ldr	r3, [pc, #564]	; (3700 <usb_isr+0x5cc>)
    34ca:	4413      	add	r3, r2
    34cc:	781a      	ldrb	r2, [r3, #0]
    34ce:	f042 0202 	orr.w	r2, r2, #2
    34d2:	e03c      	b.n	354e <usb_isr+0x41a>
		#endif
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
				break;
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    34d4:	f833 cc0c 	ldrh.w	ip, [r3, #-12]
    34d8:	4594      	cmp	ip, r2
    34da:	d007      	beq.n	34ec <usb_isr+0x3b8>
    34dc:	330c      	adds	r3, #12
		printHex( setup.wValue );
		print( NL );
		#endif
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
    34de:	f853 4c08 	ldr.w	r4, [r3, #-8]
    34e2:	f1a3 000c 	sub.w	r0, r3, #12
    34e6:	2c00      	cmp	r4, #0
    34e8:	d1f4      	bne.n	34d4 <usb_isr+0x3a0>
    34ea:	e032      	b.n	3552 <usb_isr+0x41e>
				break;
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    34ec:	f833 cc0a 	ldrh.w	ip, [r3, #-10]
    34f0:	458c      	cmp	ip, r1
    34f2:	d1f3      	bne.n	34dc <usb_isr+0x3a8>
			{
				data = list->addr;
				if ( (setup.wValue >> 8) == 3 )
    34f4:	0a12      	lsrs	r2, r2, #8
    34f6:	2a03      	cmp	r2, #3
				{
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    34f8:	bf0c      	ite	eq
    34fa:	7821      	ldrbeq	r1, [r4, #0]
				}
				else
				{
					datalen = list->length;
    34fc:	8901      	ldrhne	r1, [r0, #8]
    34fe:	e032      	b.n	3566 <usb_isr+0x432>
		//serial_print("set coding, waiting...\n");
		return;

	case 0x0921: // HID SET_REPORT
		// Interface
		switch ( setup.wIndex & 0xFF )
    3500:	792b      	ldrb	r3, [r5, #4]
    3502:	2b01      	cmp	r3, #1
    3504:	d958      	bls.n	35b8 <usb_isr+0x484>
			break;
		// NKRO Keyboard Interface
		case NKRO_KEYBOARD_INTERFACE:
			break;
		default:
			warn_msg("Unknown interface - ");
    3506:	4880      	ldr	r0, [pc, #512]	; (3708 <usb_isr+0x5d4>)
    3508:	f001 f83a 	bl	4580 <_print>
			printHex( setup.wIndex );
    350c:	88a8      	ldrh	r0, [r5, #4]
    350e:	4641      	mov	r1, r8
    3510:	f001 f8bf 	bl	4692 <printHex_op>
			print( NL );
    3514:	487d      	ldr	r0, [pc, #500]	; (370c <usb_isr+0x5d8>)
    3516:	f001 f833 	bl	4580 <_print>
    351a:	e01a      	b.n	3552 <usb_isr+0x41e>
		// Search through descriptors returning necessary info
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
				break;
			if ( list->wValue != 0x2200 )
    351c:	f833 0c0c 	ldrh.w	r0, [r3, #-12]
    3520:	f5b0 5f08 	cmp.w	r0, #8704	; 0x2200
    3524:	d005      	beq.n	3532 <usb_isr+0x3fe>
    3526:	330c      	adds	r3, #12
		print(NL);
		#endif
		// Search through descriptors returning necessary info
		for ( list = usb_descriptor_list; 1; list++ )
		{
			if ( list->addr == NULL )
    3528:	f853 4c08 	ldr.w	r4, [r3, #-8]
    352c:	2c00      	cmp	r4, #0
    352e:	d1f5      	bne.n	351c <usb_isr+0x3e8>
    3530:	e00f      	b.n	3552 <usb_isr+0x41e>
				break;
			if ( list->wValue != 0x2200 )
				continue;
			if ( setup.wIndex == list->wIndex )
    3532:	f833 0c0a 	ldrh.w	r0, [r3, #-10]
    3536:	4290      	cmp	r0, r2
    3538:	d1f5      	bne.n	3526 <usb_isr+0x3f2>
			{
				data = list->addr;
				datalen = list->length;
    353a:	f833 1c04 	ldrh.w	r1, [r3, #-4]
    353e:	e012      	b.n	3566 <usb_isr+0x432>
		#ifdef UART_DEBUG
		print("SET_IDLE - ");
		printHex( setup.wValue );
		print(NL);
		#endif
		USBKeys_Idle_Config = (setup.wValue >> 8);
    3540:	886a      	ldrh	r2, [r5, #2]
    3542:	4b73      	ldr	r3, [pc, #460]	; (3710 <usb_isr+0x5dc>)
    3544:	0a12      	lsrs	r2, r2, #8
    3546:	701a      	strb	r2, [r3, #0]
		USBKeys_Idle_Count = 0;
    3548:	4b72      	ldr	r3, [pc, #456]	; (3714 <usb_isr+0x5e0>)
    354a:	7019      	strb	r1, [r3, #0]
    354c:	e008      	b.n	3560 <usb_isr+0x42c>
		printHex( setup.wValue );
		print(" - ");
		printHex( setup.wValue & 0xFF );
		print(NL);
		#endif
		USBKeys_Protocol = setup.wValue & 0xFF; // 0 - Boot Mode, 1 - NKRO Mode
    354e:	701a      	strb	r2, [r3, #0]
    3550:	e006      	b.n	3560 <usb_isr+0x42c>
static void endpoint0_stall()
{
	#ifdef UART_DEBUG_UNKNOWN
	print("STALL" NL );
	#endif
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    3552:	4b6b      	ldr	r3, [pc, #428]	; (3700 <usb_isr+0x5cc>)
    3554:	220f      	movs	r2, #15
    3556:	701a      	strb	r2, [r3, #0]
    3558:	e02e      	b.n	35b8 <usb_isr+0x484>
		//serial_print("set control line state\n");
		goto send;

	case 0x21A1: // CDC_GET_LINE_CODING
		data = (uint8_t*)usb_cdc_line_coding;
		datalen = sizeof( usb_cdc_line_coding );
    355a:	2107      	movs	r1, #7
		usb_cdc_line_rtsdtr = setup.wValue;
		//serial_print("set control line state\n");
		goto send;

	case 0x21A1: // CDC_GET_LINE_CODING
		data = (uint8_t*)usb_cdc_line_coding;
    355c:	4c6e      	ldr	r4, [pc, #440]	; (3718 <usb_isr+0x5e4>)
    355e:	e002      	b.n	3566 <usb_isr+0x432>
	ep0_tx_bdt_bank ^= 1;
}

static void usb_setup()
{
	const uint8_t *data = NULL;
    3560:	460c      	mov	r4, r1
    3562:	e000      	b.n	3566 <usb_isr+0x432>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ( *(uint8_t *)(&USB0_ENDPT0 + setup.wIndex * 4) & 0x02 )
			reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    3564:	2102      	movs	r1, #2
	print(",");
	printHex( datalen );
	print( NL );
	#endif

	if ( datalen > setup.wLength )
    3566:	f8b5 8006 	ldrh.w	r8, [r5, #6]
    356a:	4541      	cmp	r1, r8
    356c:	bf38      	it	cc
    356e:	4688      	movcc	r8, r1
    3570:	f1b8 0f40 	cmp.w	r8, #64	; 0x40
    3574:	bf34      	ite	cc
    3576:	4645      	movcc	r5, r8
    3578:	2540      	movcs	r5, #64	; 0x40

	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;

	endpoint0_transmit(data, size);
    357a:	4620      	mov	r0, r4
    357c:	4629      	mov	r1, r5
    357e:	f7ff fcf9 	bl	2f74 <endpoint0_transmit>
	data += size;
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    3582:	ebb8 0805 	subs.w	r8, r8, r5
	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;

	endpoint0_transmit(data, size);
	data += size;
    3586:	442c      	add	r4, r5
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    3588:	d103      	bne.n	3592 <usb_isr+0x45e>
    358a:	2d40      	cmp	r5, #64	; 0x40
    358c:	d114      	bne.n	35b8 <usb_isr+0x484>
    358e:	4645      	mov	r5, r8
    3590:	e004      	b.n	359c <usb_isr+0x468>
    3592:	f1b8 0f40 	cmp.w	r8, #64	; 0x40
    3596:	bf34      	ite	cc
    3598:	4645      	movcc	r5, r8
    359a:	2540      	movcs	r5, #64	; 0x40
		return;

	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;
	endpoint0_transmit(data, size);
    359c:	4620      	mov	r0, r4
    359e:	4629      	mov	r1, r5
    35a0:	f7ff fce8 	bl	2f74 <endpoint0_transmit>
	data += size;
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    35a4:	ebb8 0805 	subs.w	r8, r8, r5

	size = datalen;
	if ( size > EP0_SIZE )
		size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    35a8:	442c      	add	r4, r5
	datalen -= size;

	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
    35aa:	d101      	bne.n	35b0 <usb_isr+0x47c>
    35ac:	2d40      	cmp	r5, #64	; 0x40
    35ae:	d103      	bne.n	35b8 <usb_isr+0x484>
		return;

	// Save rest of transfer for later? XXX
	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    35b0:	4b5a      	ldr	r3, [pc, #360]	; (371c <usb_isr+0x5e8>)
	// See if transmit has finished
	if ( datalen == 0 && size < EP0_SIZE )
		return;

	// Save rest of transfer for later? XXX
	ep0_tx_ptr = data;
    35b2:	603c      	str	r4, [r7, #0]
	ep0_tx_len = datalen;
    35b4:	f8a3 8000 	strh.w	r8, [r3]
		print(NL);
		#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    35b8:	2201      	movs	r2, #1
    35ba:	4b59      	ldr	r3, [pc, #356]	; (3720 <usb_isr+0x5ec>)
    35bc:	e05a      	b.n	3674 <usb_isr+0x540>
		printHex32(setup.word2);
		print(NL);
		#endif

		// CDC Interface
		if ( setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/ )
    35be:	4d59      	ldr	r5, [pc, #356]	; (3724 <usb_isr+0x5f0>)
    35c0:	882b      	ldrh	r3, [r5, #0]
    35c2:	f242 0121 	movw	r1, #8225	; 0x2021
    35c6:	428b      	cmp	r3, r1
    35c8:	d10e      	bne.n	35e8 <usb_isr+0x4b4>
    35ca:	2300      	movs	r3, #0
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for ( i = 0; i < 7; i++ )
			{
				//serial_phex(*buf);
				*dst++ = *buf++;
    35cc:	4952      	ldr	r1, [pc, #328]	; (3718 <usb_isr+0x5e4>)
    35ce:	5cd0      	ldrb	r0, [r2, r3]
    35d0:	5458      	strb	r0, [r3, r1]
		if ( setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/ )
		{
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for ( i = 0; i < 7; i++ )
    35d2:	3301      	adds	r3, #1
    35d4:	2b07      	cmp	r3, #7
    35d6:	d1f9      	bne.n	35cc <usb_isr+0x498>
				//serial_phex(*buf);
				*dst++ = *buf++;
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if ( usb_cdc_line_coding[0] == 134 )
    35d8:	780b      	ldrb	r3, [r1, #0]
    35da:	2b86      	cmp	r3, #134	; 0x86
    35dc:	d102      	bne.n	35e4 <usb_isr+0x4b0>
				usb_reboot_timer = 15;
    35de:	4b52      	ldr	r3, [pc, #328]	; (3728 <usb_isr+0x5f4>)
    35e0:	220f      	movs	r2, #15
    35e2:	701a      	strb	r2, [r3, #0]
			endpoint0_transmit( NULL, 0 );
    35e4:	2000      	movs	r0, #0
    35e6:	e010      	b.n	360a <usb_isr+0x4d6>
		}

		// Keyboard SET_REPORT
		if ( setup.wRequestAndType == 0x921 && setup.wValue & 0x200 )
    35e8:	f640 1121 	movw	r1, #2337	; 0x921
    35ec:	428b      	cmp	r3, r1
    35ee:	d11a      	bne.n	3626 <usb_isr+0x4f2>
    35f0:	886b      	ldrh	r3, [r5, #2]
    35f2:	059f      	lsls	r7, r3, #22
    35f4:	d517      	bpl.n	3626 <usb_isr+0x4f2>
		{
			// Interface
			switch ( setup.wIndex & 0xFF )
    35f6:	7928      	ldrb	r0, [r5, #4]
    35f8:	b120      	cbz	r0, 3604 <usb_isr+0x4d0>
    35fa:	2801      	cmp	r0, #1
    35fc:	d109      	bne.n	3612 <usb_isr+0x4de>
				endpoint0_transmit( NULL, 0 );
				break;
			// NKRO Keyboard Interface
			case NKRO_KEYBOARD_INTERFACE:
				// Only use 2nd byte, first byte is the report id
				USBKeys_LEDs = buf[1];
    35fe:	7852      	ldrb	r2, [r2, #1]
    3600:	4b4a      	ldr	r3, [pc, #296]	; (372c <usb_isr+0x5f8>)
    3602:	e7ee      	b.n	35e2 <usb_isr+0x4ae>
			// Interface
			switch ( setup.wIndex & 0xFF )
			{
			// Keyboard Interface
			case KEYBOARD_INTERFACE:
				USBKeys_LEDs = buf[0];
    3604:	4b49      	ldr	r3, [pc, #292]	; (372c <usb_isr+0x5f8>)
    3606:	7812      	ldrb	r2, [r2, #0]
    3608:	701a      	strb	r2, [r3, #0]
				endpoint0_transmit( NULL, 0 );
    360a:	4601      	mov	r1, r0
    360c:	f7ff fcb2 	bl	2f74 <endpoint0_transmit>
    3610:	e009      	b.n	3626 <usb_isr+0x4f2>
				// Only use 2nd byte, first byte is the report id
				USBKeys_LEDs = buf[1];
				endpoint0_transmit( NULL, 0 );
				break;
			default:
				warn_msg("Unknown interface - ");
    3612:	483d      	ldr	r0, [pc, #244]	; (3708 <usb_isr+0x5d4>)
    3614:	f000 ffb4 	bl	4580 <_print>
				printHex( setup.wIndex );
    3618:	88a8      	ldrh	r0, [r5, #4]
    361a:	2101      	movs	r1, #1
    361c:	f001 f839 	bl	4692 <printHex_op>
				print( NL );
    3620:	483a      	ldr	r0, [pc, #232]	; (370c <usb_isr+0x5d8>)
    3622:	f000 ffad 	bl	4580 <_print>
			print( NL );
			#endif
		}

		// give the buffer back
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    3626:	4b42      	ldr	r3, [pc, #264]	; (3730 <usb_isr+0x5fc>)
    3628:	f844 3038 	str.w	r3, [r4, r8, lsl #3]
    362c:	e023      	b.n	3676 <usb_isr+0x542>
		printHex(stat);
		print(NL);
		#endif

		// send remaining data, if any...
		data = ep0_tx_ptr;
    362e:	4f41      	ldr	r7, [pc, #260]	; (3734 <usb_isr+0x600>)
    3630:	683d      	ldr	r5, [r7, #0]
		if ( data )
    3632:	b1b5      	cbz	r5, 3662 <usb_isr+0x52e>
		{
			size = ep0_tx_len;
    3634:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 371c <usb_isr+0x5e8>
    3638:	f8b8 9000 	ldrh.w	r9, [r8]
    363c:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
    3640:	bf34      	ite	cc
    3642:	464c      	movcc	r4, r9
    3644:	2440      	movcs	r4, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    3646:	4628      	mov	r0, r5
    3648:	4621      	mov	r1, r4
    364a:	f7ff fc93 	bl	2f74 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    364e:	ebc4 0309 	rsb	r3, r4, r9
    3652:	b29b      	uxth	r3, r3
    3654:	f8a8 3000 	strh.w	r3, [r8]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    3658:	b90b      	cbnz	r3, 365e <usb_isr+0x52a>
    365a:	2c40      	cmp	r4, #64	; 0x40
    365c:	d100      	bne.n	3660 <usb_isr+0x52c>
		if ( data )
		{
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    365e:	192b      	adds	r3, r5, r4
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    3660:	603b      	str	r3, [r7, #0]
		}

		if ( setup.bRequest == 5 && setup.bmRequestType == 0 )
    3662:	4b30      	ldr	r3, [pc, #192]	; (3724 <usb_isr+0x5f0>)
    3664:	881a      	ldrh	r2, [r3, #0]
    3666:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    366a:	d104      	bne.n	3676 <usb_isr+0x542>
		{
			setup.bRequest = 0;
    366c:	2200      	movs	r2, #0
    366e:	705a      	strb	r2, [r3, #1]
			#ifdef UART_DEBUG
			print("set address: ");
			printHex(setup.wValue);
			print(NL);
			#endif
			USB0_ADDR = setup.wValue;
    3670:	789a      	ldrb	r2, [r3, #2]
    3672:	4b31      	ldr	r3, [pc, #196]	; (3738 <usb_isr+0x604>)
    3674:	701a      	strb	r2, [r3, #0]
		printHex(pid);
		print(NL);
		#endif
		break;
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    3676:	2201      	movs	r2, #1
    3678:	4b29      	ldr	r3, [pc, #164]	; (3720 <usb_isr+0x5ec>)
    367a:	e093      	b.n	37a4 <usb_isr+0x670>
		{
			usb_control( stat );
		}
		else
		{
			bdt_t *b = stat2bufferdescriptor(stat);
    367c:	eb04 07c8 	add.w	r7, r4, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;     // endpoint is index to zero-based arrays
    3680:	3d01      	subs	r5, #1
			usb_control( stat );
		}
		else
		{
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    3682:	687b      	ldr	r3, [r7, #4]
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;     // endpoint is index to zero-based arrays

			if ( stat & 0x08 )
    3684:	f002 0208 	and.w	r2, r2, #8
			usb_control( stat );
		}
		else
		{
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    3688:	f1a3 0008 	sub.w	r0, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;     // endpoint is index to zero-based arrays
    368c:	b2ed      	uxtb	r5, r5

			if ( stat & 0x08 )
    368e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
    3692:	2a00      	cmp	r2, #0
    3694:	d05d      	beq.n	3752 <usb_isr+0x61e>
			{ // transmit
				usb_free( packet );
    3696:	f000 fab5 	bl	3c04 <usb_free>
				packet = tx_first[ endpoint ];
    369a:	4828      	ldr	r0, [pc, #160]	; (373c <usb_isr+0x608>)
    369c:	4b28      	ldr	r3, [pc, #160]	; (3740 <usb_isr+0x60c>)
    369e:	f850 2025 	ldr.w	r2, [r0, r5, lsl #2]
				if ( packet )
    36a2:	b1ea      	cbz	r2, 36e0 <usb_isr+0x5ac>
				{
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    36a4:	6851      	ldr	r1, [r2, #4]
    36a6:	f840 1025 	str.w	r1, [r0, r5, lsl #2]
					b->addr = packet->buf;
    36aa:	f102 0108 	add.w	r1, r2, #8
    36ae:	6079      	str	r1, [r7, #4]
					switch ( tx_state[ endpoint ] )
    36b0:	5d59      	ldrb	r1, [r3, r5]
    36b2:	2903      	cmp	r1, #3
    36b4:	d80b      	bhi.n	36ce <usb_isr+0x59a>
    36b6:	e8df f001 	tbb	[pc, r1]
    36ba:	0402      	.short	0x0402
    36bc:	0806      	.short	0x0806
					{
					case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[ endpoint ] = TX_STATE_ODD_FREE;
    36be:	2103      	movs	r1, #3
    36c0:	e004      	b.n	36cc <usb_isr+0x598>
						break;
					case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[ endpoint ] = TX_STATE_EVEN_FREE;
    36c2:	2102      	movs	r1, #2
    36c4:	e002      	b.n	36cc <usb_isr+0x598>
						break;
					case TX_STATE_EVEN_FREE:
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_ODD_FIRST;
    36c6:	2105      	movs	r1, #5
    36c8:	e000      	b.n	36cc <usb_isr+0x598>
						break;
					case TX_STATE_ODD_FREE:
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    36ca:	2104      	movs	r1, #4
    36cc:	5559      	strb	r1, [r3, r5]
						break;
					default:
						break;
					}
					b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    36ce:	f017 0f08 	tst.w	r7, #8
    36d2:	8812      	ldrh	r2, [r2, #0]
    36d4:	bf0c      	ite	eq
    36d6:	2388      	moveq	r3, #136	; 0x88
    36d8:	23c8      	movne	r3, #200	; 0xc8
    36da:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    36de:	e069      	b.n	37b4 <usb_isr+0x680>
				} else {
					//serial_print("tx no packet\n");
					switch ( tx_state[ endpoint ] )
    36e0:	5d5a      	ldrb	r2, [r3, r5]
    36e2:	2a03      	cmp	r2, #3
    36e4:	d82e      	bhi.n	3744 <usb_isr+0x610>
    36e6:	e8df f002 	tbb	[pc, r2]
    36ea:	6767      	.short	0x6767
    36ec:	0402      	.short	0x0402
					{
					case TX_STATE_BOTH_FREE_EVEN_FIRST:
					case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					case TX_STATE_EVEN_FREE:
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    36ee:	2200      	movs	r2, #0
    36f0:	e02d      	b.n	374e <usb_isr+0x61a>
						break;
					case TX_STATE_ODD_FREE:
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    36f2:	2201      	movs	r2, #1
    36f4:	e02b      	b.n	374e <usb_isr+0x61a>
    36f6:	bf00      	nop
    36f8:	1ffff2a7 	.word	0x1ffff2a7
    36fc:	1ffff29f 	.word	0x1ffff29f
    3700:	400720c0 	.word	0x400720c0
    3704:	00006be8 	.word	0x00006be8
    3708:	00006c1e 	.word	0x00006c1e
    370c:	00006caf 	.word	0x00006caf
    3710:	1fffeb80 	.word	0x1fffeb80
    3714:	1ffff17a 	.word	0x1ffff17a
    3718:	1fffefc4 	.word	0x1fffefc4
    371c:	1ffff29c 	.word	0x1ffff29c
    3720:	40072094 	.word	0x40072094
    3724:	1ffff294 	.word	0x1ffff294
    3728:	1ffff211 	.word	0x1ffff211
    372c:	1ffff177 	.word	0x1ffff177
    3730:	004000c8 	.word	0x004000c8
    3734:	1ffff184 	.word	0x1ffff184
    3738:	40072098 	.word	0x40072098
    373c:	1ffff254 	.word	0x1ffff254
    3740:	1ffff1a8 	.word	0x1ffff1a8
						break;
					default:
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    3744:	f017 0f08 	tst.w	r7, #8
    3748:	bf0c      	ite	eq
    374a:	2202      	moveq	r2, #2
    374c:	2203      	movne	r2, #3
    374e:	555a      	strb	r2, [r3, r5]
							? TX_STATE_ODD_FREE
							: TX_STATE_EVEN_FREE;
						break;
    3750:	e032      	b.n	37b8 <usb_isr+0x684>
					}
				}
			}
			else
			{ // receive
				packet->len = b->desc >> 16;
    3752:	f854 2038 	ldr.w	r2, [r4, r8, lsl #3]
    3756:	0c12      	lsrs	r2, r2, #16
    3758:	f823 2c08 	strh.w	r2, [r3, #-8]
				if ( packet->len > 0 )
    375c:	b322      	cbz	r2, 37a8 <usb_isr+0x674>
				{
					packet->index = 0;
					packet->next = NULL;
					if ( rx_first[ endpoint ] == NULL )
    375e:	f8df e104 	ldr.w	lr, [pc, #260]	; 3864 <usb_isr+0x730>
			else
			{ // receive
				packet->len = b->desc >> 16;
				if ( packet->len > 0 )
				{
					packet->index = 0;
    3762:	f823 1c06 	strh.w	r1, [r3, #-6]
					packet->next = NULL;
    3766:	f843 1c04 	str.w	r1, [r3, #-4]
					if ( rx_first[ endpoint ] == NULL )
    376a:	f85e 3025 	ldr.w	r3, [lr, r5, lsl #2]
    376e:	492f      	ldr	r1, [pc, #188]	; (382c <usb_isr+0x6f8>)
    3770:	b913      	cbnz	r3, 3778 <usb_isr+0x644>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[ endpoint ] = packet;
    3772:	f84e 0025 	str.w	r0, [lr, r5, lsl #2]
    3776:	e002      	b.n	377e <usb_isr+0x64a>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[ endpoint ]->next = packet;
    3778:	f851 3025 	ldr.w	r3, [r1, r5, lsl #2]
    377c:	6058      	str	r0, [r3, #4]
					}
					rx_last[ endpoint ] = packet;
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    377e:	4b2c      	ldr	r3, [pc, #176]	; (3830 <usb_isr+0x6fc>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[ endpoint ]->next = packet;
					}
					rx_last[ endpoint ] = packet;
    3780:	f841 0025 	str.w	r0, [r1, r5, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    3784:	f833 1015 	ldrh.w	r1, [r3, r5, lsl #1]
    3788:	440a      	add	r2, r1
    378a:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated packets
					// so a flood of incoming data on 1 endpoint doesn't starve
					// the others if the user isn't reading it regularly
					packet = usb_malloc();
    378e:	f000 fa1b 	bl	3bc8 <usb_malloc>
					if ( packet )
    3792:	b110      	cbz	r0, 379a <usb_isr+0x666>
					{
						b->addr = packet->buf;
    3794:	3008      	adds	r0, #8
    3796:	6078      	str	r0, [r7, #4]
    3798:	e006      	b.n	37a8 <usb_isr+0x674>
					{
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						//serial_print(((uint32_t)b & 8) ? ",odd\n" : ",even\n");
						b->desc = 0;
						usb_rx_memory_needed++;
    379a:	4b26      	ldr	r3, [pc, #152]	; (3834 <usb_isr+0x700>)
					else
					{
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						//serial_print(((uint32_t)b & 8) ? ",odd\n" : ",even\n");
						b->desc = 0;
    379c:	f844 0038 	str.w	r0, [r4, r8, lsl #3]
						usb_rx_memory_needed++;
    37a0:	781a      	ldrb	r2, [r3, #0]
    37a2:	3201      	adds	r2, #1
    37a4:	701a      	strb	r2, [r3, #0]
    37a6:	e007      	b.n	37b8 <usb_isr+0x684>
					}
				}
				else
				{
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    37a8:	4b23      	ldr	r3, [pc, #140]	; (3838 <usb_isr+0x704>)
    37aa:	4a24      	ldr	r2, [pc, #144]	; (383c <usb_isr+0x708>)
    37ac:	f017 0f08 	tst.w	r7, #8
    37b0:	bf08      	it	eq
    37b2:	4613      	moveq	r3, r2
    37b4:	f844 3038 	str.w	r3, [r4, r8, lsl #3]




		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    37b8:	2308      	movs	r3, #8
    37ba:	7033      	strb	r3, [r6, #0]
		goto restart;
    37bc:	e4bc      	b.n	3138 <usb_isr+0x4>
	}


	if ( status & USB_ISTAT_USBRST /* 01 */ )
    37be:	07e0      	lsls	r0, r4, #31
    37c0:	d51f      	bpl.n	3802 <usb_isr+0x6ce>
	{
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    37c2:	491f      	ldr	r1, [pc, #124]	; (3840 <usb_isr+0x70c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    37c4:	481d      	ldr	r0, [pc, #116]	; (383c <usb_isr+0x708>)
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
    37c6:	4c1f      	ldr	r4, [pc, #124]	; (3844 <usb_isr+0x710>)
	if ( status & USB_ISTAT_USBRST /* 01 */ )
	{
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    37c8:	2302      	movs	r3, #2
    37ca:	700b      	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    37cc:	4b1e      	ldr	r3, [pc, #120]	; (3848 <usb_isr+0x714>)
    37ce:	701a      	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    37d0:	4b1e      	ldr	r3, [pc, #120]	; (384c <usb_isr+0x718>)
    37d2:	6018      	str	r0, [r3, #0]
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
		table[index( 0, RX, ODD ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    37d4:	6098      	str	r0, [r3, #8]
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
    37d6:	481e      	ldr	r0, [pc, #120]	; (3850 <usb_isr+0x71c>)
    37d8:	60d8      	str	r0, [r3, #12]
		table[index( 0, TX, EVEN ) ].desc = 0;
    37da:	611a      	str	r2, [r3, #16]
		table[index( 0, TX, ODD ) ].desc = 0;
    37dc:	619a      	str	r2, [r3, #24]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
    37de:	605c      	str	r4, [r3, #4]
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
		table[index( 0, TX, EVEN ) ].desc = 0;
		table[index( 0, TX, ODD ) ].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    37e0:	4b1c      	ldr	r3, [pc, #112]	; (3854 <usb_isr+0x720>)
    37e2:	200d      	movs	r0, #13
    37e4:	7018      	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    37e6:	481c      	ldr	r0, [pc, #112]	; (3858 <usb_isr+0x724>)
    37e8:	23ff      	movs	r3, #255	; 0xff
    37ea:	7003      	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    37ec:	702b      	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    37ee:	7402      	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    37f0:	4a1a      	ldr	r2, [pc, #104]	; (385c <usb_isr+0x728>)
    37f2:	7013      	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    37f4:	4b1a      	ldr	r3, [pc, #104]	; (3860 <usb_isr+0x72c>)
    37f6:	229f      	movs	r2, #159	; 0x9f
    37f8:	701a      	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    37fa:	2301      	movs	r3, #1
    37fc:	700b      	strb	r3, [r1, #0]
		return;
    37fe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}


	if ( (status & USB_ISTAT_STALL /* 80 */ ) )
    3802:	0621      	lsls	r1, r4, #24
    3804:	d504      	bpl.n	3810 <usb_isr+0x6dc>
	{
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    3806:	4b13      	ldr	r3, [pc, #76]	; (3854 <usb_isr+0x720>)
    3808:	220d      	movs	r2, #13
    380a:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    380c:	2380      	movs	r3, #128	; 0x80
    380e:	702b      	strb	r3, [r5, #0]
	}
	if ( (status & USB_ISTAT_ERROR /* 02 */ ) )
    3810:	07a2      	lsls	r2, r4, #30
    3812:	d505      	bpl.n	3820 <usb_isr+0x6ec>
	{
		uint8_t err = USB0_ERRSTAT;
    3814:	4b10      	ldr	r3, [pc, #64]	; (3858 <usb_isr+0x724>)
    3816:	781a      	ldrb	r2, [r3, #0]
    3818:	b2d2      	uxtb	r2, r2
		USB0_ERRSTAT = err;
    381a:	701a      	strb	r2, [r3, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    381c:	2302      	movs	r3, #2
    381e:	702b      	strb	r3, [r5, #0]
	}

	if ( (status & USB_ISTAT_SLEEP /* 10 */ ) )
    3820:	06e3      	lsls	r3, r4, #27
	{
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    3822:	bf44      	itt	mi
    3824:	2310      	movmi	r3, #16
    3826:	702b      	strbmi	r3, [r5, #0]
    3828:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    382c:	1ffff188 	.word	0x1ffff188
    3830:	1ffffc3c 	.word	0x1ffffc3c
    3834:	1ffff29e 	.word	0x1ffff29e
    3838:	004000c8 	.word	0x004000c8
    383c:	00400088 	.word	0x00400088
    3840:	40072094 	.word	0x40072094
    3844:	1ffff1b0 	.word	0x1ffff1b0
    3848:	1ffff210 	.word	0x1ffff210
    384c:	1fffe000 	.word	0x1fffe000
    3850:	1ffff214 	.word	0x1ffff214
    3854:	400720c0 	.word	0x400720c0
    3858:	40072088 	.word	0x40072088
    385c:	4007208c 	.word	0x4007208c
    3860:	40072084 	.word	0x40072084
    3864:	1ffff1f0 	.word	0x1ffff1f0

00003868 <usb_init>:
}



uint8_t usb_init()
{
    3868:	2300      	movs	r3, #0
	#endif

	// Clear out endpoints table
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
	{
		table[i].desc = 0;
    386a:	4a1e      	ldr	r2, [pc, #120]	; (38e4 <usb_init+0x7c>)
    386c:	2100      	movs	r1, #0
    386e:	5099      	str	r1, [r3, r2]
    3870:	18d0      	adds	r0, r2, r3
    3872:	3308      	adds	r3, #8
	#ifdef UART_DEBUG
	print("USB INIT"NL);
	#endif

	// Clear out endpoints table
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    3874:	f5b3 7f84 	cmp.w	r3, #264	; 0x108
	{
		table[i].desc = 0;
		table[i].addr = 0;
    3878:	6041      	str	r1, [r0, #4]
	#ifdef UART_DEBUG
	print("USB INIT"NL);
	#endif

	// Clear out endpoints table
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    387a:	d1f6      	bne.n	386a <usb_init+0x2>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    387c:	4b1a      	ldr	r3, [pc, #104]	; (38e8 <usb_init+0x80>)
    387e:	6819      	ldr	r1, [r3, #0]
    3880:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
    3884:	6019      	str	r1, [r3, #0]

	// reset USB module
	USB0_USBTRC0 = USB_USBTRC_USBRESET;
    3886:	f503 3328 	add.w	r3, r3, #172032	; 0x2a000
    388a:	33d8      	adds	r3, #216	; 0xd8
    388c:	2180      	movs	r1, #128	; 0x80
    388e:	7019      	strb	r1, [r3, #0]
	while ( (USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0 ); // wait for reset to end
    3890:	7818      	ldrb	r0, [r3, #0]
    3892:	4916      	ldr	r1, [pc, #88]	; (38ec <usb_init+0x84>)
    3894:	0600      	lsls	r0, r0, #24
    3896:	d4fb      	bmi.n	3890 <usb_init+0x28>

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    3898:	4b15      	ldr	r3, [pc, #84]	; (38f0 <usb_init+0x88>)
    389a:	f3c2 2007 	ubfx	r0, r2, #8, #8
    389e:	7018      	strb	r0, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    38a0:	f3c2 4007 	ubfx	r0, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    38a4:	0e12      	lsrs	r2, r2, #24
	USB0_USBTRC0 = USB_USBTRC_USBRESET;
	while ( (USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0 ); // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    38a6:	7518      	strb	r0, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    38a8:	761a      	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    38aa:	4a12      	ldr	r2, [pc, #72]	; (38f4 <usb_init+0x8c>)
    38ac:	23ff      	movs	r3, #255	; 0xff
    38ae:	7013      	strb	r3, [r2, #0]
	USB0_ERRSTAT = 0xFF;
    38b0:	7213      	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    38b2:	f802 3c70 	strb.w	r3, [r2, #-112]

	USB0_USBTRC0 |= 0x40; // undocumented bit
    38b6:	780b      	ldrb	r3, [r1, #0]
    38b8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    38bc:	700b      	strb	r3, [r1, #0]

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    38be:	4b0e      	ldr	r3, [pc, #56]	; (38f8 <usb_init+0x90>)
    38c0:	2001      	movs	r0, #1
	USB0_USBCTRL = 0;
    38c2:	2200      	movs	r2, #0
	USB0_OTGISTAT = 0xFF;

	USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    38c4:	7018      	strb	r0, [r3, #0]
	USB0_USBCTRL = 0;
    38c6:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    38ca:	f803 0c10 	strb.w	r0, [r3, #-16]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY( IRQ_USBOTG, 112 );
    38ce:	4b0b      	ldr	r3, [pc, #44]	; (38fc <usb_init+0x94>)
    38d0:	2270      	movs	r2, #112	; 0x70
    38d2:	701a      	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ( IRQ_USBOTG );
    38d4:	f2a3 331f 	subw	r3, r3, #799	; 0x31f
    38d8:	2208      	movs	r2, #8
    38da:	601a      	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    38dc:	4b08      	ldr	r3, [pc, #32]	; (3900 <usb_init+0x98>)
    38de:	2210      	movs	r2, #16
    38e0:	701a      	strb	r2, [r3, #0]

	return 1;
}
    38e2:	4770      	bx	lr
    38e4:	1fffe000 	.word	0x1fffe000
    38e8:	40048034 	.word	0x40048034
    38ec:	4007210c 	.word	0x4007210c
    38f0:	4007209c 	.word	0x4007209c
    38f4:	40072080 	.word	0x40072080
    38f8:	40072094 	.word	0x40072094
    38fc:	e000e423 	.word	0xe000e423
    3900:	40072108 	.word	0x40072108

00003904 <usb_keyboard_send>:

// ----- Functions -----

// send the contents of keyboard_keys and keyboard_modifier_keys
void usb_keyboard_send()
{
    3904:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3908:	f245 3599 	movw	r5, #21401	; 0x5399
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    390c:	4b99      	ldr	r3, [pc, #612]	; (3b74 <usb_keyboard_send+0x270>)
    390e:	781b      	ldrb	r3, [r3, #0]
    3910:	b90b      	cbnz	r3, 3916 <usb_keyboard_send+0x12>
		{
			erro_print("USB not configured...");
    3912:	4899      	ldr	r0, [pc, #612]	; (3b78 <usb_keyboard_send+0x274>)
    3914:	e023      	b.n	395e <usb_keyboard_send+0x5a>
			return;
		}

		if ( USBKeys_Protocol == 0 ) // Boot Mode
    3916:	4b99      	ldr	r3, [pc, #612]	; (3b7c <usb_keyboard_send+0x278>)
    3918:	781a      	ldrb	r2, [r3, #0]
    391a:	461e      	mov	r6, r3
    391c:	b942      	cbnz	r2, 3930 <usb_keyboard_send+0x2c>
		{
			if ( usb_tx_packet_count( KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    391e:	2001      	movs	r0, #1
    3920:	f7ff fb64 	bl	2fec <usb_tx_packet_count>
    3924:	2803      	cmp	r0, #3
    3926:	d90f      	bls.n	3948 <usb_keyboard_send+0x44>
				if ( tx_packet )
					break;
			}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
    3928:	3d01      	subs	r5, #1
    392a:	4b95      	ldr	r3, [pc, #596]	; (3b80 <usb_keyboard_send+0x27c>)
    392c:	d112      	bne.n	3954 <usb_keyboard_send+0x50>
    392e:	e013      	b.n	3958 <usb_keyboard_send+0x54>
				tx_packet = usb_malloc();
				if ( tx_packet )
					break;
			}
		}
		else if ( USBKeys_Protocol == 1 ) // NKRO Mode
    3930:	781b      	ldrb	r3, [r3, #0]
    3932:	2b01      	cmp	r3, #1
    3934:	d101      	bne.n	393a <usb_keyboard_send+0x36>
		{
			if ( usb_tx_packet_count( NKRO_KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    3936:	2002      	movs	r0, #2
    3938:	e7f2      	b.n	3920 <usb_keyboard_send+0x1c>
				tx_packet = usb_malloc();
				if ( tx_packet )
					break;
			}
		}
		else if ( USBKeys_Changed &
    393a:	4b92      	ldr	r3, [pc, #584]	; (3b84 <usb_keyboard_send+0x280>)
    393c:	781b      	ldrb	r3, [r3, #0]
    393e:	f013 0f60 	tst.w	r3, #96	; 0x60
    3942:	d0f1      	beq.n	3928 <usb_keyboard_send+0x24>
			( USBKeyChangeState_System | USBKeyChangeState_Consumer )
		)
		{
			if ( usb_tx_packet_count( SYS_CTRL_ENDPOINT ) < TX_PACKET_LIMIT )
    3944:	2008      	movs	r0, #8
    3946:	e7eb      	b.n	3920 <usb_keyboard_send+0x1c>
			{
				tx_packet = usb_malloc();
    3948:	f000 f93e 	bl	3bc8 <usb_malloc>
				if ( tx_packet )
    394c:	4604      	mov	r4, r0
    394e:	2800      	cmp	r0, #0
    3950:	d0ea      	beq.n	3928 <usb_keyboard_send+0x24>
    3952:	e00b      	b.n	396c <usb_keyboard_send+0x68>
					break;
			}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
    3954:	781a      	ldrb	r2, [r3, #0]
    3956:	b132      	cbz	r2, 3966 <usb_keyboard_send+0x62>
		{
			transmit_previous_timeout = 1;
    3958:	2201      	movs	r2, #1
			warn_print("USB Transmit Timeout...");
    395a:	488b      	ldr	r0, [pc, #556]	; (3b88 <usb_keyboard_send+0x284>)
			}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
		{
			transmit_previous_timeout = 1;
    395c:	701a      	strb	r2, [r3, #0]

		break;
	}

	return;
}
    395e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		}

		if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
		{
			transmit_previous_timeout = 1;
			warn_print("USB Transmit Timeout...");
    3962:	f000 be0d 	b.w	4580 <_print>
			return;
		}
		yield();
    3966:	f7fd fcea 	bl	133e <yield>
	}
    396a:	e7cf      	b.n	390c <usb_keyboard_send+0x8>

	// Pointer to USB tx packet buffer
	uint8_t *tx_buf = tx_packet->buf;

	// Check system control keys
	if ( USBKeys_Changed & USBKeyChangeState_System )
    396c:	4d85      	ldr	r5, [pc, #532]	; (3b84 <usb_keyboard_send+0x280>)
    396e:	782b      	ldrb	r3, [r5, #0]
    3970:	069a      	lsls	r2, r3, #26
    3972:	d51a      	bpl.n	39aa <usb_keyboard_send+0xa6>
	{
		if ( Output_DebugMode )
    3974:	4b85      	ldr	r3, [pc, #532]	; (3b8c <usb_keyboard_send+0x288>)
    3976:	4e86      	ldr	r6, [pc, #536]	; (3b90 <usb_keyboard_send+0x28c>)
    3978:	781b      	ldrb	r3, [r3, #0]
    397a:	b14b      	cbz	r3, 3990 <usb_keyboard_send+0x8c>
		{
			print("SysCtrl[");
    397c:	4885      	ldr	r0, [pc, #532]	; (3b94 <usb_keyboard_send+0x290>)
    397e:	f000 fdff 	bl	4580 <_print>
			printHex_op( USBKeys_SysCtrl, 2 );
    3982:	7830      	ldrb	r0, [r6, #0]
    3984:	2102      	movs	r1, #2
    3986:	f000 fe84 	bl	4692 <printHex_op>
			print( "] " NL );
    398a:	4883      	ldr	r0, [pc, #524]	; (3b98 <usb_keyboard_send+0x294>)
    398c:	f000 fdf8 	bl	4580 <_print>
		}

		*tx_buf++ = 0x02; // ID
    3990:	2302      	movs	r3, #2
		*tx_buf   = USBKeys_SysCtrl;
    3992:	7832      	ldrb	r2, [r6, #0]
			print("SysCtrl[");
			printHex_op( USBKeys_SysCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x02; // ID
    3994:	7223      	strb	r3, [r4, #8]
		*tx_buf   = USBKeys_SysCtrl;
		tx_packet->len = 2;
    3996:	8023      	strh	r3, [r4, #0]
			printHex_op( USBKeys_SysCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x02; // ID
		*tx_buf   = USBKeys_SysCtrl;
    3998:	7262      	strb	r2, [r4, #9]
		tx_packet->len = 2;

		// Send USB Packet
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    399a:	2008      	movs	r0, #8
    399c:	4621      	mov	r1, r4
    399e:	f7ff fb73 	bl	3088 <usb_tx>
		USBKeys_Changed &= ~USBKeyChangeState_System; // Mark sent
    39a2:	782b      	ldrb	r3, [r5, #0]
    39a4:	f023 0320 	bic.w	r3, r3, #32
    39a8:	e0e0      	b.n	3b6c <usb_keyboard_send+0x268>
		return;
	}

	// Check consumer control keys
	if ( USBKeys_Changed & USBKeyChangeState_Consumer )
    39aa:	065b      	lsls	r3, r3, #25
    39ac:	d51c      	bpl.n	39e8 <usb_keyboard_send+0xe4>
	{
		if ( Output_DebugMode )
    39ae:	4b77      	ldr	r3, [pc, #476]	; (3b8c <usb_keyboard_send+0x288>)
    39b0:	4e7a      	ldr	r6, [pc, #488]	; (3b9c <usb_keyboard_send+0x298>)
    39b2:	781b      	ldrb	r3, [r3, #0]
    39b4:	b14b      	cbz	r3, 39ca <usb_keyboard_send+0xc6>
		{
			print("ConsCtrl[");
    39b6:	487a      	ldr	r0, [pc, #488]	; (3ba0 <usb_keyboard_send+0x29c>)
    39b8:	f000 fde2 	bl	4580 <_print>
			printHex_op( USBKeys_ConsCtrl, 2 );
    39bc:	8830      	ldrh	r0, [r6, #0]
    39be:	2102      	movs	r1, #2
    39c0:	f000 fe67 	bl	4692 <printHex_op>
			print( "] " NL );
    39c4:	4874      	ldr	r0, [pc, #464]	; (3b98 <usb_keyboard_send+0x294>)
    39c6:	f000 fddb 	bl	4580 <_print>
		}

		*tx_buf++ = 0x03; // ID
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
    39ca:	8832      	ldrh	r2, [r6, #0]
    39cc:	7262      	strb	r2, [r4, #9]
			print("ConsCtrl[");
			printHex_op( USBKeys_ConsCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x03; // ID
    39ce:	2303      	movs	r3, #3
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
		*tx_buf   = (uint8_t)(USBKeys_ConsCtrl >> 8);
    39d0:	0a12      	lsrs	r2, r2, #8
			print("ConsCtrl[");
			printHex_op( USBKeys_ConsCtrl, 2 );
			print( "] " NL );
		}

		*tx_buf++ = 0x03; // ID
    39d2:	7223      	strb	r3, [r4, #8]
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
		*tx_buf   = (uint8_t)(USBKeys_ConsCtrl >> 8);
		tx_packet->len = 3;
    39d4:	8023      	strh	r3, [r4, #0]
			print( "] " NL );
		}

		*tx_buf++ = 0x03; // ID
		*tx_buf++ = (uint8_t)(USBKeys_ConsCtrl & 0x00FF);
		*tx_buf   = (uint8_t)(USBKeys_ConsCtrl >> 8);
    39d6:	72a2      	strb	r2, [r4, #10]
		tx_packet->len = 3;

		// Send USB Packet
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    39d8:	2008      	movs	r0, #8
    39da:	4621      	mov	r1, r4
    39dc:	f7ff fb54 	bl	3088 <usb_tx>
		USBKeys_Changed &= ~USBKeyChangeState_Consumer; // Mark sent
    39e0:	782b      	ldrb	r3, [r5, #0]
    39e2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    39e6:	e0c1      	b.n	3b6c <usb_keyboard_send+0x268>
		return;
	}

	switch ( USBKeys_Protocol )
    39e8:	7833      	ldrb	r3, [r6, #0]
    39ea:	f003 06ff 	and.w	r6, r3, #255	; 0xff
    39ee:	b11b      	cbz	r3, 39f8 <usb_keyboard_send+0xf4>
    39f0:	2e01      	cmp	r6, #1
    39f2:	d045      	beq.n	3a80 <usb_keyboard_send+0x17c>
    39f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	{
	// Send boot keyboard interrupt packet(s)
	case 0:
		// USB Boot Mode debug output
		if ( Output_DebugMode )
    39f8:	4b64      	ldr	r3, [pc, #400]	; (3b8c <usb_keyboard_send+0x288>)
    39fa:	4f6a      	ldr	r7, [pc, #424]	; (3ba4 <usb_keyboard_send+0x2a0>)
    39fc:	781b      	ldrb	r3, [r3, #0]
    39fe:	b363      	cbz	r3, 3a5a <usb_keyboard_send+0x156>
		{
			dbug_msg("Boot USB: ");
    3a00:	4869      	ldr	r0, [pc, #420]	; (3ba8 <usb_keyboard_send+0x2a4>)
    3a02:	f000 fdbd 	bl	4580 <_print>
			printHex_op( USBKeys_Modifiers, 2 );
    3a06:	2102      	movs	r1, #2
    3a08:	7838      	ldrb	r0, [r7, #0]
    3a0a:	f000 fe42 	bl	4692 <printHex_op>
			print(" ");
    3a0e:	4867      	ldr	r0, [pc, #412]	; (3bac <usb_keyboard_send+0x2a8>)
    3a10:	f000 fdb6 	bl	4580 <_print>
			printHex( 0 );
    3a14:	4630      	mov	r0, r6
    3a16:	2101      	movs	r1, #1
			print(" ");
			printHex_op( USBKeys_Keys[0], 2 );
    3a18:	4e65      	ldr	r6, [pc, #404]	; (3bb0 <usb_keyboard_send+0x2ac>)
		if ( Output_DebugMode )
		{
			dbug_msg("Boot USB: ");
			printHex_op( USBKeys_Modifiers, 2 );
			print(" ");
			printHex( 0 );
    3a1a:	f000 fe3a 	bl	4692 <printHex_op>
			print(" ");
    3a1e:	4863      	ldr	r0, [pc, #396]	; (3bac <usb_keyboard_send+0x2a8>)
    3a20:	f000 fdae 	bl	4580 <_print>
			printHex_op( USBKeys_Keys[0], 2 );
    3a24:	7830      	ldrb	r0, [r6, #0]
    3a26:	2102      	movs	r1, #2
    3a28:	f000 fe33 	bl	4692 <printHex_op>
			printHex_op( USBKeys_Keys[1], 2 );
    3a2c:	7870      	ldrb	r0, [r6, #1]
    3a2e:	2102      	movs	r1, #2
    3a30:	f000 fe2f 	bl	4692 <printHex_op>
			printHex_op( USBKeys_Keys[2], 2 );
    3a34:	78b0      	ldrb	r0, [r6, #2]
    3a36:	2102      	movs	r1, #2
    3a38:	f000 fe2b 	bl	4692 <printHex_op>
			printHex_op( USBKeys_Keys[3], 2 );
    3a3c:	78f0      	ldrb	r0, [r6, #3]
    3a3e:	2102      	movs	r1, #2
    3a40:	f000 fe27 	bl	4692 <printHex_op>
			printHex_op( USBKeys_Keys[4], 2 );
    3a44:	7930      	ldrb	r0, [r6, #4]
    3a46:	2102      	movs	r1, #2
    3a48:	f000 fe23 	bl	4692 <printHex_op>
			printHex_op( USBKeys_Keys[5], 2 );
    3a4c:	7970      	ldrb	r0, [r6, #5]
    3a4e:	2102      	movs	r1, #2
    3a50:	f000 fe1f 	bl	4692 <printHex_op>
			print( NL );
    3a54:	4857      	ldr	r0, [pc, #348]	; (3bb4 <usb_keyboard_send+0x2b0>)
    3a56:	f000 fd93 	bl	4580 <_print>
		}

		// Boot Mode
		*tx_buf++ = USBKeys_Modifiers;
    3a5a:	783b      	ldrb	r3, [r7, #0]
    3a5c:	7223      	strb	r3, [r4, #8]
		*tx_buf++ = 0;
    3a5e:	2600      	movs	r6, #0
		memcpy( tx_buf, USBKeys_Keys, USB_BOOT_MAX_KEYS );
    3a60:	4953      	ldr	r1, [pc, #332]	; (3bb0 <usb_keyboard_send+0x2ac>)
			print( NL );
		}

		// Boot Mode
		*tx_buf++ = USBKeys_Modifiers;
		*tx_buf++ = 0;
    3a62:	7266      	strb	r6, [r4, #9]
		memcpy( tx_buf, USBKeys_Keys, USB_BOOT_MAX_KEYS );
    3a64:	2206      	movs	r2, #6
    3a66:	f104 000a 	add.w	r0, r4, #10
    3a6a:	f7fd fc5f 	bl	132c <memcpy>
		tx_packet->len = 8;
    3a6e:	2308      	movs	r3, #8
    3a70:	8023      	strh	r3, [r4, #0]

		// Send USB Packet
		usb_tx( KEYBOARD_ENDPOINT, tx_packet );
    3a72:	2001      	movs	r0, #1
    3a74:	4621      	mov	r1, r4
    3a76:	f7ff fb07 	bl	3088 <usb_tx>
		USBKeys_Changed = USBKeyChangeState_None;
    3a7a:	702e      	strb	r6, [r5, #0]
		break;
    3a7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	// Send NKRO keyboard interrupts packet(s)
	case 1:
		if ( Output_DebugMode )
    3a80:	4b42      	ldr	r3, [pc, #264]	; (3b8c <usb_keyboard_send+0x288>)
    3a82:	781a      	ldrb	r2, [r3, #0]
    3a84:	461e      	mov	r6, r3
    3a86:	b112      	cbz	r2, 3a8e <usb_keyboard_send+0x18a>
		{
			dbug_msg("NKRO USB: ");
    3a88:	484b      	ldr	r0, [pc, #300]	; (3bb8 <usb_keyboard_send+0x2b4>)
    3a8a:	f000 fd79 	bl	4580 <_print>
		}

		// Standard HID Keyboard
		if ( USBKeys_Changed )
    3a8e:	782b      	ldrb	r3, [r5, #0]
    3a90:	2b00      	cmp	r3, #0
    3a92:	d06c      	beq.n	3b6e <usb_keyboard_send+0x26a>
		{
			// USB NKRO Debug output
			if ( Output_DebugMode )
    3a94:	7833      	ldrb	r3, [r6, #0]
    3a96:	4f43      	ldr	r7, [pc, #268]	; (3ba4 <usb_keyboard_send+0x2a0>)
    3a98:	2b00      	cmp	r3, #0
    3a9a:	d036      	beq.n	3b0a <usb_keyboard_send+0x206>
			{
				printHex_op( USBKeys_Modifiers, 2 );
    3a9c:	7838      	ldrb	r0, [r7, #0]
    3a9e:	2102      	movs	r1, #2
    3aa0:	f000 fdf7 	bl	4692 <printHex_op>
				print(" ");
    3aa4:	4841      	ldr	r0, [pc, #260]	; (3bac <usb_keyboard_send+0x2a8>)
    3aa6:	f000 fd6b 	bl	4580 <_print>
    3aaa:	2600      	movs	r6, #0
				for ( uint8_t c = 0; c < 6; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
    3aac:	f8df 8100 	ldr.w	r8, [pc, #256]	; 3bb0 <usb_keyboard_send+0x2ac>
    3ab0:	2102      	movs	r1, #2
    3ab2:	f818 0006 	ldrb.w	r0, [r8, r6]
    3ab6:	3601      	adds	r6, #1
    3ab8:	f000 fdeb 	bl	4692 <printHex_op>
			// USB NKRO Debug output
			if ( Output_DebugMode )
			{
				printHex_op( USBKeys_Modifiers, 2 );
				print(" ");
				for ( uint8_t c = 0; c < 6; c++ )
    3abc:	2e06      	cmp	r6, #6
    3abe:	d1f5      	bne.n	3aac <usb_keyboard_send+0x1a8>
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
    3ac0:	483a      	ldr	r0, [pc, #232]	; (3bac <usb_keyboard_send+0x2a8>)
    3ac2:	f000 fd5d 	bl	4580 <_print>
    3ac6:	2600      	movs	r6, #0
    3ac8:	eb08 0306 	add.w	r3, r8, r6
				for ( uint8_t c = 6; c < 20; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
    3acc:	2102      	movs	r1, #2
    3ace:	7998      	ldrb	r0, [r3, #6]
    3ad0:	3601      	adds	r6, #1
    3ad2:	f000 fdde 	bl	4692 <printHex_op>
				printHex_op( USBKeys_Modifiers, 2 );
				print(" ");
				for ( uint8_t c = 0; c < 6; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
				for ( uint8_t c = 6; c < 20; c++ )
    3ad6:	2e0e      	cmp	r6, #14
    3ad8:	d1f6      	bne.n	3ac8 <usb_keyboard_send+0x1c4>
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
    3ada:	4834      	ldr	r0, [pc, #208]	; (3bac <usb_keyboard_send+0x2a8>)
    3adc:	f000 fd50 	bl	4580 <_print>
				printHex_op( USBKeys_Keys[20], 2 );
    3ae0:	4b33      	ldr	r3, [pc, #204]	; (3bb0 <usb_keyboard_send+0x2ac>)
    3ae2:	2102      	movs	r1, #2
    3ae4:	7d18      	ldrb	r0, [r3, #20]
    3ae6:	f000 fdd4 	bl	4692 <printHex_op>
				print(" ");
    3aea:	4830      	ldr	r0, [pc, #192]	; (3bac <usb_keyboard_send+0x2a8>)
    3aec:	f000 fd48 	bl	4580 <_print>
    3af0:	2600      	movs	r6, #0
    3af2:	eb08 0306 	add.w	r3, r8, r6
				for ( uint8_t c = 21; c < 27; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
    3af6:	2102      	movs	r1, #2
    3af8:	7d58      	ldrb	r0, [r3, #21]
    3afa:	3601      	adds	r6, #1
    3afc:	f000 fdc9 	bl	4692 <printHex_op>
				for ( uint8_t c = 6; c < 20; c++ )
					printHex_op( USBKeys_Keys[ c ], 2 );
				print(" ");
				printHex_op( USBKeys_Keys[20], 2 );
				print(" ");
				for ( uint8_t c = 21; c < 27; c++ )
    3b00:	2e06      	cmp	r6, #6
    3b02:	d1f6      	bne.n	3af2 <usb_keyboard_send+0x1ee>
					printHex_op( USBKeys_Keys[ c ], 2 );
				print( NL );
    3b04:	482b      	ldr	r0, [pc, #172]	; (3bb4 <usb_keyboard_send+0x2b0>)
    3b06:	f000 fd3b 	bl	4580 <_print>
			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
			*tx_buf++ = USBKeys_Modifiers;
			tx_packet->len += 2;
    3b0a:	4620      	mov	r0, r4

			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
			*tx_buf++ = USBKeys_Modifiers;
    3b0c:	783b      	ldrb	r3, [r7, #0]
    3b0e:	7263      	strb	r3, [r4, #9]
			}

			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
    3b10:	f04f 0801 	mov.w	r8, #1
			*tx_buf++ = USBKeys_Modifiers;
			tx_packet->len += 2;
    3b14:	2602      	movs	r6, #2
			}

			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
    3b16:	f884 8008 	strb.w	r8, [r4, #8]
			*tx_buf++ = USBKeys_Modifiers;
			tx_packet->len += 2;

			// 4-49 (first 6 bytes)
			memcpy( tx_buf, USBKeys_Keys, 6 );
    3b1a:	4925      	ldr	r1, [pc, #148]	; (3bb0 <usb_keyboard_send+0x2ac>)
			tx_packet->len = 0;

			// Modifiers
			*tx_buf++ = 0x01; // ID
			*tx_buf++ = USBKeys_Modifiers;
			tx_packet->len += 2;
    3b1c:	f820 6b0a 	strh.w	r6, [r0], #10

			// 4-49 (first 6 bytes)
			memcpy( tx_buf, USBKeys_Keys, 6 );
    3b20:	2206      	movs	r2, #6
    3b22:	f7fd fc03 	bl	132c <memcpy>
			tx_buf += 6;
			tx_packet->len += 6;
    3b26:	8822      	ldrh	r2, [r4, #0]

			// 51-155 (Middle 14 bytes)
			memcpy( tx_buf, USBKeys_Keys + 6, 14 );
    3b28:	4924      	ldr	r1, [pc, #144]	; (3bbc <usb_keyboard_send+0x2b8>)
			tx_packet->len += 2;

			// 4-49 (first 6 bytes)
			memcpy( tx_buf, USBKeys_Keys, 6 );
			tx_buf += 6;
			tx_packet->len += 6;
    3b2a:	4620      	mov	r0, r4
    3b2c:	3206      	adds	r2, #6
    3b2e:	f820 2b10 	strh.w	r2, [r0], #16

			// 51-155 (Middle 14 bytes)
			memcpy( tx_buf, USBKeys_Keys + 6, 14 );
    3b32:	220e      	movs	r2, #14
    3b34:	f7fd fbfa 	bl	132c <memcpy>
			tx_buf += 14;
			tx_packet->len += 14;
    3b38:	8822      	ldrh	r2, [r4, #0]

			// 157-164 (Next byte)
			memcpy( tx_buf, USBKeys_Keys + 20, 1 );
    3b3a:	4921      	ldr	r1, [pc, #132]	; (3bc0 <usb_keyboard_send+0x2bc>)
			tx_packet->len += 6;

			// 51-155 (Middle 14 bytes)
			memcpy( tx_buf, USBKeys_Keys + 6, 14 );
			tx_buf += 14;
			tx_packet->len += 14;
    3b3c:	4620      	mov	r0, r4
    3b3e:	320e      	adds	r2, #14
    3b40:	f820 2b1e 	strh.w	r2, [r0], #30

			// 157-164 (Next byte)
			memcpy( tx_buf, USBKeys_Keys + 20, 1 );
    3b44:	4642      	mov	r2, r8
    3b46:	f7fd fbf1 	bl	132c <memcpy>
			tx_buf += 1;
			tx_packet->len += 1;
    3b4a:	8822      	ldrh	r2, [r4, #0]

			// 176-221 (last 6 bytes)
			memcpy( tx_buf, USBKeys_Keys + 21, 6 );
    3b4c:	491d      	ldr	r1, [pc, #116]	; (3bc4 <usb_keyboard_send+0x2c0>)
			tx_packet->len += 14;

			// 157-164 (Next byte)
			memcpy( tx_buf, USBKeys_Keys + 20, 1 );
			tx_buf += 1;
			tx_packet->len += 1;
    3b4e:	4620      	mov	r0, r4
    3b50:	4442      	add	r2, r8
    3b52:	f820 2b1f 	strh.w	r2, [r0], #31

			// 176-221 (last 6 bytes)
			memcpy( tx_buf, USBKeys_Keys + 21, 6 );
    3b56:	2206      	movs	r2, #6
    3b58:	f7fd fbe8 	bl	132c <memcpy>
			tx_packet->len += 6;
    3b5c:	8823      	ldrh	r3, [r4, #0]
    3b5e:	3306      	adds	r3, #6
    3b60:	8023      	strh	r3, [r4, #0]

			// Send USB Packet
			usb_tx( NKRO_KEYBOARD_ENDPOINT, tx_packet );
    3b62:	4630      	mov	r0, r6
    3b64:	4621      	mov	r1, r4
    3b66:	f7ff fa8f 	bl	3088 <usb_tx>
			USBKeys_Changed = USBKeyChangeState_None; // Mark sent
    3b6a:	2300      	movs	r3, #0
    3b6c:	702b      	strb	r3, [r5, #0]
    3b6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3b72:	bf00      	nop
    3b74:	1ffff2a7 	.word	0x1ffff2a7
    3b78:	00006c48 	.word	0x00006c48
    3b7c:	1fffeb81 	.word	0x1fffeb81
    3b80:	1ffff2a9 	.word	0x1ffff2a9
    3b84:	1ffff179 	.word	0x1ffff179
    3b88:	00006c75 	.word	0x00006c75
    3b8c:	1ffff17b 	.word	0x1ffff17b
    3b90:	1ffffc02 	.word	0x1ffffc02
    3b94:	00006ca4 	.word	0x00006ca4
    3b98:	00006cad 	.word	0x00006cad
    3b9c:	1ffffc3a 	.word	0x1ffffc3a
    3ba0:	00006cb2 	.word	0x00006cb2
    3ba4:	1ffff178 	.word	0x1ffff178
    3ba8:	00006cbc 	.word	0x00006cbc
    3bac:	00004a00 	.word	0x00004a00
    3bb0:	1ffffc03 	.word	0x1ffffc03
    3bb4:	00006caf 	.word	0x00006caf
    3bb8:	00006cda 	.word	0x00006cda
    3bbc:	1ffffc09 	.word	0x1ffffc09
    3bc0:	1ffffc17 	.word	0x1ffffc17
    3bc4:	1ffffc18 	.word	0x1ffffc18

00003bc8 <usb_malloc>:
usb_packet_t *usb_malloc()
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    3bc8:	b672      	cpsid	i
	avail = usb_buffer_available;
    3bca:	4a0c      	ldr	r2, [pc, #48]	; (3bfc <usb_malloc+0x34>)
    3bcc:	6811      	ldr	r1, [r2, #0]
	n = __builtin_clz( avail ); // clz = count leading zeros
    3bce:	fab1 f381 	clz	r3, r1
	if ( n >= NUM_USB_BUFFERS )
    3bd2:	2b1d      	cmp	r3, #29
    3bd4:	d902      	bls.n	3bdc <usb_malloc+0x14>
	{
		__enable_irq();
    3bd6:	b662      	cpsie	i
		return NULL;
    3bd8:	2000      	movs	r0, #0
    3bda:	4770      	bx	lr
	}

	usb_buffer_available = avail & ~(0x80000000 >> n);
    3bdc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    3be0:	40d8      	lsrs	r0, r3
    3be2:	ea21 0100 	bic.w	r1, r1, r0
    3be6:	6011      	str	r1, [r2, #0]
	__enable_irq();
    3be8:	b662      	cpsie	i
	p = usb_buffer_memory + ( n * sizeof(usb_packet_t) );
    3bea:	4905      	ldr	r1, [pc, #20]	; (3c00 <usb_malloc+0x38>)
    3bec:	2248      	movs	r2, #72	; 0x48
    3bee:	4353      	muls	r3, r2
    3bf0:	18c8      	adds	r0, r1, r3
	*(uint32_t *)p = 0;
    3bf2:	2200      	movs	r2, #0
    3bf4:	50ca      	str	r2, [r1, r3]
	*(uint32_t *)(p + 4) = 0;
    3bf6:	6042      	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    3bf8:	4770      	bx	lr
    3bfa:	bf00      	nop
    3bfc:	1fffefc0 	.word	0x1fffefc0
    3c00:	1fffe120 	.word	0x1fffe120

00003c04 <usb_free>:

void usb_free( usb_packet_t *p )
{
	unsigned int n, mask;

	n = ( (uint8_t *)p - usb_buffer_memory ) / sizeof(usb_packet_t);
    3c04:	4b0c      	ldr	r3, [pc, #48]	; (3c38 <usb_free+0x34>)
    3c06:	2248      	movs	r2, #72	; 0x48
    3c08:	1ac3      	subs	r3, r0, r3
    3c0a:	fbb3 f3f2 	udiv	r3, r3, r2
	if ( n >= NUM_USB_BUFFERS )
    3c0e:	2b1d      	cmp	r3, #29
    3c10:	d811      	bhi.n	3c36 <usb_free+0x32>
		return;

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if ( usb_rx_memory_needed && usb_configuration )
    3c12:	4a0a      	ldr	r2, [pc, #40]	; (3c3c <usb_free+0x38>)
    3c14:	7812      	ldrb	r2, [r2, #0]
    3c16:	b122      	cbz	r2, 3c22 <usb_free+0x1e>
    3c18:	4a09      	ldr	r2, [pc, #36]	; (3c40 <usb_free+0x3c>)
    3c1a:	7812      	ldrb	r2, [r2, #0]
    3c1c:	b10a      	cbz	r2, 3c22 <usb_free+0x1e>
	{
		usb_rx_memory( p );
    3c1e:	f7ff b9f7 	b.w	3010 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    3c22:	b672      	cpsid	i
	usb_buffer_available |= mask;
    3c24:	4a07      	ldr	r2, [pc, #28]	; (3c44 <usb_free+0x40>)
	{
		usb_rx_memory( p );
		return;
	}

	mask = (0x80000000 >> n);
    3c26:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    3c2a:	fa21 f303 	lsr.w	r3, r1, r3
	__disable_irq();
	usb_buffer_available |= mask;
    3c2e:	6811      	ldr	r1, [r2, #0]
    3c30:	4319      	orrs	r1, r3
    3c32:	6011      	str	r1, [r2, #0]
	__enable_irq();
    3c34:	b662      	cpsie	i
    3c36:	4770      	bx	lr
    3c38:	1fffe120 	.word	0x1fffe120
    3c3c:	1ffff29e 	.word	0x1ffff29e
    3c40:	1ffff2a7 	.word	0x1ffff2a7
    3c44:	1fffefc0 	.word	0x1fffefc0

00003c48 <usb_serial_getchar>:

// ----- Functions -----

// get the next character, or -1 if nothing received
int usb_serial_getchar()
{
    3c48:	b510      	push	{r4, lr}
	unsigned int i;
	int c;

	if ( !rx_packet )
    3c4a:	4c10      	ldr	r4, [pc, #64]	; (3c8c <usb_serial_getchar+0x44>)
    3c4c:	6823      	ldr	r3, [r4, #0]
    3c4e:	b16b      	cbz	r3, 3c6c <usb_serial_getchar+0x24>
			return -1;
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
		if ( !rx_packet )
			return -1;
	}
	i = rx_packet->index;
    3c50:	6820      	ldr	r0, [r4, #0]
    3c52:	8842      	ldrh	r2, [r0, #2]
	c = rx_packet->buf[i++];
    3c54:	1c53      	adds	r3, r2, #1
    3c56:	4402      	add	r2, r0
    3c58:	7a14      	ldrb	r4, [r2, #8]
	if ( i >= rx_packet->len )
    3c5a:	8802      	ldrh	r2, [r0, #0]
    3c5c:	4293      	cmp	r3, r2
    3c5e:	d312      	bcc.n	3c86 <usb_serial_getchar+0x3e>
	{
		usb_free( rx_packet );
    3c60:	f7ff ffd0 	bl	3c04 <usb_free>
		rx_packet = NULL;
    3c64:	4b09      	ldr	r3, [pc, #36]	; (3c8c <usb_serial_getchar+0x44>)
    3c66:	2200      	movs	r2, #0
    3c68:	601a      	str	r2, [r3, #0]
    3c6a:	e00d      	b.n	3c88 <usb_serial_getchar+0x40>
	unsigned int i;
	int c;

	if ( !rx_packet )
	{
		if ( !usb_configuration )
    3c6c:	4b08      	ldr	r3, [pc, #32]	; (3c90 <usb_serial_getchar+0x48>)
    3c6e:	781b      	ldrb	r3, [r3, #0]
    3c70:	b913      	cbnz	r3, 3c78 <usb_serial_getchar+0x30>
			return -1;
    3c72:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    3c76:	bd10      	pop	{r4, pc}
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
    3c78:	2004      	movs	r0, #4
    3c7a:	f7ff f99b 	bl	2fb4 <usb_rx>
    3c7e:	6020      	str	r0, [r4, #0]
		if ( !rx_packet )
    3c80:	2800      	cmp	r0, #0
    3c82:	d1e5      	bne.n	3c50 <usb_serial_getchar+0x8>
    3c84:	e7f5      	b.n	3c72 <usb_serial_getchar+0x2a>
		usb_free( rx_packet );
		rx_packet = NULL;
	}
	else
	{
		rx_packet->index = i;
    3c86:	8043      	strh	r3, [r0, #2]
	}
	return c;
    3c88:	4620      	mov	r0, r4
}
    3c8a:	bd10      	pop	{r4, pc}
    3c8c:	1ffff2b4 	.word	0x1ffff2b4
    3c90:	1ffff2a7 	.word	0x1ffff2a7

00003c94 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
		return 0;
	return usb_rx_byte_count_data[ endpoint ];
    3c94:	4b04      	ldr	r3, [pc, #16]	; (3ca8 <usb_serial_available+0x14>)
}

// number of bytes available in the receive buffer
int usb_serial_available()
{
	int count = usb_rx_byte_count( CDC_RX_ENDPOINT );
    3c96:	88d8      	ldrh	r0, [r3, #6]
	if ( rx_packet )
    3c98:	4b04      	ldr	r3, [pc, #16]	; (3cac <usb_serial_available+0x18>)
    3c9a:	681b      	ldr	r3, [r3, #0]
    3c9c:	b11b      	cbz	r3, 3ca6 <usb_serial_available+0x12>
		count += rx_packet->len - rx_packet->index;
    3c9e:	881a      	ldrh	r2, [r3, #0]
    3ca0:	885b      	ldrh	r3, [r3, #2]
    3ca2:	1ad3      	subs	r3, r2, r3
    3ca4:	4418      	add	r0, r3
	return count;
}
    3ca6:	4770      	bx	lr
    3ca8:	1ffffc3c 	.word	0x1ffffc3c
    3cac:	1ffff2b4 	.word	0x1ffff2b4

00003cb0 <usb_serial_write>:
{
	return usb_serial_write( &c, 1 );
}

int usb_serial_write( const void *buffer, uint32_t size )
{
    3cb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    3cb4:	4e2d      	ldr	r6, [pc, #180]	; (3d6c <usb_serial_write+0xbc>)
    3cb6:	2301      	movs	r3, #1
{
	return usb_serial_write( &c, 1 );
}

int usb_serial_write( const void *buffer, uint32_t size )
{
    3cb8:	4607      	mov	r7, r0
    3cba:	460c      	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    3cbc:	7033      	strb	r3, [r6, #0]
	while ( size > 0 )
    3cbe:	2c00      	cmp	r4, #0
    3cc0:	d04f      	beq.n	3d62 <usb_serial_write+0xb2>
	{
		if ( !tx_packet )
    3cc2:	4d2b      	ldr	r5, [pc, #172]	; (3d70 <usb_serial_write+0xc0>)
    3cc4:	682b      	ldr	r3, [r5, #0]
    3cc6:	46a9      	mov	r9, r5
    3cc8:	bb2b      	cbnz	r3, 3d16 <usb_serial_write+0x66>
    3cca:	f247 5809 	movw	r8, #29961	; 0x7509
		{
			wait_count = 0;
			while ( 1 )
			{
				if ( !usb_configuration )
    3cce:	4b29      	ldr	r3, [pc, #164]	; (3d74 <usb_serial_write+0xc4>)
    3cd0:	781b      	ldrb	r3, [r3, #0]
    3cd2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    3cd6:	b90b      	cbnz	r3, 3cdc <usb_serial_write+0x2c>
				{
					tx_noautoflush = 0;
    3cd8:	7032      	strb	r2, [r6, #0]
    3cda:	e015      	b.n	3d08 <usb_serial_write+0x58>
					return -1;
				}
				if ( usb_tx_packet_count( CDC_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    3cdc:	2005      	movs	r0, #5
    3cde:	f7ff f985 	bl	2fec <usb_tx_packet_count>
    3ce2:	2807      	cmp	r0, #7
    3ce4:	d808      	bhi.n	3cf8 <usb_serial_write+0x48>
				{
					tx_noautoflush = 1;
    3ce6:	2301      	movs	r3, #1
    3ce8:	7033      	strb	r3, [r6, #0]
					tx_packet = usb_malloc();
    3cea:	f7ff ff6d 	bl	3bc8 <usb_malloc>
    3cee:	f8c9 0000 	str.w	r0, [r9]
					if ( tx_packet )
    3cf2:	b980      	cbnz	r0, 3d16 <usb_serial_write+0x66>
						break;
					tx_noautoflush = 0;
    3cf4:	4b1d      	ldr	r3, [pc, #116]	; (3d6c <usb_serial_write+0xbc>)
    3cf6:	7018      	strb	r0, [r3, #0]
				}
				if ( ++wait_count > TX_TIMEOUT || transmit_previous_timeout )
    3cf8:	f1b8 0801 	subs.w	r8, r8, #1
    3cfc:	4b1e      	ldr	r3, [pc, #120]	; (3d78 <usb_serial_write+0xc8>)
    3cfe:	d001      	beq.n	3d04 <usb_serial_write+0x54>
    3d00:	781a      	ldrb	r2, [r3, #0]
    3d02:	b12a      	cbz	r2, 3d10 <usb_serial_write+0x60>
				{
					transmit_previous_timeout = 1;
    3d04:	2201      	movs	r2, #1
    3d06:	701a      	strb	r2, [r3, #0]
					return -1;
    3d08:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    3d0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
				yield();
    3d10:	f7fd fb15 	bl	133e <yield>
			}
    3d14:	e7db      	b.n	3cce <usb_serial_write+0x1e>
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    3d16:	6829      	ldr	r1, [r5, #0]
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    3d18:	4a17      	ldr	r2, [pc, #92]	; (3d78 <usb_serial_write+0xc8>)
		len = CDC_TX_SIZE - tx_packet->index;
    3d1a:	8848      	ldrh	r0, [r1, #2]
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    3d1c:	2300      	movs	r3, #0
    3d1e:	7013      	strb	r3, [r2, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    3d20:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
    3d24:	4294      	cmp	r4, r2
    3d26:	bf38      	it	cc
    3d28:	4622      	movcc	r2, r4
		if ( len > size )
			len = size;
		dest = tx_packet->buf + tx_packet->index;
    3d2a:	f100 0c08 	add.w	ip, r0, #8
		tx_packet->index += len;
    3d2e:	4410      	add	r0, r2
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if ( len > size )
			len = size;
		dest = tx_packet->buf + tx_packet->index;
    3d30:	448c      	add	ip, r1
		tx_packet->index += len;
    3d32:	8048      	strh	r0, [r1, #2]
		size -= len;
    3d34:	1aa4      	subs	r4, r4, r2
		while ( len-- > 0 )
    3d36:	4293      	cmp	r3, r2
    3d38:	d004      	beq.n	3d44 <usb_serial_write+0x94>
			*dest++ = *src++;
    3d3a:	5cf8      	ldrb	r0, [r7, r3]
    3d3c:	f80c 0003 	strb.w	r0, [ip, r3]
    3d40:	3301      	adds	r3, #1
    3d42:	e7f8      	b.n	3d36 <usb_serial_write+0x86>
    3d44:	441f      	add	r7, r3
		if ( tx_packet->index >= CDC_TX_SIZE )
    3d46:	884b      	ldrh	r3, [r1, #2]
    3d48:	2b3f      	cmp	r3, #63	; 0x3f
    3d4a:	d906      	bls.n	3d5a <usb_serial_write+0xaa>
		{
			tx_packet->len = CDC_TX_SIZE;
    3d4c:	2340      	movs	r3, #64	; 0x40
    3d4e:	800b      	strh	r3, [r1, #0]
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
    3d50:	2005      	movs	r0, #5
    3d52:	f7ff f999 	bl	3088 <usb_tx>
			tx_packet = NULL;
    3d56:	2300      	movs	r3, #0
    3d58:	602b      	str	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    3d5a:	4b08      	ldr	r3, [pc, #32]	; (3d7c <usb_serial_write+0xcc>)
    3d5c:	2205      	movs	r2, #5
    3d5e:	701a      	strb	r2, [r3, #0]
    3d60:	e7ad      	b.n	3cbe <usb_serial_write+0xe>
	}
	tx_noautoflush = 0;
    3d62:	7034      	strb	r4, [r6, #0]
	return 0;
    3d64:	4620      	mov	r0, r4
}
    3d66:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3d6a:	bf00      	nop
    3d6c:	1ffff2ab 	.word	0x1ffff2ab
    3d70:	1ffff2ac 	.word	0x1ffff2ac
    3d74:	1ffff2a7 	.word	0x1ffff2a7
    3d78:	1ffff2b0 	.word	0x1ffff2b0
    3d7c:	1ffff2aa 	.word	0x1ffff2aa

00003d80 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback()
{
    3d80:	b538      	push	{r3, r4, r5, lr}
	if ( tx_noautoflush )
    3d82:	4b0e      	ldr	r3, [pc, #56]	; (3dbc <usb_serial_flush_callback+0x3c>)
    3d84:	781b      	ldrb	r3, [r3, #0]
    3d86:	f003 05ff 	and.w	r5, r3, #255	; 0xff
    3d8a:	b9ab      	cbnz	r3, 3db8 <usb_serial_flush_callback+0x38>
		return;
	if ( tx_packet )
    3d8c:	4c0c      	ldr	r4, [pc, #48]	; (3dc0 <usb_serial_flush_callback+0x40>)
    3d8e:	6821      	ldr	r1, [r4, #0]
    3d90:	b131      	cbz	r1, 3da0 <usb_serial_flush_callback+0x20>
	{
		tx_packet->len = tx_packet->index;
    3d92:	884b      	ldrh	r3, [r1, #2]
    3d94:	800b      	strh	r3, [r1, #0]
		usb_tx( CDC_TX_ENDPOINT, tx_packet );
    3d96:	2005      	movs	r0, #5
    3d98:	f7ff f976 	bl	3088 <usb_tx>
		tx_packet = NULL;
    3d9c:	6025      	str	r5, [r4, #0]
    3d9e:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    3da0:	f7ff ff12 	bl	3bc8 <usb_malloc>
		if ( tx )
    3da4:	4601      	mov	r1, r0
    3da6:	b120      	cbz	r0, 3db2 <usb_serial_flush_callback+0x32>
		{
			usb_tx( CDC_TX_ENDPOINT, tx );
    3da8:	2005      	movs	r0, #5
		else
		{
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    3daa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if ( tx )
		{
			usb_tx( CDC_TX_ENDPOINT, tx );
    3dae:	f7ff b96b 	b.w	3088 <usb_tx>
		}
		else
		{
			usb_cdc_transmit_flush_timer = 1;
    3db2:	4b04      	ldr	r3, [pc, #16]	; (3dc4 <usb_serial_flush_callback+0x44>)
    3db4:	2201      	movs	r2, #1
    3db6:	701a      	strb	r2, [r3, #0]
    3db8:	bd38      	pop	{r3, r4, r5, pc}
    3dba:	bf00      	nop
    3dbc:	1ffff2ab 	.word	0x1ffff2ab
    3dc0:	1ffff2ac 	.word	0x1ffff2ac
    3dc4:	1ffff2aa 	.word	0x1ffff2aa

00003dc8 <cliFunc_clear>:

// ----- CLI Command Functions -----

void cliFunc_clear( char* args)
{
	print("\033[2J\033[H\r"); // Erases the whole screen
    3dc8:	4801      	ldr	r0, [pc, #4]	; (3dd0 <cliFunc_clear+0x8>)
    3dca:	f000 bbd9 	b.w	4580 <_print>
    3dce:	bf00      	nop
    3dd0:	00006dc1 	.word	0x00006dc1

00003dd4 <cliFunc_reload>:
	CLILEDState ^= 1 << 1; // Toggle between 0 and 1
	errorLED( CLILEDState ); // Enable/Disable error LED
}

void cliFunc_reload( char* args )
{
    3dd4:	b508      	push	{r3, lr}
	if ( flashModeEnabled_define == 0 )
	{
		print( NL );
    3dd6:	4805      	ldr	r0, [pc, #20]	; (3dec <cliFunc_reload+0x18>)
    3dd8:	f000 fbd2 	bl	4580 <_print>
		warn_print("flashModeEnabled not set, cancelling firmware reload...");
    3ddc:	4804      	ldr	r0, [pc, #16]	; (3df0 <cliFunc_reload+0x1c>)
    3dde:	f000 fbcf 	bl	4580 <_print>
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    3de2:	4804      	ldr	r0, [pc, #16]	; (3df4 <cliFunc_reload+0x20>)
		return;
	}

	// Request to output module to be set into firmware reload mode
	Output_firmwareReload();
}
    3de4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	if ( flashModeEnabled_define == 0 )
	{
		print( NL );
		warn_print("flashModeEnabled not set, cancelling firmware reload...");
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    3de8:	f000 bbca 	b.w	4580 <_print>
    3dec:	00006caf 	.word	0x00006caf
    3df0:	00004eba 	.word	0x00004eba
    3df4:	00004f09 	.word	0x00004f09

00003df8 <cliFunc_reset>:
	Output_firmwareReload();
}

void cliFunc_reset( char* args )
{
	print("\033c"); // Resets the terminal
    3df8:	4801      	ldr	r0, [pc, #4]	; (3e00 <cliFunc_reset+0x8>)
    3dfa:	f000 bbc1 	b.w	4580 <_print>
    3dfe:	bf00      	nop
    3e00:	00006dca 	.word	0x00006dca

00003e04 <cliFunc_help>:
		CLIHexDebugMode = 1;
	}
}

void cliFunc_help( char* args )
{
    3e04:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	// Scan array of dictionaries and print every description
	//  (no alphabetical here, too much processing/memory to sort...)
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    3e08:	2500      	movs	r5, #0
    3e0a:	4b22      	ldr	r3, [pc, #136]	; (3e94 <cliFunc_help+0x90>)
    3e0c:	781b      	ldrb	r3, [r3, #0]
    3e0e:	b2ec      	uxtb	r4, r5
    3e10:	42a3      	cmp	r3, r4
    3e12:	d93c      	bls.n	3e8e <cliFunc_help+0x8a>
	{
		// Print the name of each dictionary as a title
		print( NL "\033[1;32m" );
    3e14:	4820      	ldr	r0, [pc, #128]	; (3e98 <cliFunc_help+0x94>)
    3e16:	f000 fbb3 	bl	4580 <_print>
		_print( CLIDictNames[dict] ); // This print is requride by AVR (flash)
    3e1a:	4b20      	ldr	r3, [pc, #128]	; (3e9c <cliFunc_help+0x98>)
    3e1c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    3e20:	f000 fbae 	bl	4580 <_print>
		print( "\033[0m" NL );
    3e24:	481e      	ldr	r0, [pc, #120]	; (3ea0 <cliFunc_help+0x9c>)
    3e26:	f000 fbab 	bl	4580 <_print>

		// Parse each cmd/description until a null command entry is found
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    3e2a:	f04f 0800 	mov.w	r8, #0
    3e2e:	4f1d      	ldr	r7, [pc, #116]	; (3ea4 <cliFunc_help+0xa0>)
    3e30:	fa5f f388 	uxtb.w	r3, r8
    3e34:	260c      	movs	r6, #12
    3e36:	435e      	muls	r6, r3
    3e38:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
    3e3c:	5999      	ldr	r1, [r3, r6]
    3e3e:	b321      	cbz	r1, 3e8a <cliFunc_help+0x86>
		{
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    3e40:	4819      	ldr	r0, [pc, #100]	; (3ea8 <cliFunc_help+0xa4>)
    3e42:	4a1a      	ldr	r2, [pc, #104]	; (3eac <cliFunc_help+0xa8>)
    3e44:	4b1a      	ldr	r3, [pc, #104]	; (3eb0 <cliFunc_help+0xac>)
    3e46:	f000 fb81 	bl	454c <printstrs>

			// Determine number of spaces to tab by the length of the command and TabAlign
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    3e4a:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
    3e4e:	5998      	ldr	r0, [r3, r6]
    3e50:	f000 fb98 	bl	4584 <lenStr>
    3e54:	f1c0 000d 	rsb	r0, r0, #13
    3e58:	fa5f f980 	uxtb.w	r9, r0
			while ( padLength-- > 0 )
    3e5c:	f1b9 0f00 	cmp.w	r9, #0
    3e60:	d007      	beq.n	3e72 <cliFunc_help+0x6e>
				print(" ");
    3e62:	4814      	ldr	r0, [pc, #80]	; (3eb4 <cliFunc_help+0xb0>)
    3e64:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    3e68:	f000 fb8a 	bl	4580 <_print>
    3e6c:	fa5f f989 	uxtb.w	r9, r9
    3e70:	e7f4      	b.n	3e5c <cliFunc_help+0x58>

			_print( CLIDict[dict][cmd].description ); // This print is required by AVR (flash)
    3e72:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
    3e76:	441e      	add	r6, r3
    3e78:	f108 0801 	add.w	r8, r8, #1
    3e7c:	6870      	ldr	r0, [r6, #4]
    3e7e:	f000 fb7f 	bl	4580 <_print>
			print( NL );
    3e82:	480d      	ldr	r0, [pc, #52]	; (3eb8 <cliFunc_help+0xb4>)
    3e84:	f000 fb7c 	bl	4580 <_print>
    3e88:	e7d1      	b.n	3e2e <cliFunc_help+0x2a>
    3e8a:	3501      	adds	r5, #1
    3e8c:	e7bd      	b.n	3e0a <cliFunc_help+0x6>
		}
	}
}
    3e8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3e92:	bf00      	nop
    3e94:	1ffff2bf 	.word	0x1ffff2bf
    3e98:	00006dcd 	.word	0x00006dcd
    3e9c:	1ffff73c 	.word	0x1ffff73c
    3ea0:	00006dd7 	.word	0x00006dd7
    3ea4:	1ffff710 	.word	0x1ffff710
    3ea8:	00006dde 	.word	0x00006dde
    3eac:	00005033 	.word	0x00005033
    3eb0:	00006cf8 	.word	0x00006cf8
    3eb4:	00004a00 	.word	0x00004a00
    3eb8:	00006caf 	.word	0x00006caf

00003ebc <cliFunc_led>:

void cliFunc_led( char* args )
{
	CLILEDState ^= 1 << 1; // Toggle between 0 and 1
    3ebc:	4b03      	ldr	r3, [pc, #12]	; (3ecc <cliFunc_led+0x10>)
    3ebe:	7818      	ldrb	r0, [r3, #0]
    3ec0:	f080 0002 	eor.w	r0, r0, #2
    3ec4:	7018      	strb	r0, [r3, #0]
	errorLED( CLILEDState ); // Enable/Disable error LED
    3ec6:	f000 bb33 	b.w	4530 <errorLED>
    3eca:	bf00      	nop
    3ecc:	1ffff2be 	.word	0x1ffff2be

00003ed0 <cliFunc_restart>:
}

void cliFunc_restart( char* args )
{
	// Trigger an overall software reset
	Output_softReset();
    3ed0:	f7ff b848 	b.w	2f64 <Output_softReset>

00003ed4 <cliFunc_version>:
}

void cliFunc_version( char* args )
{
    3ed4:	b508      	push	{r3, lr}
	print( NL );
    3ed6:	4821      	ldr	r0, [pc, #132]	; (3f5c <cliFunc_version+0x88>)
    3ed8:	f000 fb52 	bl	4580 <_print>
	print( " \033[1mRevision:\033[0m      " CLI_Revision       NL );
    3edc:	4820      	ldr	r0, [pc, #128]	; (3f60 <cliFunc_version+0x8c>)
    3ede:	f000 fb4f 	bl	4580 <_print>
	print( " \033[1mBranch:\033[0m        " CLI_Branch         NL );
    3ee2:	4820      	ldr	r0, [pc, #128]	; (3f64 <cliFunc_version+0x90>)
    3ee4:	f000 fb4c 	bl	4580 <_print>
	print( " \033[1mTree Status:\033[0m   " CLI_ModifiedStatus CLI_ModifiedFiles NL );
    3ee8:	481f      	ldr	r0, [pc, #124]	; (3f68 <cliFunc_version+0x94>)
    3eea:	f000 fb49 	bl	4580 <_print>
	print( " \033[1mRepo Origin:\033[0m   " CLI_RepoOrigin     NL );
    3eee:	481f      	ldr	r0, [pc, #124]	; (3f6c <cliFunc_version+0x98>)
    3ef0:	f000 fb46 	bl	4580 <_print>
	print( " \033[1mCommit Date:\033[0m   " CLI_CommitDate     NL );
    3ef4:	481e      	ldr	r0, [pc, #120]	; (3f70 <cliFunc_version+0x9c>)
    3ef6:	f000 fb43 	bl	4580 <_print>
	print( " \033[1mCommit Author:\033[0m " CLI_CommitAuthor   NL );
    3efa:	481e      	ldr	r0, [pc, #120]	; (3f74 <cliFunc_version+0xa0>)
    3efc:	f000 fb40 	bl	4580 <_print>
	print( " \033[1mBuild Date:\033[0m    " CLI_BuildDate      NL );
    3f00:	481d      	ldr	r0, [pc, #116]	; (3f78 <cliFunc_version+0xa4>)
    3f02:	f000 fb3d 	bl	4580 <_print>
	print( " \033[1mBuild OS:\033[0m      " CLI_BuildOS        NL );
    3f06:	481d      	ldr	r0, [pc, #116]	; (3f7c <cliFunc_version+0xa8>)
    3f08:	f000 fb3a 	bl	4580 <_print>
	print( " \033[1mArchitecture:\033[0m  " CLI_Arch           NL );
    3f0c:	481c      	ldr	r0, [pc, #112]	; (3f80 <cliFunc_version+0xac>)
    3f0e:	f000 fb37 	bl	4580 <_print>
	print( " \033[1mChip:\033[0m          " CLI_Chip           NL );
    3f12:	481c      	ldr	r0, [pc, #112]	; (3f84 <cliFunc_version+0xb0>)
    3f14:	f000 fb34 	bl	4580 <_print>
	print( " \033[1mCPU:\033[0m           " CLI_CPU            NL );
    3f18:	481b      	ldr	r0, [pc, #108]	; (3f88 <cliFunc_version+0xb4>)
    3f1a:	f000 fb31 	bl	4580 <_print>
	print( " \033[1mDevice:\033[0m        " CLI_Device         NL );
    3f1e:	481b      	ldr	r0, [pc, #108]	; (3f8c <cliFunc_version+0xb8>)
    3f20:	f000 fb2e 	bl	4580 <_print>
	print( " \033[1mModules:\033[0m       " CLI_Modules        NL );
    3f24:	481a      	ldr	r0, [pc, #104]	; (3f90 <cliFunc_version+0xbc>)
    3f26:	f000 fb2b 	bl	4580 <_print>
#if defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_)
	print( " \033[1mUnique Id:\033[0m     " );
    3f2a:	481a      	ldr	r0, [pc, #104]	; (3f94 <cliFunc_version+0xc0>)
    3f2c:	f000 fb28 	bl	4580 <_print>
	printHex32_op( SIM_UIDH, 4 );
    3f30:	4b19      	ldr	r3, [pc, #100]	; (3f98 <cliFunc_version+0xc4>)
    3f32:	2104      	movs	r1, #4
    3f34:	6818      	ldr	r0, [r3, #0]
    3f36:	f000 fbe1 	bl	46fc <printHex32_op>
	printHex32_op( SIM_UIDMH, 4 );
    3f3a:	4b18      	ldr	r3, [pc, #96]	; (3f9c <cliFunc_version+0xc8>)
    3f3c:	2104      	movs	r1, #4
    3f3e:	6818      	ldr	r0, [r3, #0]
    3f40:	f000 fbdc 	bl	46fc <printHex32_op>
	printHex32_op( SIM_UIDML, 4 );
    3f44:	4b16      	ldr	r3, [pc, #88]	; (3fa0 <cliFunc_version+0xcc>)
    3f46:	2104      	movs	r1, #4
    3f48:	6818      	ldr	r0, [r3, #0]
    3f4a:	f000 fbd7 	bl	46fc <printHex32_op>
	printHex32_op( SIM_UIDL, 4 );
    3f4e:	4b15      	ldr	r3, [pc, #84]	; (3fa4 <cliFunc_version+0xd0>)
    3f50:	2104      	movs	r1, #4
    3f52:	6818      	ldr	r0, [r3, #0]
#elif defined(_at90usb162_) || defined(_atmega32u4_) || defined(_at90usb646_) || defined(_at90usb1286_)
#else
#error "No unique id defined."
#endif
}
    3f54:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#if defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_)
	print( " \033[1mUnique Id:\033[0m     " );
	printHex32_op( SIM_UIDH, 4 );
	printHex32_op( SIM_UIDMH, 4 );
	printHex32_op( SIM_UIDML, 4 );
	printHex32_op( SIM_UIDL, 4 );
    3f58:	f000 bbd0 	b.w	46fc <printHex32_op>
    3f5c:	00006caf 	.word	0x00006caf
    3f60:	00006de5 	.word	0x00006de5
    3f64:	00006e28 	.word	0x00006e28
    3f68:	00006e49 	.word	0x00006e49
    3f6c:	00006e88 	.word	0x00006e88
    3f70:	00006ed6 	.word	0x00006ed6
    3f74:	00006f0a 	.word	0x00006f0a
    3f78:	00006f52 	.word	0x00006f52
    3f7c:	00006f86 	.word	0x00006f86
    3f80:	00006fb8 	.word	0x00006fb8
    3f84:	00006fd6 	.word	0x00006fd6
    3f88:	00006ffe 	.word	0x00006ffe
    3f8c:	00007022 	.word	0x00007022
    3f90:	00007045 	.word	0x00007045
    3f94:	00007097 	.word	0x00007097
    3f98:	40048054 	.word	0x40048054
    3f9c:	40048058 	.word	0x40048058
    3fa0:	4004805c 	.word	0x4004805c
    3fa4:	40048060 	.word	0x40048060

00003fa8 <cliFunc_cliDebug>:
{
	print("\033[2J\033[H\r"); // Erases the whole screen
}

void cliFunc_cliDebug( char* args )
{
    3fa8:	b510      	push	{r4, lr}
	// Toggle Hex Debug Mode
	if ( CLIHexDebugMode )
    3faa:	4c09      	ldr	r4, [pc, #36]	; (3fd0 <cliFunc_cliDebug+0x28>)
	{
		print( NL );
    3fac:	4809      	ldr	r0, [pc, #36]	; (3fd4 <cliFunc_cliDebug+0x2c>)
}

void cliFunc_cliDebug( char* args )
{
	// Toggle Hex Debug Mode
	if ( CLIHexDebugMode )
    3fae:	7823      	ldrb	r3, [r4, #0]
    3fb0:	b133      	cbz	r3, 3fc0 <cliFunc_cliDebug+0x18>
	{
		print( NL );
    3fb2:	f000 fae5 	bl	4580 <_print>
		info_print("Hex debug mode disabled...");
    3fb6:	4808      	ldr	r0, [pc, #32]	; (3fd8 <cliFunc_cliDebug+0x30>)
    3fb8:	f000 fae2 	bl	4580 <_print>
		CLIHexDebugMode = 0;
    3fbc:	2300      	movs	r3, #0
    3fbe:	e005      	b.n	3fcc <cliFunc_cliDebug+0x24>
	}
	else
	{
		print( NL );
    3fc0:	f000 fade 	bl	4580 <_print>
		info_print("Hex debug mode enabled...");
    3fc4:	4805      	ldr	r0, [pc, #20]	; (3fdc <cliFunc_cliDebug+0x34>)
    3fc6:	f000 fadb 	bl	4580 <_print>
		CLIHexDebugMode = 1;
    3fca:	2301      	movs	r3, #1
    3fcc:	7023      	strb	r3, [r4, #0]
    3fce:	bd10      	pop	{r4, pc}
    3fd0:	1ffff2bc 	.word	0x1ffff2bc
    3fd4:	00006caf 	.word	0x00006caf
    3fd8:	000070b0 	.word	0x000070b0
    3fdc:	000070df 	.word	0x000070df

00003fe0 <CLI_saveHistory.part.1>:
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
        if (*cursor == '\0') { return ; }

	// Copy the line to the history
	int i;
	for (i = 0; i < CLILineBufferCurrent; i++)
    3fe0:	4b08      	ldr	r3, [pc, #32]	; (4004 <CLI_saveHistory.part.1+0x24>)
    3fe2:	781a      	ldrb	r2, [r3, #0]
	{
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    3fe4:	4b08      	ldr	r3, [pc, #32]	; (4008 <CLI_saveHistory.part.1+0x28>)
    3fe6:	7818      	ldrb	r0, [r3, #0]
    3fe8:	4b08      	ldr	r3, [pc, #32]	; (400c <CLI_saveHistory.part.1+0x2c>)
    3fea:	2164      	movs	r1, #100	; 0x64
    3fec:	fb00 3101 	mla	r1, r0, r1, r3
    3ff0:	2300      	movs	r3, #0
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
        if (*cursor == '\0') { return ; }

	// Copy the line to the history
	int i;
	for (i = 0; i < CLILineBufferCurrent; i++)
    3ff2:	4293      	cmp	r3, r2
    3ff4:	da04      	bge.n	4000 <CLI_saveHistory.part.1+0x20>
	{
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    3ff6:	4806      	ldr	r0, [pc, #24]	; (4010 <CLI_saveHistory.part.1+0x30>)
    3ff8:	5c18      	ldrb	r0, [r3, r0]
    3ffa:	54c8      	strb	r0, [r1, r3]
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
        if (*cursor == '\0') { return ; }

	// Copy the line to the history
	int i;
	for (i = 0; i < CLILineBufferCurrent; i++)
    3ffc:	3301      	adds	r3, #1
    3ffe:	e7f8      	b.n	3ff2 <CLI_saveHistory.part.1+0x12>
	{
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
	}
}
    4000:	4770      	bx	lr
    4002:	bf00      	nop
    4004:	1ffff764 	.word	0x1ffff764
    4008:	1ffff738 	.word	0x1ffff738
    400c:	1ffff2c0 	.word	0x1ffff2c0
    4010:	1ffff6a8 	.word	0x1ffff6a8

00004014 <CLI_argumentIsolation>:
// Takes a string, returns two pointers
//  One to the first non-space character
//  The second to the next argument (first NULL if there isn't an argument). delimited by a space
//  Places a NULL at the first space after the first argument
void CLI_argumentIsolation( char* string, char** first, char** second )
{
    4014:	b530      	push	{r4, r5, lr}
	// Mark out the first argument
	// This is done by finding the first space after a list of non-spaces and setting it NULL
	char* cmdPtr = string - 1;
	while ( *++cmdPtr == ' ' ); // Skips leading spaces, and points to first character of cmd
    4016:	4604      	mov	r4, r0
    4018:	3001      	adds	r0, #1
    401a:	7823      	ldrb	r3, [r4, #0]
    401c:	2b20      	cmp	r3, #32
    401e:	d0fa      	beq.n	4016 <CLI_argumentIsolation+0x2>
    4020:	4603      	mov	r3, r0
    4022:	3001      	adds	r0, #1

	// Locates first space delimiter
	char* argPtr = cmdPtr + 1;
	while ( *argPtr != ' ' && *argPtr != '\0' )
    4024:	781d      	ldrb	r5, [r3, #0]
    4026:	f015 05df 	ands.w	r5, r5, #223	; 0xdf
    402a:	d1f9      	bne.n	4020 <CLI_argumentIsolation+0xc>
		argPtr++;

	// Point to the first character of args or a NULL (no args) and set the space delimiter as a NULL
	(++argPtr)[-1] = '\0';
    402c:	f803 5b01 	strb.w	r5, [r3], #1

	// Set return variables
	*first = cmdPtr;
    4030:	600c      	str	r4, [r1, #0]
	*second = argPtr;
    4032:	6013      	str	r3, [r2, #0]
    4034:	bd30      	pop	{r4, r5, pc}
    4036:	0000      	movs	r0, r0

00004038 <CLI_commandLookup>:
}

// Scans the CLILineBuffer for any valid commands
void CLI_commandLookup()
{
    4038:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
    403c:	4b23      	ldr	r3, [pc, #140]	; (40cc <CLI_commandLookup+0x94>)
    403e:	781b      	ldrb	r3, [r3, #0]
	*second = argPtr;
}

// Scans the CLILineBuffer for any valid commands
void CLI_commandLookup()
{
    4040:	b089      	sub	sp, #36	; 0x24
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
    4042:	2b00      	cmp	r3, #0
    4044:	d03e      	beq.n	40c4 <CLI_commandLookup+0x8c>
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    4046:	4c22      	ldr	r4, [pc, #136]	; (40d0 <CLI_commandLookup+0x98>)
    4048:	2600      	movs	r6, #0

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    404a:	4620      	mov	r0, r4
    404c:	a906      	add	r1, sp, #24
    404e:	aa07      	add	r2, sp, #28
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    4050:	54e6      	strb	r6, [r4, r3]

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    4052:	f7ff ffdf 	bl	4014 <CLI_argumentIsolation>
    4056:	46a1      	mov	r9, r4

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    4058:	4b1e      	ldr	r3, [pc, #120]	; (40d4 <CLI_commandLookup+0x9c>)
    405a:	781b      	ldrb	r3, [r3, #0]
    405c:	b2f7      	uxtb	r7, r6
    405e:	42bb      	cmp	r3, r7
    4060:	d91b      	bls.n	409a <CLI_commandLookup+0x62>
    4062:	2500      	movs	r5, #0
	{
		// Parse each cmd until a null command entry is found, or an argument match
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    4064:	4c1c      	ldr	r4, [pc, #112]	; (40d8 <CLI_commandLookup+0xa0>)
    4066:	b2eb      	uxtb	r3, r5
    4068:	f04f 080c 	mov.w	r8, #12
    406c:	fb08 f803 	mul.w	r8, r8, r3
    4070:	f854 3027 	ldr.w	r3, [r4, r7, lsl #2]
    4074:	f853 1008 	ldr.w	r1, [r3, r8]
    4078:	b169      	cbz	r1, 4096 <CLI_commandLookup+0x5e>
		{
			// Compare the first argument and each command entry
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == -1 )
    407a:	9806      	ldr	r0, [sp, #24]
    407c:	f000 fb49 	bl	4712 <eqStr>
    4080:	3001      	adds	r0, #1
    4082:	f105 0501 	add.w	r5, r5, #1
    4086:	d1ed      	bne.n	4064 <CLI_commandLookup+0x2c>
			{
				// Run the specified command function pointer
				//   argPtr is already pointing at the first character of the arguments
				(*(void (*)(char*))CLIDict[dict][cmd].function)( argPtr );
    4088:	f854 3027 	ldr.w	r3, [r4, r7, lsl #2]
    408c:	9807      	ldr	r0, [sp, #28]
    408e:	4443      	add	r3, r8
    4090:	689b      	ldr	r3, [r3, #8]
    4092:	4798      	blx	r3

				return;
    4094:	e016      	b.n	40c4 <CLI_commandLookup+0x8c>
    4096:	3601      	adds	r6, #1
    4098:	e7de      	b.n	4058 <CLI_commandLookup+0x20>
			}
		}
	}

	// No match for the command...
	print( NL );
    409a:	4d10      	ldr	r5, [pc, #64]	; (40dc <CLI_commandLookup+0xa4>)
    409c:	4628      	mov	r0, r5
    409e:	f000 fa6f 	bl	4580 <_print>
	erro_dPrint("\"", CLILineBuffer, "\" is not a valid command...type \033[35mhelp\033[0m");
    40a2:	4b0f      	ldr	r3, [pc, #60]	; (40e0 <CLI_commandLookup+0xa8>)
    40a4:	9300      	str	r3, [sp, #0]
    40a6:	4b0f      	ldr	r3, [pc, #60]	; (40e4 <CLI_commandLookup+0xac>)
    40a8:	9301      	str	r3, [sp, #4]
    40aa:	4b0f      	ldr	r3, [pc, #60]	; (40e8 <CLI_commandLookup+0xb0>)
    40ac:	9303      	str	r3, [sp, #12]
    40ae:	4b0f      	ldr	r3, [pc, #60]	; (40ec <CLI_commandLookup+0xb4>)
    40b0:	9305      	str	r3, [sp, #20]
    40b2:	f8cd 9008 	str.w	r9, [sp, #8]
    40b6:	9504      	str	r5, [sp, #16]
    40b8:	480d      	ldr	r0, [pc, #52]	; (40f0 <CLI_commandLookup+0xb8>)
    40ba:	490e      	ldr	r1, [pc, #56]	; (40f4 <CLI_commandLookup+0xbc>)
    40bc:	4a0e      	ldr	r2, [pc, #56]	; (40f8 <CLI_commandLookup+0xc0>)
    40be:	4b0f      	ldr	r3, [pc, #60]	; (40fc <CLI_commandLookup+0xc4>)
    40c0:	f000 fa44 	bl	454c <printstrs>
}
    40c4:	b009      	add	sp, #36	; 0x24
    40c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    40ca:	bf00      	nop
    40cc:	1ffff764 	.word	0x1ffff764
    40d0:	1ffff6a8 	.word	0x1ffff6a8
    40d4:	1ffff2bf 	.word	0x1ffff2bf
    40d8:	1ffff710 	.word	0x1ffff710
    40dc:	00006caf 	.word	0x00006caf
    40e0:	0000711d 	.word	0x0000711d
    40e4:	00007125 	.word	0x00007125
    40e8:	00007127 	.word	0x00007127
    40ec:	00006cf8 	.word	0x00006cf8
    40f0:	0000710d 	.word	0x0000710d
    40f4:	00007110 	.word	0x00007110
    40f8:	00005036 	.word	0x00005036
    40fc:	00007117 	.word	0x00007117

00004100 <CLI_registerDictionary>:

// Registers a command dictionary with the CLI
void CLI_registerDictionary( const CLIDictItem *cmdDict, const char* dictName )
{
    4100:	b510      	push	{r4, lr}
	// Make sure this max limit of dictionaries hasn't been reached
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
    4102:	4a09      	ldr	r2, [pc, #36]	; (4128 <CLI_registerDictionary+0x28>)
    4104:	7813      	ldrb	r3, [r2, #0]
    4106:	2b09      	cmp	r3, #9
    4108:	d904      	bls.n	4114 <CLI_registerDictionary+0x14>
	{
		erro_print("Max number of dictionaries defined already...");
    410a:	4808      	ldr	r0, [pc, #32]	; (412c <CLI_registerDictionary+0x2c>)
	}

	// Add dictionary
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
}
    410c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void CLI_registerDictionary( const CLIDictItem *cmdDict, const char* dictName )
{
	// Make sure this max limit of dictionaries hasn't been reached
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
	{
		erro_print("Max number of dictionaries defined already...");
    4110:	f000 ba36 	b.w	4580 <_print>
		return;
	}

	// Add dictionary
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
    4114:	4c06      	ldr	r4, [pc, #24]	; (4130 <CLI_registerDictionary+0x30>)
    4116:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
    411a:	1c59      	adds	r1, r3, #1
    411c:	7011      	strb	r1, [r2, #0]
    411e:	4a05      	ldr	r2, [pc, #20]	; (4134 <CLI_registerDictionary+0x34>)
    4120:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    4124:	bd10      	pop	{r4, pc}
    4126:	bf00      	nop
    4128:	1ffff2bf 	.word	0x1ffff2bf
    412c:	00007155 	.word	0x00007155
    4130:	1ffff73c 	.word	0x1ffff73c
    4134:	1ffff710 	.word	0x1ffff710

00004138 <CLI_init>:

// Initialize the CLI
inline void CLI_init()
{
	// Reset the Line Buffer
	CLILineBufferCurrent = 0;
    4138:	4b0e      	ldr	r3, [pc, #56]	; (4174 <CLI_init+0x3c>)

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    413a:	480f      	ldr	r0, [pc, #60]	; (4178 <CLI_init+0x40>)
	print("\033[1;34m:\033[0m "); // Blue bold prompt
}

// Initialize the CLI
inline void CLI_init()
{
    413c:	b510      	push	{r4, lr}
	// Reset the Line Buffer
	CLILineBufferCurrent = 0;
    413e:	2400      	movs	r4, #0
    4140:	701c      	strb	r4, [r3, #0]

	// History starts empty
	CLIHistoryHead = 0;
    4142:	4b0e      	ldr	r3, [pc, #56]	; (417c <CLI_init+0x44>)
    4144:	701c      	strb	r4, [r3, #0]
	CLIHistoryCurrent = 0;
    4146:	4b0e      	ldr	r3, [pc, #56]	; (4180 <CLI_init+0x48>)
    4148:	701c      	strb	r4, [r3, #0]
	CLIHistoryTail = 0;
    414a:	4b0e      	ldr	r3, [pc, #56]	; (4184 <CLI_init+0x4c>)
    414c:	701c      	strb	r4, [r3, #0]

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    414e:	f000 fa17 	bl	4580 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    4152:	480d      	ldr	r0, [pc, #52]	; (4188 <CLI_init+0x50>)
    4154:	f000 fa14 	bl	4580 <_print>

	// Set prompt
	prompt();

	// Register first dictionary
	CLIDictionariesUsed = 0;
    4158:	4b0c      	ldr	r3, [pc, #48]	; (418c <CLI_init+0x54>)
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    415a:	480d      	ldr	r0, [pc, #52]	; (4190 <CLI_init+0x58>)
    415c:	490d      	ldr	r1, [pc, #52]	; (4194 <CLI_init+0x5c>)

	// Set prompt
	prompt();

	// Register first dictionary
	CLIDictionariesUsed = 0;
    415e:	701c      	strb	r4, [r3, #0]
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    4160:	f7ff ffce 	bl	4100 <CLI_registerDictionary>

	// Initialize main LED
	init_errorLED();
    4164:	f000 f9d4 	bl	4510 <init_errorLED>
	CLILEDState = 0;
    4168:	4b0b      	ldr	r3, [pc, #44]	; (4198 <CLI_init+0x60>)
    416a:	701c      	strb	r4, [r3, #0]

	// Hex debug mode is off by default
	CLIHexDebugMode = 0;
    416c:	4b0b      	ldr	r3, [pc, #44]	; (419c <CLI_init+0x64>)
    416e:	701c      	strb	r4, [r3, #0]
    4170:	bd10      	pop	{r4, pc}
    4172:	bf00      	nop
    4174:	1ffff764 	.word	0x1ffff764
    4178:	0000719a 	.word	0x0000719a
    417c:	1ffff70d 	.word	0x1ffff70d
    4180:	1ffff2bd 	.word	0x1ffff2bd
    4184:	1ffff738 	.word	0x1ffff738
    4188:	000071a0 	.word	0x000071a0
    418c:	1ffff2bf 	.word	0x1ffff2bf
    4190:	0000727c 	.word	0x0000727c
    4194:	0000737e 	.word	0x0000737e
    4198:	1ffff2be 	.word	0x1ffff2be
    419c:	1ffff2bc 	.word	0x1ffff2bc

000041a0 <CLI_tabCompletion>:
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
}

inline void CLI_tabCompletion()
{
    41a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
    41a4:	4d28      	ldr	r5, [pc, #160]	; (4248 <CLI_tabCompletion+0xa8>)
    41a6:	782b      	ldrb	r3, [r5, #0]
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
}

inline void CLI_tabCompletion()
{
    41a8:	b085      	sub	sp, #20
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
    41aa:	2b00      	cmp	r3, #0
    41ac:	d048      	beq.n	4240 <CLI_tabCompletion+0xa0>
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    41ae:	4f27      	ldr	r7, [pc, #156]	; (424c <CLI_tabCompletion+0xac>)
    41b0:	2400      	movs	r4, #0

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    41b2:	4638      	mov	r0, r7
    41b4:	a902      	add	r1, sp, #8
    41b6:	aa03      	add	r2, sp, #12
	// Ignore command if buffer is 0 length
	if ( CLILineBufferCurrent == 0 )
		return;

	// Set the last+1 character of the buffer to NULL for string processing
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    41b8:	54fc      	strb	r4, [r7, r3]

	// Retrieve pointers to command and beginning of arguments
	// Places a NULL at the first space after the command
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    41ba:	f7ff ff2b 	bl	4014 <CLI_argumentIsolation>

	// Tab match pointer
	char* tabMatch = 0;
	uint8_t matches = 0;
    41be:	46a0      	mov	r8, r4
	char* cmdPtr;
	char* argPtr;
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );

	// Tab match pointer
	char* tabMatch = 0;
    41c0:	4626      	mov	r6, r4
	uint8_t matches = 0;

	// Scan array of dictionaries for a valid command match
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    41c2:	4b23      	ldr	r3, [pc, #140]	; (4250 <CLI_tabCompletion+0xb0>)
    41c4:	781b      	ldrb	r3, [r3, #0]
    41c6:	fa5f fa84 	uxtb.w	sl, r4
    41ca:	4553      	cmp	r3, sl
    41cc:	d920      	bls.n	4210 <CLI_tabCompletion+0x70>
    41ce:	f04f 0900 	mov.w	r9, #0
	{
		// Parse each cmd until a null command entry is found, or an argument match
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    41d2:	fa5f f389 	uxtb.w	r3, r9
    41d6:	f04f 0b0c 	mov.w	fp, #12
    41da:	fb0b fb03 	mul.w	fp, fp, r3
    41de:	4b1d      	ldr	r3, [pc, #116]	; (4254 <CLI_tabCompletion+0xb4>)
    41e0:	f853 202a 	ldr.w	r2, [r3, sl, lsl #2]
    41e4:	f852 100b 	ldr.w	r1, [r2, fp]
    41e8:	b181      	cbz	r1, 420c <CLI_tabCompletion+0x6c>
		{
			// Compare the first argument piece to each command entry to see if it is "like"
			// NOTE: To save on processing, we only care about the commands and ignore the arguments
			//       If there are arguments, and a valid tab match is found, buffer is cleared (args lost)
			//       Also ignores full matches
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
    41ea:	9802      	ldr	r0, [sp, #8]
    41ec:	9301      	str	r3, [sp, #4]
    41ee:	f000 fa90 	bl	4712 <eqStr>
    41f2:	9b01      	ldr	r3, [sp, #4]
    41f4:	b938      	cbnz	r0, 4206 <CLI_tabCompletion+0x66>
			{
				// TODO Make list of commands if multiple matches
				matches++;
				tabMatch = (char*)CLIDict[dict][cmd].name;
    41f6:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
			//       If there are arguments, and a valid tab match is found, buffer is cleared (args lost)
			//       Also ignores full matches
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
			{
				// TODO Make list of commands if multiple matches
				matches++;
    41fa:	f108 0801 	add.w	r8, r8, #1
				tabMatch = (char*)CLIDict[dict][cmd].name;
    41fe:	f853 600b 	ldr.w	r6, [r3, fp]
			//       If there are arguments, and a valid tab match is found, buffer is cleared (args lost)
			//       Also ignores full matches
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
			{
				// TODO Make list of commands if multiple matches
				matches++;
    4202:	fa5f f888 	uxtb.w	r8, r8
    4206:	f109 0901 	add.w	r9, r9, #1
    420a:	e7e2      	b.n	41d2 <CLI_tabCompletion+0x32>
    420c:	3401      	adds	r4, #1
    420e:	e7d8      	b.n	41c2 <CLI_tabCompletion+0x22>
			}
		}
	}

	// Only tab complete if there was 1 match
	if ( matches == 1 )
    4210:	f1b8 0f01 	cmp.w	r8, #1
    4214:	d114      	bne.n	4240 <CLI_tabCompletion+0xa0>
	{
		// Reset the buffer
		CLILineBufferCurrent = 0;
    4216:	2300      	movs	r3, #0

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    4218:	480f      	ldr	r0, [pc, #60]	; (4258 <CLI_tabCompletion+0xb8>)

	// Only tab complete if there was 1 match
	if ( matches == 1 )
	{
		// Reset the buffer
		CLILineBufferCurrent = 0;
    421a:	702b      	strb	r3, [r5, #0]

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    421c:	f000 f9b0 	bl	4580 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    4220:	480e      	ldr	r0, [pc, #56]	; (425c <CLI_tabCompletion+0xbc>)
    4222:	f000 f9ad 	bl	4580 <_print>

		// Reprint the prompt (automatically clears the line)
		prompt();

		// Display the command
		dPrint( tabMatch );
    4226:	4630      	mov	r0, r6
    4228:	f7fe fe94 	bl	2f54 <Output_putstr>

		// There are no index counts, so just copy the whole string to the input buffer
		while ( *tabMatch != '\0' )
    422c:	f816 3b01 	ldrb.w	r3, [r6], #1
    4230:	b133      	cbz	r3, 4240 <CLI_tabCompletion+0xa0>
		{
			CLILineBuffer[CLILineBufferCurrent++] = *tabMatch++;
    4232:	782b      	ldrb	r3, [r5, #0]
    4234:	1c5a      	adds	r2, r3, #1
    4236:	702a      	strb	r2, [r5, #0]
    4238:	f816 2c01 	ldrb.w	r2, [r6, #-1]
    423c:	54fa      	strb	r2, [r7, r3]
    423e:	e7f5      	b.n	422c <CLI_tabCompletion+0x8c>
		}
	}
}
    4240:	b005      	add	sp, #20
    4242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4246:	bf00      	nop
    4248:	1ffff764 	.word	0x1ffff764
    424c:	1ffff6a8 	.word	0x1ffff6a8
    4250:	1ffff2bf 	.word	0x1ffff2bf
    4254:	1ffff710 	.word	0x1ffff710
    4258:	0000719a 	.word	0x0000719a
    425c:	000071a0 	.word	0x000071a0

00004260 <CLI_wrap>:

inline int CLI_wrap( int kX, int const kLowerBound, int const kUpperBound )
{
	int range_size = kUpperBound - kLowerBound + 1;
    4260:	1a52      	subs	r2, r2, r1

	if ( kX < kLowerBound )
    4262:	4288      	cmp	r0, r1
	}
}

inline int CLI_wrap( int kX, int const kLowerBound, int const kUpperBound )
{
	int range_size = kUpperBound - kLowerBound + 1;
    4264:	f102 0201 	add.w	r2, r2, #1

	if ( kX < kLowerBound )
    4268:	da05      	bge.n	4276 <CLI_wrap+0x16>
		kX += range_size * ((kLowerBound - kX) / range_size + 1);
    426a:	1a0b      	subs	r3, r1, r0
    426c:	fb93 f3f2 	sdiv	r3, r3, r2
    4270:	fb03 2302 	mla	r3, r3, r2, r2
    4274:	4418      	add	r0, r3

	return kLowerBound + (kX - kLowerBound) % range_size;
    4276:	1a40      	subs	r0, r0, r1
    4278:	fb90 f3f2 	sdiv	r3, r0, r2
    427c:	fb02 0013 	mls	r0, r2, r3, r0
}
    4280:	4408      	add	r0, r1
    4282:	4770      	bx	lr

00004284 <CLI_saveHistory>:

inline void CLI_saveHistory( char *buff )
{
	if ( buff == NULL )
    4284:	b108      	cbz	r0, 428a <CLI_saveHistory+0x6>
    4286:	3801      	subs	r0, #1
    4288:	e006      	b.n	4298 <CLI_saveHistory+0x14>
	{
		//clear the item
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    428a:	4b07      	ldr	r3, [pc, #28]	; (42a8 <CLI_saveHistory+0x24>)
    428c:	781b      	ldrb	r3, [r3, #0]
    428e:	2264      	movs	r2, #100	; 0x64
    4290:	4353      	muls	r3, r2
    4292:	4a06      	ldr	r2, [pc, #24]	; (42ac <CLI_saveHistory+0x28>)
    4294:	54d0      	strb	r0, [r2, r3]
		return;
    4296:	4770      	bx	lr
	}

        // Don't write empty lines to the history
        const char *cursor = buff;
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
    4298:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    429c:	2b20      	cmp	r3, #32
    429e:	d0fb      	beq.n	4298 <CLI_saveHistory+0x14>
        if (*cursor == '\0') { return ; }
    42a0:	b10b      	cbz	r3, 42a6 <CLI_saveHistory+0x22>
    42a2:	f7ff be9d 	b.w	3fe0 <CLI_saveHistory.part.1>
    42a6:	4770      	bx	lr
    42a8:	1ffff738 	.word	0x1ffff738
    42ac:	1ffff2c0 	.word	0x1ffff2c0

000042b0 <CLI_retreiveHistory>:
	}
}

void CLI_retreiveHistory( int index )
{
	char *histMatch = CLIHistoryBuffer[ index ];
    42b0:	4b0d      	ldr	r3, [pc, #52]	; (42e8 <CLI_retreiveHistory+0x38>)
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
	}
}

void CLI_retreiveHistory( int index )
{
    42b2:	b570      	push	{r4, r5, r6, lr}
	char *histMatch = CLIHistoryBuffer[ index ];
    42b4:	2464      	movs	r4, #100	; 0x64

	// Reset the buffer
	CLILineBufferCurrent = 0;
    42b6:	4d0d      	ldr	r5, [pc, #52]	; (42ec <CLI_retreiveHistory+0x3c>)
	}
}

void CLI_retreiveHistory( int index )
{
	char *histMatch = CLIHistoryBuffer[ index ];
    42b8:	fb04 3400 	mla	r4, r4, r0, r3

	// Reset the buffer
	CLILineBufferCurrent = 0;
    42bc:	2600      	movs	r6, #0

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    42be:	480c      	ldr	r0, [pc, #48]	; (42f0 <CLI_retreiveHistory+0x40>)
void CLI_retreiveHistory( int index )
{
	char *histMatch = CLIHistoryBuffer[ index ];

	// Reset the buffer
	CLILineBufferCurrent = 0;
    42c0:	702e      	strb	r6, [r5, #0]

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    42c2:	f000 f95d 	bl	4580 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    42c6:	480b      	ldr	r0, [pc, #44]	; (42f4 <CLI_retreiveHistory+0x44>)
    42c8:	f000 f95a 	bl	4580 <_print>

	// Reprint the prompt (automatically clears the line)
	prompt();

	// Display the command
	dPrint( histMatch );
    42cc:	4620      	mov	r0, r4
    42ce:	f7fe fe41 	bl	2f54 <Output_putstr>

	// There are no index counts, so just copy the whole string to the input buffe
	CLILineBufferCurrent = 0;
	while ( *histMatch != '\0' )
    42d2:	4633      	mov	r3, r6
    42d4:	b2da      	uxtb	r2, r3
    42d6:	1c59      	adds	r1, r3, #1
    42d8:	5ce3      	ldrb	r3, [r4, r3]
    42da:	b11b      	cbz	r3, 42e4 <CLI_retreiveHistory+0x34>
	{
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    42dc:	4806      	ldr	r0, [pc, #24]	; (42f8 <CLI_retreiveHistory+0x48>)
    42de:	5483      	strb	r3, [r0, r2]
    42e0:	460b      	mov	r3, r1
    42e2:	e7f7      	b.n	42d4 <CLI_retreiveHistory+0x24>
    42e4:	702a      	strb	r2, [r5, #0]
    42e6:	bd70      	pop	{r4, r5, r6, pc}
    42e8:	1ffff2c0 	.word	0x1ffff2c0
    42ec:	1ffff764 	.word	0x1ffff764
    42f0:	0000719a 	.word	0x0000719a
    42f4:	000071a0 	.word	0x000071a0
    42f8:	1ffff6a8 	.word	0x1ffff6a8

000042fc <CLI_process>:
	CLIHexDebugMode = 0;
}

// Query the serial input buffer for any new characters
void CLI_process()
{
    42fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// Current buffer position
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    42fe:	4d74      	ldr	r5, [pc, #464]	; (44d0 <CLI_process+0x1d4>)
    4300:	782c      	ldrb	r4, [r5, #0]

	// Process each character while available
	while ( 1 )
	{
		// No more characters to process
		if ( Output_availablechar() == 0 )
    4302:	f7fe fe23 	bl	2f4c <Output_availablechar>
    4306:	b1a0      	cbz	r0, 4332 <CLI_process+0x36>
			break;

		// Retrieve from output module
		char cur_char = (char)Output_getchar();
    4308:	f7fe fe22 	bl	2f50 <Output_getchar>

		// Make sure buffer isn't full
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    430c:	782b      	ldrb	r3, [r5, #0]
    430e:	4e70      	ldr	r6, [pc, #448]	; (44d0 <CLI_process+0x1d4>)
    4310:	2b63      	cmp	r3, #99	; 0x63
		// No more characters to process
		if ( Output_availablechar() == 0 )
			break;

		// Retrieve from output module
		char cur_char = (char)Output_getchar();
    4312:	b2c0      	uxtb	r0, r0

		// Make sure buffer isn't full
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    4314:	d908      	bls.n	4328 <CLI_process+0x2c>
		{
			print( NL );
    4316:	486f      	ldr	r0, [pc, #444]	; (44d4 <CLI_process+0x1d8>)
    4318:	f000 f932 	bl	4580 <_print>
			erro_print("Serial line buffer is full, dropping character and resetting...");
    431c:	486e      	ldr	r0, [pc, #440]	; (44d8 <CLI_process+0x1dc>)
    431e:	f000 f92f 	bl	4580 <_print>

			// Clear buffer
			CLILineBufferCurrent = 0;
    4322:	2300      	movs	r3, #0
    4324:	7033      	strb	r3, [r6, #0]
    4326:	e03e      	b.n	43a6 <CLI_process+0xaa>

			return;
		}

		// Place into line buffer
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    4328:	1c5a      	adds	r2, r3, #1
    432a:	7032      	strb	r2, [r6, #0]
    432c:	4a6b      	ldr	r2, [pc, #428]	; (44dc <CLI_process+0x1e0>)
    432e:	54d0      	strb	r0, [r2, r3]
	}
    4330:	e7e7      	b.n	4302 <CLI_process+0x6>

	// Display Hex Key Input if enabled
	if ( CLIHexDebugMode && CLILineBufferCurrent > prev_buf_pos )
    4332:	4b6b      	ldr	r3, [pc, #428]	; (44e0 <CLI_process+0x1e4>)
    4334:	781b      	ldrb	r3, [r3, #0]
    4336:	b30b      	cbz	r3, 437c <CLI_process+0x80>
    4338:	782b      	ldrb	r3, [r5, #0]
    433a:	42a3      	cmp	r3, r4
    433c:	d91e      	bls.n	437c <CLI_process+0x80>
	{
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    433e:	4869      	ldr	r0, [pc, #420]	; (44e4 <CLI_process+0x1e8>)
    4340:	f000 f91e 	bl	4580 <_print>
		print("\033[2K");    // Erases the current line
    4344:	4868      	ldr	r0, [pc, #416]	; (44e8 <CLI_process+0x1ec>)
    4346:	f000 f91b 	bl	4580 <_print>

		uint8_t pos = prev_buf_pos;
		while ( CLILineBufferCurrent > pos )
    434a:	4623      	mov	r3, r4
    434c:	782a      	ldrb	r2, [r5, #0]
    434e:	429a      	cmp	r2, r3
    4350:	d90b      	bls.n	436a <CLI_process+0x6e>
		{
			printHex( CLILineBuffer[pos++] );
    4352:	4a62      	ldr	r2, [pc, #392]	; (44dc <CLI_process+0x1e0>)
    4354:	1c5e      	adds	r6, r3, #1
    4356:	5cd0      	ldrb	r0, [r2, r3]
    4358:	2101      	movs	r1, #1
    435a:	f000 f99a 	bl	4692 <printHex_op>
    435e:	b2f6      	uxtb	r6, r6
			print(" ");
    4360:	4862      	ldr	r0, [pc, #392]	; (44ec <CLI_process+0x1f0>)
    4362:	f000 f90d 	bl	4580 <_print>
		print("\033[2K");    // Erases the current line

		uint8_t pos = prev_buf_pos;
		while ( CLILineBufferCurrent > pos )
		{
			printHex( CLILineBuffer[pos++] );
    4366:	4633      	mov	r3, r6
    4368:	e7f0      	b.n	434c <CLI_process+0x50>
			print(" ");
		}

		print("\033[u"); // Restore cursor position
    436a:	4861      	ldr	r0, [pc, #388]	; (44f0 <CLI_process+0x1f4>)
    436c:	e026      	b.n	43bc <CLI_process+0xc0>

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    436e:	d830      	bhi.n	43d2 <CLI_process+0xd6>
    4370:	2a08      	cmp	r2, #8
    4372:	d126      	bne.n	43c2 <CLI_process+0xc6>
		case 0x7F: // Backspace
			// TODO - Does not handle case for arrow editing (arrows disabled atm)
			CLILineBufferCurrent--; // Remove the backspace

			// If there are characters in the buffer
			if ( CLILineBufferCurrent > 0 )
    4374:	2b01      	cmp	r3, #1
    4376:	d11e      	bne.n	43b6 <CLI_process+0xba>
			return;

		case 0x08:
		case 0x7F: // Backspace
			// TODO - Does not handle case for arrow editing (arrows disabled atm)
			CLILineBufferCurrent--; // Remove the backspace
    4378:	2300      	movs	r3, #0
    437a:	702b      	strb	r3, [r5, #0]

		print("\033[u"); // Restore cursor position
	}

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
    437c:	782b      	ldrb	r3, [r5, #0]
    437e:	4f54      	ldr	r7, [pc, #336]	; (44d0 <CLI_process+0x1d4>)
    4380:	42a3      	cmp	r3, r4
    4382:	f240 80a3 	bls.w	44cc <CLI_process+0x1d0>
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    4386:	4955      	ldr	r1, [pc, #340]	; (44dc <CLI_process+0x1e0>)
    4388:	5d0a      	ldrb	r2, [r1, r4]
    438a:	2a0a      	cmp	r2, #10
    438c:	460e      	mov	r6, r1
    438e:	d1ee      	bne.n	436e <CLI_process+0x72>
		{
		// Enter
		case 0x0A: // LF
		case 0x0D: // CR
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    4390:	441e      	add	r6, r3
    4392:	2220      	movs	r2, #32

			// Remove the space if there is no command
			if ( CLILineBufferCurrent == 1 )
    4394:	2b01      	cmp	r3, #1
		switch ( CLILineBuffer[prev_buf_pos] )
		{
		// Enter
		case 0x0A: // LF
		case 0x0D: // CR
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    4396:	f806 2c01 	strb.w	r2, [r6, #-1]

			// Remove the space if there is no command
			if ( CLILineBufferCurrent == 1 )
    439a:	d121      	bne.n	43e0 <CLI_process+0xe4>
				CLI_saveHistory( NULL ); // delete the old temp buffer

			}

			// Reset the buffer
			CLILineBufferCurrent = 0;
    439c:	2300      	movs	r3, #0

			// Reset the prompt after processing has finished
			print( NL );
    439e:	484d      	ldr	r0, [pc, #308]	; (44d4 <CLI_process+0x1d8>)
				CLI_saveHistory( NULL ); // delete the old temp buffer

			}

			// Reset the buffer
			CLILineBufferCurrent = 0;
    43a0:	702b      	strb	r3, [r5, #0]

			// Reset the prompt after processing has finished
			print( NL );
    43a2:	f000 f8ed 	bl	4580 <_print>

// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    43a6:	4853      	ldr	r0, [pc, #332]	; (44f4 <CLI_process+0x1f8>)
    43a8:	f000 f8ea 	bl	4580 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    43ac:	4852      	ldr	r0, [pc, #328]	; (44f8 <CLI_process+0x1fc>)
			prev_buf_pos++;

			break;
		}
	}
}
    43ae:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
// ----- Functions -----

inline void prompt()
{
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    43b2:	f000 b8e5 	b.w	4580 <_print>

			// If there are characters in the buffer
			if ( CLILineBufferCurrent > 0 )
			{
				// Remove character from current position in the line buffer
				CLILineBufferCurrent--;
    43b6:	3b02      	subs	r3, #2

				// Remove character from tty
				print("\b \b");
    43b8:	4850      	ldr	r0, [pc, #320]	; (44fc <CLI_process+0x200>)

			// If there are characters in the buffer
			if ( CLILineBufferCurrent > 0 )
			{
				// Remove character from current position in the line buffer
				CLILineBufferCurrent--;
    43ba:	702b      	strb	r3, [r5, #0]

				// Remove character from tty
				print("\b \b");
    43bc:	f000 f8e0 	bl	4580 <_print>
    43c0:	e7dc      	b.n	437c <CLI_process+0x80>

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    43c2:	2a09      	cmp	r2, #9
    43c4:	d17a      	bne.n	44bc <CLI_process+0x1c0>
			//     Doesn't look like it will happen *that* often, so not handling it for now -HaaTa
			return;

		case 0x09: // Tab
			// Tab completion for the current command
			CLI_tabCompletion();
    43c6:	f7ff feeb 	bl	41a0 <CLI_tabCompletion>

			CLILineBufferCurrent--; // Remove the Tab
    43ca:	783b      	ldrb	r3, [r7, #0]
    43cc:	3b01      	subs	r3, #1
    43ce:	703b      	strb	r3, [r7, #0]

			// XXX There is a potential bug here when resetting the buffer (losing valid keypresses)
			//     Doesn't look like it will happen *that* often, so not handling it for now -HaaTa
			return;
    43d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	// If buffer has changed, output to screen while there are still characters in the buffer not displayed
	while ( CLILineBufferCurrent > prev_buf_pos )
	{
		// Check for control characters
		switch ( CLILineBuffer[prev_buf_pos] )
    43d2:	2a1b      	cmp	r2, #27
    43d4:	d029      	beq.n	442a <CLI_process+0x12e>
    43d6:	2a7f      	cmp	r2, #127	; 0x7f
    43d8:	d0cc      	beq.n	4374 <CLI_process+0x78>
    43da:	2a0d      	cmp	r2, #13
    43dc:	d16e      	bne.n	44bc <CLI_process+0x1c0>
    43de:	e7d7      	b.n	4390 <CLI_process+0x94>
				CLILineBufferCurrent--;
			}
			else
			{
				// Add the command to the history
				CLI_saveHistory( CLILineBuffer );
    43e0:	483e      	ldr	r0, [pc, #248]	; (44dc <CLI_process+0x1e0>)
    43e2:	f7ff ff4f 	bl	4284 <CLI_saveHistory>

				// Process the current line buffer
				CLI_commandLookup();
    43e6:	f7ff fe27 	bl	4038 <CLI_commandLookup>

				// Keep the array circular, discarding the older entries
				if ( CLIHistoryTail < CLIHistoryHead )
    43ea:	4b45      	ldr	r3, [pc, #276]	; (4500 <CLI_process+0x204>)
    43ec:	4a45      	ldr	r2, [pc, #276]	; (4504 <CLI_process+0x208>)
    43ee:	7819      	ldrb	r1, [r3, #0]
    43f0:	7814      	ldrb	r4, [r2, #0]
    43f2:	42a1      	cmp	r1, r4
    43f4:	d206      	bcs.n	4404 <CLI_process+0x108>
					CLIHistoryHead = ( CLIHistoryHead + 1 ) % CLIMaxHistorySize;
    43f6:	3401      	adds	r4, #1
    43f8:	200a      	movs	r0, #10
    43fa:	fb94 f6f0 	sdiv	r6, r4, r0
    43fe:	fb00 4016 	mls	r0, r0, r6, r4
    4402:	7010      	strb	r0, [r2, #0]
				CLIHistoryTail++;
    4404:	3101      	adds	r1, #1
    4406:	b2c9      	uxtb	r1, r1
				if ( CLIHistoryTail == CLIMaxHistorySize )
    4408:	290a      	cmp	r1, #10
    440a:	d001      	beq.n	4410 <CLI_process+0x114>
				CLI_commandLookup();

				// Keep the array circular, discarding the older entries
				if ( CLIHistoryTail < CLIHistoryHead )
					CLIHistoryHead = ( CLIHistoryHead + 1 ) % CLIMaxHistorySize;
				CLIHistoryTail++;
    440c:	7019      	strb	r1, [r3, #0]
    440e:	e003      	b.n	4418 <CLI_process+0x11c>
				if ( CLIHistoryTail == CLIMaxHistorySize )
				{
					CLIHistoryTail = 0;
    4410:	2100      	movs	r1, #0
    4412:	7019      	strb	r1, [r3, #0]
					CLIHistoryHead = 1;
    4414:	2101      	movs	r1, #1
    4416:	7011      	strb	r1, [r2, #0]
				}

				CLIHistoryCurrent = CLIHistoryTail; // 'Up' starts at the last item
    4418:	4a3b      	ldr	r2, [pc, #236]	; (4508 <CLI_process+0x20c>)
    441a:	781b      	ldrb	r3, [r3, #0]
    441c:	7013      	strb	r3, [r2, #0]
inline void CLI_saveHistory( char *buff )
{
	if ( buff == NULL )
	{
		//clear the item
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    441e:	2264      	movs	r2, #100	; 0x64
    4420:	4353      	muls	r3, r2
    4422:	4a3a      	ldr	r2, [pc, #232]	; (450c <CLI_process+0x210>)
    4424:	2100      	movs	r1, #0
    4426:	54d1      	strb	r1, [r2, r3]
    4428:	e7b8      	b.n	439c <CLI_process+0xa0>

		case 0x1B: // Esc / Escape codes
			// Check for other escape sequence

			// \e[ is an escape code in vt100 compatible terminals
			if ( CLILineBufferCurrent >= prev_buf_pos + 3
    442a:	1ca5      	adds	r5, r4, #2
    442c:	429d      	cmp	r5, r3
    442e:	da4d      	bge.n	44cc <CLI_process+0x1d0>
				&& CLILineBuffer[ prev_buf_pos ] == 0x1B
				&& CLILineBuffer[ prev_buf_pos + 1] == 0x5B )
    4430:	190b      	adds	r3, r1, r4
    4432:	785b      	ldrb	r3, [r3, #1]
    4434:	2b5b      	cmp	r3, #91	; 0x5b
    4436:	d149      	bne.n	44cc <CLI_process+0x1d0>
			{
				// Arrow Keys: A (0x41) = Up, B (0x42) = Down, C (0x43) = Right, D (0x44) = Left

				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x41 ) // Hist prev
    4438:	5d4b      	ldrb	r3, [r1, r5]
    443a:	2b41      	cmp	r3, #65	; 0x41
    443c:	d122      	bne.n	4484 <CLI_process+0x188>
				{
					if ( CLIHistoryCurrent == CLIHistoryTail )
    443e:	4f32      	ldr	r7, [pc, #200]	; (4508 <CLI_process+0x20c>)
    4440:	4b2f      	ldr	r3, [pc, #188]	; (4500 <CLI_process+0x204>)
    4442:	f997 2000 	ldrsb.w	r2, [r7]
    4446:	781b      	ldrb	r3, [r3, #0]
    4448:	429a      	cmp	r2, r3
    444a:	d104      	bne.n	4456 <CLI_process+0x15a>
					{
						// Is first time pressing arrow. Save the current buffer
						CLILineBuffer[ prev_buf_pos ] = '\0';
    444c:	2300      	movs	r3, #0
						CLI_saveHistory( CLILineBuffer );
    444e:	4608      	mov	r0, r1
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x41 ) // Hist prev
				{
					if ( CLIHistoryCurrent == CLIHistoryTail )
					{
						// Is first time pressing arrow. Save the current buffer
						CLILineBuffer[ prev_buf_pos ] = '\0';
    4450:	550b      	strb	r3, [r1, r4]
						CLI_saveHistory( CLILineBuffer );
    4452:	f7ff ff17 	bl	4284 <CLI_saveHistory>
					}

					// Grab the previus item from the history if there is one
					if ( RING_PREV( CLIHistoryCurrent ) != RING_PREV( CLIHistoryHead ) )
    4456:	f997 0000 	ldrsb.w	r0, [r7]
    445a:	2100      	movs	r1, #0
    445c:	2209      	movs	r2, #9
    445e:	3801      	subs	r0, #1
    4460:	f7ff fefe 	bl	4260 <CLI_wrap>
    4464:	4b27      	ldr	r3, [pc, #156]	; (4504 <CLI_process+0x208>)
    4466:	4604      	mov	r4, r0
    4468:	7818      	ldrb	r0, [r3, #0]
    446a:	2100      	movs	r1, #0
    446c:	3801      	subs	r0, #1
    446e:	2209      	movs	r2, #9
    4470:	f7ff fef6 	bl	4260 <CLI_wrap>
    4474:	4284      	cmp	r4, r0
						CLIHistoryCurrent = RING_PREV( CLIHistoryCurrent );
    4476:	bf1c      	itt	ne
    4478:	4b23      	ldrne	r3, [pc, #140]	; (4508 <CLI_process+0x20c>)
    447a:	701c      	strbne	r4, [r3, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    447c:	f997 0000 	ldrsb.w	r0, [r7]
    4480:	f7ff ff16 	bl	42b0 <CLI_retreiveHistory>
				}
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x42 ) // Hist next
    4484:	5d73      	ldrb	r3, [r6, r5]
    4486:	2b42      	cmp	r3, #66	; 0x42
    4488:	d120      	bne.n	44cc <CLI_process+0x1d0>
				{
					// Grab the next item from the history if it exists
					if ( RING_NEXT( CLIHistoryCurrent ) != RING_NEXT( CLIHistoryTail ) )
    448a:	4d1f      	ldr	r5, [pc, #124]	; (4508 <CLI_process+0x20c>)
    448c:	f995 0000 	ldrsb.w	r0, [r5]
    4490:	2100      	movs	r1, #0
    4492:	2209      	movs	r2, #9
    4494:	3001      	adds	r0, #1
    4496:	f7ff fee3 	bl	4260 <CLI_wrap>
    449a:	4b19      	ldr	r3, [pc, #100]	; (4500 <CLI_process+0x204>)
    449c:	4604      	mov	r4, r0
    449e:	7818      	ldrb	r0, [r3, #0]
    44a0:	2100      	movs	r1, #0
    44a2:	3001      	adds	r0, #1
    44a4:	2209      	movs	r2, #9
    44a6:	f7ff fedb 	bl	4260 <CLI_wrap>
    44aa:	4284      	cmp	r4, r0
						CLIHistoryCurrent = RING_NEXT( CLIHistoryCurrent );
    44ac:	bf18      	it	ne
    44ae:	702c      	strbne	r4, [r5, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    44b0:	f995 0000 	ldrsb.w	r0, [r5]
			prev_buf_pos++;

			break;
		}
	}
}
    44b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x42 ) // Hist next
				{
					// Grab the next item from the history if it exists
					if ( RING_NEXT( CLIHistoryCurrent ) != RING_NEXT( CLIHistoryTail ) )
						CLIHistoryCurrent = RING_NEXT( CLIHistoryCurrent );
					CLI_retreiveHistory( CLIHistoryCurrent );
    44b8:	f7ff befa 	b.w	42b0 <CLI_retreiveHistory>

			break;

		default:
			// Place a null on the end (to use with string print)
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    44bc:	2200      	movs	r2, #0

			// Output buffer to screen
			dPrint( &CLILineBuffer[prev_buf_pos] );
    44be:	1930      	adds	r0, r6, r4

			// Buffer reset
			prev_buf_pos++;
    44c0:	3401      	adds	r4, #1

			break;

		default:
			// Place a null on the end (to use with string print)
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    44c2:	54ca      	strb	r2, [r1, r3]

			// Output buffer to screen
			dPrint( &CLILineBuffer[prev_buf_pos] );

			// Buffer reset
			prev_buf_pos++;
    44c4:	b2e4      	uxtb	r4, r4
		default:
			// Place a null on the end (to use with string print)
			CLILineBuffer[CLILineBufferCurrent] = '\0';

			// Output buffer to screen
			dPrint( &CLILineBuffer[prev_buf_pos] );
    44c6:	f7fe fd45 	bl	2f54 <Output_putstr>

			// Buffer reset
			prev_buf_pos++;

			break;
    44ca:	e757      	b.n	437c <CLI_process+0x80>
    44cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    44ce:	bf00      	nop
    44d0:	1ffff764 	.word	0x1ffff764
    44d4:	00006caf 	.word	0x00006caf
    44d8:	000071ae 	.word	0x000071ae
    44dc:	1ffff6a8 	.word	0x1ffff6a8
    44e0:	1ffff2bc 	.word	0x1ffff2bc
    44e4:	00007205 	.word	0x00007205
    44e8:	0000720b 	.word	0x0000720b
    44ec:	00004a00 	.word	0x00004a00
    44f0:	00007210 	.word	0x00007210
    44f4:	0000719a 	.word	0x0000719a
    44f8:	000071a0 	.word	0x000071a0
    44fc:	00007214 	.word	0x00007214
    4500:	1ffff738 	.word	0x1ffff738
    4504:	1ffff70d 	.word	0x1ffff70d
    4508:	1ffff2bd 	.word	0x1ffff2bd
    450c:	1ffff2c0 	.word	0x1ffff2c0

00004510 <init_errorLED>:
	// Setup pin - B16 - See Lib/pin_map.mchck for more details on pins
	PORTB_PCR16 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
*/
	// Kiibohd MCHCK Variant
	// Enable pin
	GPIOA_PDDR |= (1<<19);
    4510:	4b06      	ldr	r3, [pc, #24]	; (452c <init_errorLED+0x1c>)
    4512:	681a      	ldr	r2, [r3, #0]
    4514:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    4518:	601a      	str	r2, [r3, #0]

	// Setup pin - A19 - See Lib/pin_map.mchck for more details on pins
	PORTA_PCR19 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    451a:	f5a3 2335 	sub.w	r3, r3, #741376	; 0xb5000
    451e:	f6a3 73c8 	subw	r3, r3, #4040	; 0xfc8
    4522:	f44f 72a2 	mov.w	r2, #324	; 0x144
    4526:	601a      	str	r2, [r3, #0]
    4528:	4770      	bx	lr
    452a:	bf00      	nop
    452c:	400ff014 	.word	0x400ff014

00004530 <errorLED>:
		GPIOB_PCOR |= (1<<16);
	}
*/
	// Kiibohd MCHCK Variant
	// Error LED On (A19)
	if ( on ) {
    4530:	b108      	cbz	r0, 4536 <errorLED+0x6>
		GPIOA_PSOR |= (1<<19);
    4532:	4b04      	ldr	r3, [pc, #16]	; (4544 <errorLED+0x14>)
    4534:	e000      	b.n	4538 <errorLED+0x8>
	}
	// Error LED Off
	else {
		GPIOA_PCOR |= (1<<19);
    4536:	4b04      	ldr	r3, [pc, #16]	; (4548 <errorLED+0x18>)
    4538:	681a      	ldr	r2, [r3, #0]
    453a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    453e:	601a      	str	r2, [r3, #0]
    4540:	4770      	bx	lr
    4542:	bf00      	nop
    4544:	400ff004 	.word	0x400ff004
    4548:	400ff008 	.word	0x400ff008

0000454c <printstrs>:

// ----- Functions -----

// Multiple string Output
void printstrs( char* first, ... )
{
    454c:	b40f      	push	{r0, r1, r2, r3}
    454e:	b507      	push	{r0, r1, r2, lr}
    4550:	ab04      	add	r3, sp, #16
    4552:	f853 0b04 	ldr.w	r0, [r3], #4
	// Initialize the variadic function parameter list
	va_list ap;

	// Get the first parameter
	va_start( ap, first );
    4556:	9301      	str	r3, [sp, #4]
	char *cur = first;

	// Loop through the variadic list until "\0\0\0" is found
	while ( !( cur[0] == '\0' && cur[1] == '\0' && cur[2] == '\0' ) )
    4558:	7803      	ldrb	r3, [r0, #0]
    455a:	b133      	cbz	r3, 456a <printstrs+0x1e>
	{
		// Print out the given string
		Output_putstr( cur );
    455c:	f7fe fcfa 	bl	2f54 <Output_putstr>

		// Get the next argument ready
		cur = va_arg( ap, char* );
    4560:	9b01      	ldr	r3, [sp, #4]
    4562:	1d1a      	adds	r2, r3, #4
    4564:	9201      	str	r2, [sp, #4]
    4566:	6818      	ldr	r0, [r3, #0]
    4568:	e7f6      	b.n	4558 <printstrs+0xc>
	// Get the first parameter
	va_start( ap, first );
	char *cur = first;

	// Loop through the variadic list until "\0\0\0" is found
	while ( !( cur[0] == '\0' && cur[1] == '\0' && cur[2] == '\0' ) )
    456a:	7843      	ldrb	r3, [r0, #1]
    456c:	2b00      	cmp	r3, #0
    456e:	d1f5      	bne.n	455c <printstrs+0x10>
    4570:	7883      	ldrb	r3, [r0, #2]
    4572:	2b00      	cmp	r3, #0
    4574:	d1f2      	bne.n	455c <printstrs+0x10>
		// Get the next argument ready
		cur = va_arg( ap, char* );
	}

	va_end( ap ); // Not required, but good practice
}
    4576:	b003      	add	sp, #12
    4578:	f85d eb04 	ldr.w	lr, [sp], #4
    457c:	b004      	add	sp, #16
    457e:	4770      	bx	lr

00004580 <_print>:
	while ( ( c = pgm_read_byte( s++ ) ) != '\0' )
	{
		Output_putchar( c );
	}
#elif defined(_mk20dx128_) || defined(_mk20dx128vlf5_) || defined(_mk20dx256_) || defined(_mk20dx256vlh7_) // ARM
	Output_putstr( (char*)s );
    4580:	f7fe bce8 	b.w	2f54 <Output_putstr>

00004584 <lenStr>:
	}
}


uint16_t lenStr( char* in )
{
    4584:	4603      	mov	r3, r0
    4586:	461a      	mov	r2, r3
    4588:	3301      	adds	r3, #1
	// Iterator
	char *pos;

	// Loop until null is found
	for ( pos = in; *pos; pos++ );
    458a:	7811      	ldrb	r1, [r2, #0]
    458c:	2900      	cmp	r1, #0
    458e:	d1fa      	bne.n	4586 <lenStr+0x2>

	// Return the difference between the pointers of in and pos (which is the string length)
	return (pos - in);
    4590:	1a10      	subs	r0, r2, r0
}
    4592:	b280      	uxth	r0, r0
    4594:	4770      	bx	lr

00004596 <revsStr>:
	revsStr(out);
}


void revsStr( char* in )
{
    4596:	b510      	push	{r4, lr}
    4598:	4604      	mov	r4, r0

	// Temp storage
	char c;

	// Loop through the string, and reverse the order of the characters
	for ( i = 0, j = lenStr( in ) - 1; i < j; i++, j-- )
    459a:	f7ff fff3 	bl	4584 <lenStr>
    459e:	2200      	movs	r2, #0
    45a0:	1e43      	subs	r3, r0, #1
    45a2:	429a      	cmp	r2, r3
    45a4:	da06      	bge.n	45b4 <revsStr+0x1e>
	{
		c = in[i];
    45a6:	5ca1      	ldrb	r1, [r4, r2]
		in[i] = in[j];
    45a8:	5ce0      	ldrb	r0, [r4, r3]
    45aa:	54a0      	strb	r0, [r4, r2]
		in[j] = c;
    45ac:	54e1      	strb	r1, [r4, r3]

	// Temp storage
	char c;

	// Loop through the string, and reverse the order of the characters
	for ( i = 0, j = lenStr( in ) - 1; i < j; i++, j-- )
    45ae:	3201      	adds	r2, #1
    45b0:	3b01      	subs	r3, #1
    45b2:	e7f6      	b.n	45a2 <revsStr+0xc>
	{
		c = in[i];
		in[i] = in[j];
		in[j] = c;
	}
}
    45b4:	bd10      	pop	{r4, pc}

000045b6 <int8ToStr>:



// String Functions
void int8ToStr( uint8_t in, char* out )
{
    45b6:	b530      	push	{r4, r5, lr}
    45b8:	4603      	mov	r3, r0
	// Position and sign containers
	uint8_t pos;
	pos = 0;
    45ba:	2200      	movs	r2, #0

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    45bc:	250a      	movs	r5, #10
    45be:	fbb3 f0f5 	udiv	r0, r3, r5
    45c2:	fb05 3310 	mls	r3, r5, r0, r3
    45c6:	3330      	adds	r3, #48	; 0x30
    45c8:	1c54      	adds	r4, r2, #1
    45ca:	548b      	strb	r3, [r1, r2]
	}
	while ( (in /= 10) > 0 );
    45cc:	f010 03ff 	ands.w	r3, r0, #255	; 0xff
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    45d0:	b2e4      	uxtb	r4, r4
	}
	while ( (in /= 10) > 0 );
    45d2:	d001      	beq.n	45d8 <int8ToStr+0x22>
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    45d4:	4622      	mov	r2, r4
    45d6:	e7f1      	b.n	45bc <int8ToStr+0x6>
	}
	while ( (in /= 10) > 0 );

	// Append null
	out[pos] = '\0';
    45d8:	550b      	strb	r3, [r1, r4]

	// Reverse the string to the correct order
	revsStr(out);
    45da:	4608      	mov	r0, r1
}
    45dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    45e0:	f7ff bfd9 	b.w	4596 <revsStr>

000045e4 <printInt8>:



// Number Printing Functions
void printInt8( uint8_t in )
{
    45e4:	b507      	push	{r0, r1, r2, lr}
	// Max number of characters is 3 + 1 for null
	char tmpStr[4];

	// Convert number
	int8ToStr( in, tmpStr );
    45e6:	a901      	add	r1, sp, #4
    45e8:	f7ff ffe5 	bl	45b6 <int8ToStr>

	// Print number
	dPrintStr( tmpStr );
    45ec:	a801      	add	r0, sp, #4
    45ee:	f7fe fcb1 	bl	2f54 <Output_putstr>
}
    45f2:	b003      	add	sp, #12
    45f4:	f85d fb04 	ldr.w	pc, [sp], #4

000045f8 <int16ToStr>:
	revsStr(out);
}


void int16ToStr( uint16_t in, char* out )
{
    45f8:	b530      	push	{r4, r5, lr}
    45fa:	4603      	mov	r3, r0
	// Position and sign containers
	uint16_t pos;
	pos = 0;
    45fc:	2200      	movs	r2, #0

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    45fe:	250a      	movs	r5, #10
    4600:	fbb3 f4f5 	udiv	r4, r3, r5
    4604:	fb05 3314 	mls	r3, r5, r4, r3
    4608:	3330      	adds	r3, #48	; 0x30
    460a:	1c50      	adds	r0, r2, #1
    460c:	548b      	strb	r3, [r1, r2]
	}
	while ( (in /= 10) > 0 );
    460e:	b2a3      	uxth	r3, r4
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    4610:	b280      	uxth	r0, r0
	}
	while ( (in /= 10) > 0 );
    4612:	b10b      	cbz	r3, 4618 <int16ToStr+0x20>
	pos = 0;

	// Evaluate through digits as decimal
	do
	{
		out[pos++] = in % 10 + '0';
    4614:	4602      	mov	r2, r0
    4616:	e7f2      	b.n	45fe <int16ToStr+0x6>
	}
	while ( (in /= 10) > 0 );

	// Append null
	out[pos] = '\0';
    4618:	540b      	strb	r3, [r1, r0]

	// Reverse the string to the correct order
	revsStr(out);
}
    461a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    461e:	4608      	mov	r0, r1
    4620:	f7ff bfb9 	b.w	4596 <revsStr>

00004624 <printInt16>:
	// Print number
	dPrintStr( tmpStr );
}

void printInt16( uint16_t in )
{
    4624:	b507      	push	{r0, r1, r2, lr}
	// Max number of characters is 5 + 1 for null
	char tmpStr[6];

	// Convert number
	int16ToStr( in, tmpStr );
    4626:	4669      	mov	r1, sp
    4628:	f7ff ffe6 	bl	45f8 <int16ToStr>

	// Print number
	dPrintStr( tmpStr );
    462c:	4668      	mov	r0, sp
    462e:	f7fe fc91 	bl	2f54 <Output_putstr>
}
    4632:	b003      	add	sp, #12
    4634:	f85d fb04 	ldr.w	pc, [sp], #4

00004638 <hexToStr_op>:
	revsStr(out);
}


void hexToStr_op( uint16_t in, char* out, uint8_t op )
{
    4638:	b570      	push	{r4, r5, r6, lr}
	// Position container
	uint16_t pos = 0;
    463a:	2400      	movs	r4, #0

	// Evaluate through digits as hex
	do
	{
		uint16_t cur = in % 16;
    463c:	f000 050f 	and.w	r5, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    4640:	2d09      	cmp	r5, #9
    4642:	bf8c      	ite	hi
    4644:	2637      	movhi	r6, #55	; 0x37
    4646:	2630      	movls	r6, #48	; 0x30
    4648:	1c63      	adds	r3, r4, #1
    464a:	4435      	add	r5, r6
	}
	while ( (in /= 16) > 0 );
    464c:	0900      	lsrs	r0, r0, #4

	// Evaluate through digits as hex
	do
	{
		uint16_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    464e:	b29b      	uxth	r3, r3
    4650:	550d      	strb	r5, [r1, r4]
	}
	while ( (in /= 16) > 0 );
    4652:	d001      	beq.n	4658 <hexToStr_op+0x20>

	// Evaluate through digits as hex
	do
	{
		uint16_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    4654:	461c      	mov	r4, r3
    4656:	e7f1      	b.n	463c <hexToStr_op+0x4>
	}
	while ( (in /= 16) > 0 );

	// Output formatting options
	switch ( op )
    4658:	2a02      	cmp	r2, #2
    465a:	d00c      	beq.n	4676 <hexToStr_op+0x3e>
    465c:	2a04      	cmp	r2, #4
    465e:	d00a      	beq.n	4676 <hexToStr_op+0x3e>
    4660:	2a01      	cmp	r2, #1
    4662:	d10f      	bne.n	4684 <hexToStr_op+0x4c>
	{
	case 1: // Add 0x
		out[pos++] = 'x';
    4664:	2278      	movs	r2, #120	; 0x78
    4666:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    4668:	1ce3      	adds	r3, r4, #3

	// Output formatting options
	switch ( op )
	{
	case 1: // Add 0x
		out[pos++] = 'x';
    466a:	3402      	adds	r4, #2
		out[pos++] = '0';
    466c:	b2a4      	uxth	r4, r4
    466e:	2230      	movs	r2, #48	; 0x30
    4670:	b29b      	uxth	r3, r3
    4672:	550a      	strb	r2, [r1, r4]
		break;
    4674:	e006      	b.n	4684 <hexToStr_op+0x4c>
	case 2: //  8-bit padding
	case 4: // 16-bit padding
		while ( pos < op )
    4676:	4293      	cmp	r3, r2
    4678:	d204      	bcs.n	4684 <hexToStr_op+0x4c>
			out[pos++] = '0';
    467a:	1c58      	adds	r0, r3, #1
    467c:	2430      	movs	r4, #48	; 0x30
    467e:	54cc      	strb	r4, [r1, r3]
    4680:	b283      	uxth	r3, r0
    4682:	e7f8      	b.n	4676 <hexToStr_op+0x3e>
		break;
	}

	// Append null
	out[pos] = '\0';
    4684:	2200      	movs	r2, #0
    4686:	54ca      	strb	r2, [r1, r3]

	// Reverse the string to the correct order
	revsStr(out);
    4688:	4608      	mov	r0, r1
}
    468a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    468e:	f7ff bf82 	b.w	4596 <revsStr>

00004692 <printHex_op>:
	// Print number
	dPrintStr( tmpStr );
}

void printHex_op( uint16_t in, uint8_t op )
{
    4692:	b507      	push	{r0, r1, r2, lr}
    4694:	460a      	mov	r2, r1
	// e.g. "0xFFFF\0"
	// op 2 and 4 require fewer characters (2+1 and 4+1 respectively)
	char tmpStr[7];

	// Convert number
	hexToStr_op( in, tmpStr, op );
    4696:	4669      	mov	r1, sp
    4698:	f7ff ffce 	bl	4638 <hexToStr_op>

	// Print number
	dPrintStr( tmpStr );
    469c:	4668      	mov	r0, sp
    469e:	f7fe fc59 	bl	2f54 <Output_putstr>
}
    46a2:	b003      	add	sp, #12
    46a4:	f85d fb04 	ldr.w	pc, [sp], #4

000046a8 <hex32ToStr_op>:
	revsStr(out);
}


void hex32ToStr_op( uint32_t in, char* out, uint8_t op )
{
    46a8:	b570      	push	{r4, r5, r6, lr}
	// Position container
	uint32_t pos = 0;
    46aa:	2400      	movs	r4, #0

	// Evaluate through digits as hex
	do
	{
		uint32_t cur = in % 16;
    46ac:	f000 050f 	and.w	r5, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    46b0:	2d09      	cmp	r5, #9
    46b2:	bf8c      	ite	hi
    46b4:	2637      	movhi	r6, #55	; 0x37
    46b6:	2630      	movls	r6, #48	; 0x30
    46b8:	4435      	add	r5, r6
	}
	while ( (in /= 16) > 0 );
    46ba:	0900      	lsrs	r0, r0, #4
    46bc:	f104 0301 	add.w	r3, r4, #1

	// Evaluate through digits as hex
	do
	{
		uint32_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    46c0:	550d      	strb	r5, [r1, r4]
	}
	while ( (in /= 16) > 0 );
    46c2:	d001      	beq.n	46c8 <hex32ToStr_op+0x20>

	// Evaluate through digits as hex
	do
	{
		uint32_t cur = in % 16;
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    46c4:	461c      	mov	r4, r3
    46c6:	e7f1      	b.n	46ac <hex32ToStr_op+0x4>
	}
	while ( (in /= 16) > 0 );

	// Output formatting options
	switch ( op )
    46c8:	2a02      	cmp	r2, #2
    46ca:	d00a      	beq.n	46e2 <hex32ToStr_op+0x3a>
    46cc:	2a04      	cmp	r2, #4
    46ce:	d008      	beq.n	46e2 <hex32ToStr_op+0x3a>
    46d0:	2a01      	cmp	r2, #1
    46d2:	d10c      	bne.n	46ee <hex32ToStr_op+0x46>
	{
	case 1: // Add 0x
		out[pos++] = 'x';
    46d4:	2278      	movs	r2, #120	; 0x78
    46d6:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    46d8:	1ce3      	adds	r3, r4, #3
    46da:	440c      	add	r4, r1
    46dc:	2230      	movs	r2, #48	; 0x30
    46de:	70a2      	strb	r2, [r4, #2]
		break;
    46e0:	e005      	b.n	46ee <hex32ToStr_op+0x46>
	case 2: //  8-bit padding
	case 4: // 16-bit padding
		while ( pos < op )
    46e2:	4293      	cmp	r3, r2
    46e4:	d203      	bcs.n	46ee <hex32ToStr_op+0x46>
			out[pos++] = '0';
    46e6:	2030      	movs	r0, #48	; 0x30
    46e8:	54c8      	strb	r0, [r1, r3]
    46ea:	3301      	adds	r3, #1
    46ec:	e7f9      	b.n	46e2 <hex32ToStr_op+0x3a>
		break;
	}

	// Append null
	out[pos] = '\0';
    46ee:	2200      	movs	r2, #0
    46f0:	54ca      	strb	r2, [r1, r3]

	// Reverse the string to the correct order
	revsStr(out);
    46f2:	4608      	mov	r0, r1
}
    46f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	// Append null
	out[pos] = '\0';

	// Reverse the string to the correct order
	revsStr(out);
    46f8:	f7ff bf4d 	b.w	4596 <revsStr>

000046fc <printHex32_op>:
	// Print number
	dPrintStr( tmpStr );
}

void printHex32_op( uint32_t in, uint8_t op )
{
    46fc:	b507      	push	{r0, r1, r2, lr}
    46fe:	460a      	mov	r2, r1
	// e.g. "0xFFFF\0"
	// op 2 and 4 require fewer characters (2+1 and 4+1 respectively)
	char tmpStr[7];

	// Convert number
	hex32ToStr_op( in, tmpStr, op );
    4700:	4669      	mov	r1, sp
    4702:	f7ff ffd1 	bl	46a8 <hex32ToStr_op>

	// Print number
	dPrintStr( tmpStr );
    4706:	4668      	mov	r0, sp
    4708:	f7fe fc24 	bl	2f54 <Output_putstr>
}
    470c:	b003      	add	sp, #12
    470e:	f85d fb04 	ldr.w	pc, [sp], #4

00004712 <eqStr>:
	return (pos - in);
}


int16_t eqStr( char* str1, char* str2 )
{
    4712:	b510      	push	{r4, lr}
    4714:	4603      	mov	r3, r0
	// Scan each string for NULLs and whether they are the same
	while( *str1 != '\0' && *str1++ == *str2++ );
    4716:	f810 2b01 	ldrb.w	r2, [r0], #1
    471a:	b122      	cbz	r2, 4726 <eqStr+0x14>
    471c:	f811 4b01 	ldrb.w	r4, [r1], #1
    4720:	4294      	cmp	r4, r2
    4722:	4603      	mov	r3, r0
    4724:	d0f6      	beq.n	4714 <eqStr+0x2>

	// If the strings are still identical (i.e. both NULL), then return -1, otherwise current *str1
	// If *str1 is 0, then str1 ended (and str1 is "like" str2), otherwise strings are different
	return *--str1 == *--str2 ? -1 : *++str1;
    4726:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    472a:	f811 2c01 	ldrb.w	r2, [r1, #-1]
    472e:	4290      	cmp	r0, r2
    4730:	bf14      	ite	ne
    4732:	7818      	ldrbne	r0, [r3, #0]
    4734:	f64f 70ff 	movweq	r0, #65535	; 0xffff
}
    4738:	b200      	sxth	r0, r0
    473a:	bd10      	pop	{r4, pc}

0000473c <numToInt>:

int numToInt( char* in )
{
    473c:	b570      	push	{r4, r5, r6, lr}
    473e:	4601      	mov	r1, r0
	char* lsd = in;
	char* msd = in;

	int total = 0;
	int sign = 1; // Default to positive
	uint8_t base = 10; // Use base 10 by default TODO Add support for bases other than 10 and 16
    4740:	250a      	movs	r5, #10
	// Pointers to the LSD (Least Significant Digit) and MSD
	char* lsd = in;
	char* msd = in;

	int total = 0;
	int sign = 1; // Default to positive
    4742:	2601      	movs	r6, #1
    4744:	460a      	mov	r2, r1
	uint8_t base = 10; // Use base 10 by default TODO Add support for bases other than 10 and 16

	// Scan the string once to determine the length
	while ( *lsd != '\0' )
    4746:	f811 3b01 	ldrb.w	r3, [r1], #1
    474a:	b193      	cbz	r3, 4772 <numToInt+0x36>
	{
		// Check for positive/negative
		switch ( *lsd++ )
    474c:	2b2b      	cmp	r3, #43	; 0x2b
    474e:	460a      	mov	r2, r1
    4750:	d00d      	beq.n	476e <numToInt+0x32>
    4752:	d802      	bhi.n	475a <numToInt+0x1e>
    4754:	2b20      	cmp	r3, #32
    4756:	d00a      	beq.n	476e <numToInt+0x32>
    4758:	e003      	b.n	4762 <numToInt+0x26>
    475a:	2b2d      	cmp	r3, #45	; 0x2d
    475c:	d003      	beq.n	4766 <numToInt+0x2a>
    475e:	2b78      	cmp	r3, #120	; 0x78
    4760:	d004      	beq.n	476c <numToInt+0x30>
    4762:	4602      	mov	r2, r0
    4764:	e003      	b.n	476e <numToInt+0x32>
		{
		// Fall through is intentional, only do something on negative, ignore the rest
		// Update the MSD to remove leading spaces and signs
		case '-': sign = -1;
    4766:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    476a:	e000      	b.n	476e <numToInt+0x32>
		case '+':
		case ' ':
			msd = lsd;
			break;
		case 'x': // Hex Mode
			base = 0x10;
    476c:	2510      	movs	r5, #16
		// Check for positive/negative
		switch ( *lsd++ )
		{
		// Fall through is intentional, only do something on negative, ignore the rest
		// Update the MSD to remove leading spaces and signs
		case '-': sign = -1;
    476e:	4610      	mov	r0, r2
    4770:	e7e8      	b.n	4744 <numToInt+0x8>
			break;
		}
	}

	// Process string depending on which base
	switch ( base )
    4772:	2d0a      	cmp	r5, #10
    4774:	d004      	beq.n	4780 <numToInt+0x44>
    4776:	2d10      	cmp	r5, #16
    4778:	d122      	bne.n	47c0 <numToInt+0x84>
    477a:	4614      	mov	r4, r2
    477c:	2101      	movs	r1, #1
    477e:	e014      	b.n	47aa <numToInt+0x6e>
    4780:	2101      	movs	r1, #1
	{
	case 10: // Decimal
		// Rescan the string from the LSD to MSD to convert it to a decimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 10 )
    4782:	4282      	cmp	r2, r0
    4784:	4614      	mov	r4, r2
    4786:	d91b      	bls.n	47c0 <numToInt+0x84>
			total += ( (*--lsd) - '0' ) * digit;
    4788:	f814 4c01 	ldrb.w	r4, [r4, #-1]
    478c:	3c30      	subs	r4, #48	; 0x30
    478e:	fb01 3304 	mla	r3, r1, r4, r3
	// Process string depending on which base
	switch ( base )
	{
	case 10: // Decimal
		// Rescan the string from the LSD to MSD to convert it to a decimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 10 )
    4792:	240a      	movs	r4, #10
    4794:	3a01      	subs	r2, #1
    4796:	4361      	muls	r1, r4
    4798:	e7f3      	b.n	4782 <numToInt+0x46>

	case 0x10: // Hex
		// Rescan the string from the LSD to MSD to convert it to a hexadecimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
		{
			if    ( *--lsd <= '9' ) total += ( *lsd - '0' ) * digit;
    479a:	f814 2d01 	ldrb.w	r2, [r4, #-1]!
    479e:	2a39      	cmp	r2, #57	; 0x39
    47a0:	d806      	bhi.n	47b0 <numToInt+0x74>
    47a2:	3a30      	subs	r2, #48	; 0x30
			else if ( *lsd <= 'F' ) total += ( *lsd - 'A' + 10 ) * digit;
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    47a4:	fb01 3302 	mla	r3, r1, r2, r3
			total += ( (*--lsd) - '0' ) * digit;
		break;

	case 0x10: // Hex
		// Rescan the string from the LSD to MSD to convert it to a hexadecimal number
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    47a8:	0109      	lsls	r1, r1, #4
    47aa:	4284      	cmp	r4, r0
    47ac:	d8f5      	bhi.n	479a <numToInt+0x5e>
    47ae:	e007      	b.n	47c0 <numToInt+0x84>
		{
			if    ( *--lsd <= '9' ) total += ( *lsd - '0' ) * digit;
			else if ( *lsd <= 'F' ) total += ( *lsd - 'A' + 10 ) * digit;
    47b0:	2a46      	cmp	r2, #70	; 0x46
    47b2:	d801      	bhi.n	47b8 <numToInt+0x7c>
    47b4:	3a37      	subs	r2, #55	; 0x37
    47b6:	e7f5      	b.n	47a4 <numToInt+0x68>
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    47b8:	2a66      	cmp	r2, #102	; 0x66
    47ba:	d8f5      	bhi.n	47a8 <numToInt+0x6c>
    47bc:	3a57      	subs	r2, #87	; 0x57
    47be:	e7f1      	b.n	47a4 <numToInt+0x68>
		break;
	}

	// Propagate sign and return
	return total * sign;
}
    47c0:	fb06 f003 	mul.w	r0, r6, r3
    47c4:	bd70      	pop	{r4, r5, r6, pc}
    47c6:	6146      	.short	0x6146
    47c8:	21746c75 	.word	0x21746c75
    47cc:	4e000a0d 	.word	0x4e000a0d
    47d0:	0d21494d 	.word	0x0d21494d
    47d4:	6148000a 	.word	0x6148000a
    47d8:	46206472 	.word	0x46206472
    47dc:	746c7561 	.word	0x746c7561
    47e0:	43532021 	.word	0x43532021
    47e4:	46485f42 	.word	0x46485f42
    47e8:	203a5253 	.word	0x203a5253
    47ec:	6d654d00 	.word	0x6d654d00
    47f0:	2079726f 	.word	0x2079726f
    47f4:	616e614d 	.word	0x616e614d
    47f8:	20726567 	.word	0x20726567
    47fc:	6c756146 	.word	0x6c756146
    4800:	53202174 	.word	0x53202174
    4804:	435f4243 	.word	0x435f4243
    4808:	3a525346 	.word	0x3a525346
    480c:	53200020 	.word	0x53200020
    4810:	4d5f4243 	.word	0x4d5f4243
    4814:	3a52414d 	.word	0x3a52414d
    4818:	75420020 	.word	0x75420020
    481c:	61462073 	.word	0x61462073
    4820:	21746c75 	.word	0x21746c75
    4824:	42435320 	.word	0x42435320
    4828:	5346435f 	.word	0x5346435f
    482c:	00203a52 	.word	0x00203a52
    4830:	42435320 	.word	0x42435320
    4834:	4146425f 	.word	0x4146425f
    4838:	00203a52 	.word	0x00203a52
    483c:	67617355 	.word	0x67617355
    4840:	61462065 	.word	0x61462065
    4844:	21746c75 	.word	0x21746c75
    4848:	42435320 	.word	0x42435320
    484c:	5346435f 	.word	0x5346435f
    4850:	00203a52 	.word	0x00203a52

00004854 <sys_reset_to_loader_magic>:
    4854:	527f00ff 54455345 204f5420 44414f4c     ...RESET TO LOAD
    4864:	007f5245 6e4500ff                                ER....

0000486a <matrixDebugCLIDict_DescEntry>:
    486a:	62616e45 2073656c 7274616d 64207869     Enables matrix d
    487a:	67756265 646f6d20 70202c65 746e6972     ebug mode, print
    488a:	756f2073 61652074 73206863 206e6163     s out each scan 
    489a:	65646f63 090a0d2e 20664909 75677261     code.....If argu
    48aa:	746e656d 335b1b20 1b546d35 206d305b     ment .[35mT.[0m 
    48ba:	67207369 6e657669 7270202c 73746e69     is given, prints
    48ca:	74756f20 63616520 63732068 63206e61      out each scan c
    48da:	2065646f 74617473 72742065 69736e61     ode state transi
    48ea:	6e6f6974 5b1b002e 32333b31 464e496d     tion...[1;32mINF
    48fa:	305b1b4f 202d206d 7274614d 44207869     O.[0m - Matrix D
    490a:	67756265 646f4d20 00203a65 3b315b1b     ebug Mode: ..[1;
    491a:	496d3233 1b4f464e 206d305b 6f43202d     32mINFO.[0m - Co
    492a:	6e6d756c 20203a73 315b1b00 6d32333b     lumns:  ..[1;32m
    493a:	4f464e49 6d305b1b 52202d20 3a73776f     INFO.[0m - Rows:
    494a:	20202020 5b1b0020 32333b31 464e496d          ..[1;32mINF
    495a:	305b1b4f 202d206d 2078614d 7379654b     O.[0m - Max Keys
    496a:	1b00203a 4f6d315b 6d305b1b 315b1b00     : ..[1mO.[0m..[1
    497a:	6d33333b 305b1b50 5b1b006d 32333b31     ;33mP.[0m..[1;32
    498a:	5b1b486d 1b006d30 333b315b 1b526d35     mH.[0m..[1;35mR.
    499a:	006d305b 3b315b1b 496d3133 6d305b1b     [0m..[1;31mI.[0m
    49aa:	315b1b00 333b353b 52456d31 1b524f52     ..[1;5;31mERROR.
    49ba:	206d305b 614d202d 78697274 61637320     [0m - Matrix sca
    49ca:	7562206e 20212167 6f706552 6d207472     n bug!! Report m
    49da:	0a0d2165 315b1b00 6d32333b 4f464e49     e!....[1;32mINFO
    49ea:	6d305b1b 4d202d20 73207861 736e6163     .[0m - Max scans
    49fa:	2020203a 00202020 3b315b1b 496d3233     :      ..[1;32mI
    4a0a:	1b4f464e 206d305b 7250202d 6f697665     NFO.[0m - Previo
    4a1a:	73207375 736e6163 1b00203a 333b315b     us scans: ..[1;3
    4a2a:	4e496d32 5b1b4f46 2d206d30 61635320     2mINFO.[0m - Sca
    4a3a:	754e206e 7265626d 2020203a 6b3c0020     n Number:    .<k
    4a4a:	3a3e7965 6572703c 756f6976 74732073     ey>:<previous st
    4a5a:	3e657461 7275633c 746e6572 61747320     ate><current sta
    4a6a:	203e6574 7463613c 20657669 6e756f63     te> <active coun
    4a7a:	3c203e74 63616e69 65766974 756f6320     t> <inactive cou
    4a8a:	003e746e 6d315b1b 3a007830 78302000     nt>..[1m0x.:. 0x
    4a9a:	74616d00 44786972 67756265 74616d00     .matrixDebug.mat
    4aaa:	53786972 65746174 69725000                       rixState.

00004ab3 <matrixStateCLIDict_DescEntry>:
    4ab3:	6e697250 6f207374 74207475 63206568     Prints out the c
    4ac3:	65727275 7320746e 206e6163 6c626174     urrent scan tabl
    4ad3:	204e2065 656d6974 0a0d2e73 1b200909     e N times..... .
    4ae3:	4f6d315b 6d305b1b 4f202d20 202c6666     [1mO.[0m - Off, 
    4af3:	3b315b1b 506d3333 6d305b1b 50202d20     .[1;33mP.[0m - P
    4b03:	73736572 5b1b202c 32333b31 5b1b486d     ress, .[1;32mH.[
    4b13:	2d206d30 6c6f4820 1b202c64 333b315b     0m - Hold, .[1;3
    4b23:	1b526d35 206d305b 6552202d 7361656c     5mR.[0m - Releas
    4b33:	1b202c65 333b315b 1b496d31 206d305b     e, .[1;31mI.[0m 
    4b43:	6e49202d 696c6176 614d0064                       - Invalid.

00004b4d <matrixCLIDictName>:
    4b4d:	7274614d 4d207869 6c75646f 6f432065     Matrix Module Co
    4b5d:	6e616d6d 9b007364                                mmands.

00004b64 <matrixCLIDict>:
    4b64:	00004a9b 0000486a 00001365 00004aa7     .J..jH..e....J..
    4b74:	00004ab3 00001341 00000000 00000000     .J..A...........
    4b84:	00000000                                ....

00004b88 <scanCLIDictName>:
    4b88:	6e616353 646f4d20 20656c75 6d6d6f43     Scan Module Comm
    4b98:	73646e61 73754300 416d6f74 6f697463     ands.CustomActio
    4ba8:	63615f6e 6e6f6974 61635f31 69626170     n_action1_capabi
    4bb8:	7974696c 1b002928 333b315b 4e496d32     lity()..[1;32mIN
    4bc8:	5b1b4f46 2d206d30 74634120 316e6f69     FO.[0m - Action1
    4bd8:	43000a0d 6f747375 7463416d 5f6e6f69     ...CustomAction_
    4be8:	636f6c62 6c6f486b 61635f64 69626170     blockHold_capabi
    4bf8:	7974696c 62737528 65646f43 5b1b0029     lity(usbCode)..[
    4c08:	32333b31 464e496d 305b1b4f 202d206d     1;32mINFO.[0m - 
    4c18:	636f6c42 676e696b 79654b20 1b00203a     Blocking Key: ..
    4c28:	333b315b 4e496d32 5b1b4f46 2d206d30     [1;32mINFO.[0m -
    4c38:	626e5520 6b636f6c 20676e69 3a79654b      Unblocking Key:
    4c48:	75430020 6d6f7473 69746341 625f6e6f      .CustomAction_b
    4c58:	6b636f6c 5f79654b 61706163 696c6962     lockKey_capabili
    4c68:	75287974 6f436273 00296564 6f686365     ty(usbCode).echo
    4c78:	00000000                                ....

00004c7c <scanCLIDict>:
    4c7c:	00004c74 00004c94 0000183d 00000000     tL...L..=.......
    4c8c:	00000000 00000000                       ........

00004c94 <echoCLIDict_DescEntry>:
    4c94:	6d617845 20656c70 6d6d6f63 2c646e61     Example command,
    4ca4:	68636520 7420736f 61206568 6d756772      echos the argum
    4cb4:	73746e65 0000002e                       ents....

00004cbc <layer1_tl_0x34>:
    4cbc:	00000001 0000004c                       ....L...

00004cc4 <default_tl_0x0D>:
    4cc4:	00000001 00000011                       ........

00004ccc <tm13_guide>:
    4ccc:	23010001 2e0e0100                                ...#.

00004cd1 <rm34_guide>:
    4cd1:	002e0e01                                ....

00004cd5 <rm95_guide>:
    4cd5:	003c0e01 00000000                                ..<....

00004cdc <layer1_tl_0x2F>:
    4cdc:	00000000                                ....

00004ce0 <tm34_guide>:
    4ce0:	0c010001 00000000                       ........

00004ce8 <CapabilitiesList>:
    4ce8:	000018b5 00000000 000018d1 00000001     ................
    4cf8:	00001945 00000001 00001f65 00000002     E.......e.......
    4d08:	00001f8d 00000002 00001fb5 00000001     ................
    4d18:	00001f3d 00000002 00001f15 00000003     =...............
    4d28:	00002b85 00000002 00002c49 00000000     .+......I,......
    4d38:	00002c8d 00000000 00002cbd 00000000     .,.......,......
    4d48:	00002bdd 00000000 00002bf1 00000001     .+.......+......
    4d58:	00002cf1 00000001                       .,......

00004d60 <tm97_guide>:
    4d60:	25010001 1f0e0100                                ...%.

00004d65 <rm54_guide>:
    4d65:	001f0e01                                ....

00004d69 <tm96_guide>:
    4d69:	03010001 0c0e0100                                .....

00004d6e <rm36_guide>:
    4d6e:	000c0e01                                ....

00004d72 <tm35_guide>:
    4d72:	2e010001 01000100                                .....

00004d77 <tm36_guide>:
    4d77:	17010001 01000100                                .....

00004d7c <tm87_guide>:
    4d7c:	08010001 01000100                                .....

00004d81 <tm60_guide>:
    4d81:	25010001 01000000                                ...%...

00004d88 <default_tl_0x10>:
    4d88:	00000001 0000000e                       ........

00004d90 <tm27_guide>:
    4d90:	1e010001 420e0100                                .....

00004d95 <rm89_guide>:
    4d95:	00420e01                                ..B.

00004d99 <rm5_guide>:
    4d99:	00e50e01                                ....

00004d9d <rm38_guide>:
    4d9d:	00010301 080e0100                                .....

00004da2 <rm62_guide>:
    4da2:	00080e01                                ....

00004da6 <tm38_guide>:
    4da6:	3d010001 01000100                                ...=.

00004dab <tm62_guide>:
    4dab:	12010001 330e0100                                .....

00004db0 <rm44_guide>:
    4db0:	00330e01                                ..3.

00004db4 <rm25_guide>:
    4db4:	00090e01                                ....

00004db8 <tm56_guide>:
    4db8:	16010001 4b0e0100                                .....

00004dbd <rm64_guide>:
    4dbd:	004b0e01                                ..K.

00004dc1 <tm64_guide>:
    4dc1:	26010001 1a0e0100                                ...&.

00004dc6 <rm19_guide>:
    4dc6:	001a0e01                                ....

00004dca <rm35_guide>:
    4dca:	00190e01                                ....

00004dce <rm51_guide>:
    4dce:	001c0e01 00010000                                ......

00004dd4 <default_tl_0x1A>:
    4dd4:	00000001 00000021                       ....!...

00004ddc <tm32_guide>:
    4ddc:	31010001 6e655300                                ...1.

00004de1 <keyReleaseCLIDict_DescEntry>:
    4de1:	646e6553 79656b20 6c65722d 65736165     Send key-release
    4df1:	65766520 7420746e 616d206f 206f7263      event to macro 
    4e01:	75646f6d 202e656c 6c707544 74616369     module. Duplicat
    4e11:	68207365 20657661 65646e75 656e6966     es have undefine
    4e21:	65622064 69766168 2e72756f 09090a0d     d behaviour.....
    4e31:	35335b1b 3031536d 6d305b1b 61635320     .[35mS10.[0m Sca
    4e41:	646f636e 78302065 01004130                       ncode 0x0A.

00004e4c <default_tl_0x1C>:
    4e4c:	00000001 00000029                       ....)...

00004e54 <rm15_guide>:
    4e54:	00360e01                                ..6.

00004e58 <default_tl_0x1D>:
    4e58:	00000001 00000018                       ........

00004e60 <rm46_guide>:
    4e60:	001d0e01                                ....

00004e64 <default_tl_0x1E>:
    4e64:	00000001 0000001b                       ........

00004e6c <default_tl_0x1F>:
    4e6c:	00000001 0000000b                       ........

00004e74 <tm90_guide>:
    4e74:	09010001 0e0e0100                                .....

00004e79 <rm60_guide>:
    4e79:	000e0e01 3b315b1b 496d3233 1b4f464e     .....[1;32mINFO.
    4e89:	206d305b 6143202d 69626170 6974696c     [0m - Capabiliti
    4e99:	4c207365 20747369 090a0d00 315b1b00     es List ......[1
    4ea9:	6d32333b 4f464e49 6d305b1b 4b202d20     ;32mINFO.[0m - K
    4eb9:	315b1b00 6d33333b 4e524157 1b474e49     ..[1;33mWARNING.
    4ec9:	206d305b 6c66202d 4d687361 4565646f     [0m - flashModeE
    4ed9:	6c62616e 6e206465 7320746f 202c7465     nabled not set, 
    4ee9:	636e6163 696c6c65 6620676e 776d7269     cancelling firmw
    4ef9:	20657261 6f6c6572 2e2e6461 000a0d2e     are reload......
    4f09:	3b315b1b 496d3233 1b4f464e 206d305b     .[1;32mINFO.[0m 
    4f19:	6553202d 6c662074 4d687361 4565646f     - Set flashModeE
    4f29:	6c62616e 74206465 2031206f 79206e69     nabled to 1 in y
    4f39:	2072756f 206c6c6b 666e6f63 72756769     our kll configur
    4f49:	6f697461 1b002e6e 333b315b 4e496d32     ation...[1;32mIN
    4f59:	5b1b4f46 2d206d30 79614c20 44207265     FO.[0m - Layer D
    4f69:	67756265 646f4d20 00203a65 3b315b1b     ebug Mode: ..[1;
    4f79:	496d3233 1b4f464e 206d305b 6553202d     32mINFO.[0m - Se
    4f89:	6e697474 614c2067 20726579 7420004c     tting Layer L. t
    4f99:	202d206f 315b1b00 6d32333b 4f464e49     o - ..[1;32mINFO
    4fa9:	6d305b1b 4d202d20 6f726361 62654420     .[0m - Macro Deb
    4fb9:	4d206775 3a65646f 5b1b0020 32333b31     ug Mode: ..[1;32
    4fc9:	464e496d 305b1b4f 202d206d 7263614d     mINFO.[0m - Macr
    4fd9:	7250206f 7365636f 676e6973 646f4d20     o Processing Mod
    4fe9:	00203a65 3b315b1b 496d3233 1b4f464e     e: ..[1;32mINFO.
    4ff9:	206d305b 614c202d 20726579 7473694c     [0m - Layer List
    5009:	203a4400 4f31646d 6c726576 2b207961     .D: md1Overlay +
    5019:	64747320 636e7546 0070614d 315b1b20      stdFuncMap. .[1
    5029:	6564286d 6c756166 5b1b2974 0d006d30     m(default).[0m..
    5039:	2009090a 6579614c 74532072 3a657461     ... Layer State:
    5049:	46200020 74737269 203e2d20 7473614c      . First -> Last
    5059:	646e4920 73656369 2000203a 00203e2d      Indices: . -> .
    5069:	68203a31 70626b68 00326f72 3b315b1b     1: hhkbpro2..[1;
    5079:	496d3233 1b4f464e 206d305b 6550202d     32mINFO.[0m - Pe
    5089:	6e69646e 654b2067 76452079 73746e65     nding Key Events
    5099:	2000203a 1b00203a 333b315b 4e496d32     : . : ..[1;32mIN
    50a9:	5b1b4f46 2d206d30 6e655020 676e6964     FO.[0m - Pending
    50b9:	69725420 72656767 63614d20 3a736f72      Trigger Macros:
    50c9:	5b1b0020 32333b31 464e496d 305b1b4f      ..[1;32mINFO.[0
    50d9:	202d206d 646e6550 20676e69 75736552     m - Pending Resu
    50e9:	4d20746c 6f726361 00203a73 3b315b1b     lt Macros: ..[1;
    50f9:	496d3233 1b4f464e 206d305b 7254202d     32mINFO.[0m - Tr
    5109:	65676769 614d2072 736f7263 6e615220     igger Macros Ran
    5119:	203a6567 2d203054 0054203e 3b315b1b     ge: T0 -> T..[1;
    5129:	496d3233 1b4f464e 206d305b 6552202d     32mINFO.[0m - Re
    5139:	746c7573 614d2020 736f7263 6e615220     sult  Macros Ran
    5149:	203a6567 2d203052 0052203e 3b315b1b     ge: R0 -> R..[1;
    5159:	496d3233 1b4f464e 206d305b 7254202d     32mINFO.[0m - Tr
    5169:	65676769 203a2072 75736552 4d20746c     igger : Result M
    5179:	6f726361 69615020 09007372 3a200054     acro Pairs..T. :
    5189:	1b005220 333b315b 45446d35 1b475542      R..[1;35mDEBUG.
    5199:	206d305b 614c202d 20726579 00302000     [0m - Layer . 0.
    51a9:	7263614d 616c5f6f 53726579 65746174     Macro_layerState
    51b9:	79616c28 6e497265 2c786564 6579616c     (layerIndex,laye
    51c9:	61745372 00296574 7263614d 616c5f6f     rState).Macro_la
    51d9:	53726579 74666968 79616c28 6e497265     yerShift(layerIn
    51e9:	29786564 63614d00 6c5f6f72 72657961     dex).Macro_layer
    51f9:	6374614c 616c2868 49726579 7865646e     Latch(layerIndex
    5209:	614d0029 5f6f7263 6579616c 636f4c72     ).Macro_layerLoc
    5219:	616c286b 49726579 7865646e 614d0029     k(layerIndex).Ma
    5229:	5f6f7263 6579616c 746f5272 28657461     cro_layerRotate(
    5239:	76657270 73756f69 5b1b0029 3b353b31     previous)..[1;5;
    5249:	456d3133 524f5252 6d305b1b 53202d20     31mERROR.[0m - S
    5259:	206e6163 65646f43 73616820 206f6e20     can Code has no 
    5269:	69666564 2064656e 67697254 20726567     defined Trigger 
    5279:	7263614d 00203a6f 3b315b1b 576d3333     Macro: ..[1;33mW
    5289:	494e5241 5b1b474e 2d206d30 61635320     ARNING.[0m - Sca
    5299:	646f436e 73692065 74756f20 20666f20     nCode is out of 
    52a9:	676e6172 6f6e2f65 65642074 656e6966     range/not define
    52b9:	00203a64 3b315b1b 31333b35 5252456d     d: ..[1;5;31mERR
    52c9:	5b1b524f 2d206d30 44454c20 61745320     OR.[0m - LED Sta
    52d9:	54206574 20657079 6f4e202d 6d692074     te Type - Not im
    52e9:	6d656c70 65746e65 2e2e2e64 1b000a0d     plemented.......
    52f9:	353b315b 6d31333b 4f525245 305b1b52     [1;5;31mERROR.[0
    5309:	202d206d 6c616e41 5320676f 65746174     m - Analog State
    5319:	70795420 202d2065 20746f4e 6c706d69      Type - Not impl
    5329:	6e656d65 2e646574 0a0d2e2e 315b1b00     emented.......[1
    5339:	333b353b 52456d31 1b524f52 206d305b     ;5;31mERROR.[0m 
    5349:	6e49202d 696c6176 74532064 20657461     - Invalid State 
    5359:	65707954 6854202e 69207369 20612073     Type. This is a 
    5369:	2e677562 1b000a0d 333b315b 45446d35     bug.....[1;35mDE
    5379:	1b475542 206d305b 614d202d 206f7263     BUG.[0m - Macro 
    5389:	70657453 1b000a0d 333b315b 4e496d32     Step....[1;32mIN
    5399:	5b1b4f46 2d206d30 69725420 72656767     FO.[0m - Trigger
    53a9:	63614d20 49206f72 7865646e 7c00203a      Macro Index: .|
    53b9:	3b002b00 500a0d00 7469736f 3a6e6f69     .+.;...Position:
    53c9:	0a0d0020 75736552 4d20746c 6f726361      ...Result Macro
    53d9:	646e4920 203a7865 540a0d00 67676972      Index: ...Trigg
    53e9:	4d207265 6f726361 61745320 203a6574     er Macro State: 
    53f9:	69615700 676e6974 315b1b00 6d32333b     .Waiting..[1;32m
    5409:	4f464e49 6d305b1b 52202d20 6c757365     INFO.[0m - Resul
    5419:	614d2074 206f7263 65646e49 00203a78     t Macro Index: .
    5429:	002c0028 69460a0d 206c616e 67697254     (.,...Final Trig
    5439:	20726567 74617453 53282065 65746174     ger State (State
    5449:	7079542f 203a2965 63002f00 694c7061     /Type): ./.capLi
    5459:	63007473 65537061 7463656c 79656b00     st.capSelect.key
    5469:	646c6f48 79656b00 73657250 656b0073     Hold.keyPress.ke
    5479:	6c655279 65736165 79616c00 65447265     yRelease.layerDe
    5489:	00677562 6579616c 73694c72 616c0074     bug.layerList.la
    5499:	53726579 65746174 63616d00 65446f72     yerState.macroDe
    54a9:	00677562 7263616d 73694c6f 616d0074     bug.macroList.ma
    54b9:	506f7263 00636f72 7263616d 6f68536f     croProc.macroSho
    54c9:	616d0077 536f7263 00706574              w.macroStep.

000054d5 <macroProcCLIDict_DescEntry>:
    54d5:	73756150 65522f65 656d7573 63616d20     Pause/Resume mac
    54e5:	70206f72 65636f72 6e697373 01002e67              ro processing..

000054f4 <tm15_guide>:
    54f4:	32010001 ea080100                                ...2.

000054f9 <rm78_guide>:
    54f9:	00ea0801 2a0e0100                                .....

000054fe <rm41_guide>:
    54fe:	002a0e01                                ..*.

00005502 <rm92_guide>:
    5502:	00480e01                                ..H.

00005506 <tm17_guide>:
    5506:	0d010001 01000100                                .....

0000550b <tm68_guide>:
    550b:	23010001 01000100                                ...#.

00005510 <tm41_guide>:
    5510:	1c010001 01000100                                .....

00005515 <tm92_guide>:
    5515:	18010001 6e655300                                .....

0000551a <keyPressCLIDict_DescEntry>:
    551a:	646e6553 79656b20 6572702d 65207373     Send key-press e
    552a:	746e6576 6f742073 65687420 63616d20     vents to the mac
    553a:	6d206f72 6c75646f 44202e65 696c7075     ro module. Dupli
    554a:	65746163 61682073 75206576 6665646e     cates have undef
    555a:	64656e69 68656220 6f697661 0d2e7275     ined behaviour..
    556a:	1b09090a 6d35335b 1b303153 206d305b     ....[35mS10.[0m 
    557a:	6e616353 65646f63 30783020 0e010041              Scancode 0x0A.

00005588 <rm49_guide>:
    5588:	002c0e01                                ..,.

0000558c <rm67_guide>:
    558c:	00550e01                                ..U.

00005590 <rm0_guide>:
    5590:	00210e01                                ..!.

00005594 <macroCLIDictName>:
    5594:	7263614d 6f4d206f 656c7564 6d6f4320     Macro Module Com
    55a4:	646e616d 0e010073                                mands.

000055aa <rm43_guide>:
    55aa:	00390e01                                ..9.

000055ae <tm37_guide>:
    55ae:	1b010001 01000100                                .....

000055b3 <tm19_guide>:
    55b3:	11010001 01000100                                .....

000055b8 <tm43_guide>:
    55b8:	3e010001 01000100                                ...>.

000055bd <tm94_guide>:
    55bd:	02010001 0a0e0100                                .....

000055c2 <rm8_guide>:
    55c2:	000a0e01 00010000                                ......

000055c8 <layer1_tl_0x0E>:
    55c8:	00000001 0000004a                       ....J...

000055d0 <layerDebugCLIDict_DescEntry>:
    55d0:	6579614c 65642072 20677562 65646f6d     Layer debug mode
    55e0:	6853202e 2073776f 6579616c 74732072     . Shows layer st
    55f0:	206b6361 20646e61 20796e61 6e616863     ack and any chan
    5600:	2e736567 470e0100                                ges..

00005605 <rm91_guide>:
    5605:	00470e01 01000000                                ..G....

0000560c <layer1_tl_0x0F>:
    560c:	00000001 00000041                       ....A...

00005614 <rm7_guide>:
    5614:	00e30e01                                ....

00005618 <rm45_guide>:
    5618:	00260e01                                ..&.

0000561c <tm85_guide>:
    561c:	0c010001 00000000                       ........

00005624 <default_tl_0x2D>:
    5624:	00000001 0000001f                       ........

0000562c <tm45_guide>:
    562c:	09010001 00000000                       ........

00005634 <default_tl_0x2E>:
    5634:	00000001 00000023                       ....#...

0000563c <default_tl_0x2F>:
    563c:	00000001 00000012                       ........

00005644 <tm23_guide>:
    5644:	34010001 230e0100                                ...4.

00005649 <rm47_guide>:
    5649:	00230e01                                ..#.

0000564d <rm10_guide>:
    564d:	00010601 6f685300                                .....

00005652 <macroShowCLIDict_DescEntry>:
    5652:	776f6853 65687420 63616d20 63206f72     Show the macro c
    5662:	6572726f 6e6f7073 676e6964 206f7420     orresponding to 
    5672:	20656874 65766967 6e69206e 2e786564     the given index.
    5682:	09090a0d 35335b1b 3631546d 6d305b1b     .....[35mT16.[0m
    5692:	646e4920 64657865 69725420 72656767      Indexed Trigger
    56a2:	63614d20 30206f72 2c303178 335b1b20      Macro 0x10, .[3
    56b2:	31526d35 305b1b32 6e49206d 65786564     5mR12.[0m Indexe
    56c2:	65522064 746c7573 63614d20 30206f72     d Result Macro 0
    56d2:	00433078 00010000                                x0C...

000056d8 <layer1_tl_0x0A>:
    56d8:	00000001 0000004e                       ....N...

000056e0 <tm47_guide>:
    56e0:	06010001 00000000                       ........

000056e8 <default_tl_0x00>:
    56e8:	00000001 00000006                       ........

000056f0 <tm71_guide>:
    56f0:	0d010001 00000000                       ........

000056f8 <default_tl_0x02>:
    56f8:	00000001 00000036                       ....6...

00005700 <default_tl_0x03>:
    5700:	00000001 0000003a                       ....:...

00005708 <default_tl_0x04>:
    5708:	00000001 00000000                       ........

00005710 <default_tl_0x05>:
    5710:	00000001 0000002a                       ....*...

00005718 <default_tl_0x06>:
    5718:	00000001 0000002f                       ..../...

00005720 <default_tl_0x07>:
    5720:	00000001 0000001c                       ........

00005728 <default_tl_0x08>:
    5728:	00000001 00000027                       ....'...

00005730 <default_tl_0x09>:
    5730:	00000001 0000002d                       ....-...

00005738 <tm10_guide>:
    5738:	36010001 01000100                                ...6.

0000573d <tm1_guide>:
    573d:	26010001 4c0e0100                                ...&.

00005742 <rm73_guide>:
    5742:	004c0e01                                ..L.

00005746 <tm49_guide>:
    5746:	3a010001 01000100                                ...:.

0000574b <tm12_guide>:
    574b:	01010001 01000100                                .....

00005750 <tm73_guide>:
    5750:	33010001 00000000                       ...3....

00005758 <default_tl_0x0A>:
    5758:	00000001 0000001a                       ........

00005760 <layer1_tl_0x01>:
    5760:	00000001 00000043                       ....C...

00005768 <layer1_tl_0x02>:
    5768:	00000001 0000005e                       ....^...

00005770 <layer1_tl_0x03>:
    5770:	00000001 00000060                       ....`...

00005778 <layer1_tl_0x04>:
    5778:	00000001 0000003f                       ....?...

00005780 <layer1_tl_0x05>:
    5780:	00000001 00000058                       ....X...

00005788 <layer1_tl_0x06>:
    5788:	00000001 0000005b                       ....[...

00005790 <layer1_tl_0x07>:
    5790:	00000001 00000050                       ....P...

00005798 <layer1_tl_0x08>:
    5798:	00000001 00000057                       ....W...

000057a0 <ResultMacroList>:
    57a0:	00005590 00006410 00005b22 000063b0     .U...d.."[...c..
    57b0:	00005b12 00004d99 0000624b 00005614     .[...M..Kb...V..
    57c0:	000055c2 0000598d 0000564d 00005eff     .U...Y..MV...^..
    57d0:	00005e70 00005f07 00005cdc 00004e54     p^..._...\..TN..
    57e0:	00005a09 00006325 00005a87 00004dc6     .Z..%c...Z...M..
    57f0:	00005f22 000063fc 00005981 000063c9     "_...c...Y...c..
    5800:	00005b34 00004db4 000063d2 00005ef7     4[...M...c...^..
    5810:	0000624f 0000636d 000063c5 00006360     Ob..mc...c..`c..
    5820:	00006408 00005b1a 00004cd1 00004dca     .d...[...L...M..
    5830:	00004d6e 00006400 00004d9d 00005e74     nM...d...M..t^..
    5840:	00005d8c 000054fe 00005dfc 000055aa     .]...T...]...U..
    5850:	00004db0 00005618 00004e60 00005649     .M...V..`N..IV..
    5860:	00005efb 00005588 000063b4 00004dce     .^...U...c...M..
    5870:	00005996 00006369 00004d65 000063b8     .Y..ic..eM...c..
    5880:	00005989 000063d6 00005b38 00006404     .Y...c..8[...d..
    5890:	00004e79 00006376 00004da2 00005c04     yN..vc...M...\..
    58a0:	00004dbd 00005ce0 00005cd4 0000558c     .M...\...\...U..
    58b0:	00005ef3 00005d7f 00005eb4 00005f1a     .^...]...^..._..
    58c0:	00005f03 00005742 00006241 00005924     ._..BW..Ab..$Y..
    58d0:	00006329 00005a05 000054f9 00005df8     )c...Z...T...]..
    58e0:	00005985 000063df 00005cd8 0000640c     .Y...c...\...d..
    58f0:	000063bc 00005b26 00005b16 00005969     .c..&[...[..iY..
    5900:	00006333 00004d95 00005bf8 00005605     3c...M...[...V..
    5910:	00005502 00005e00 00005b1e 00004cd5     .U...^...[...L..
    5920:	00005e82                                .^..

00005924 <rm75_guide>:
    5924:	00510e01                                ..Q.

00005928 <tm14_guide>:
    5928:	10010001 01000100                                .....

0000592d <tm75_guide>:
    592d:	20010001 01000000                                ... ...

00005934 <default_tl_0x01>:
    5934:	00000001 0000000c                       ........

0000593c <tm66_guide>:
    593c:	1f010001 00000000                       ........

00005944 <layer1_tl_0x0B>:
    5944:	00000001 00000052                       ....R...

0000594c <layer1_tl_0x0C>:
    594c:	00000001 00000055                       ....U...

00005954 <layer1_tl_0x0D>:
    5954:	00000001 00000047                       ....G...

0000595c <default_tl_0x25>:
    595c:	00000001 0000003c                       ....<...

00005964 <tm5_guide>:
    5964:	35010001 3e0e0100                                ...5.

00005969 <rm87_guide>:
    5969:	003e0e01                                ..>.

0000596d <tm39_guide>:
    596d:	08010001 01000100                                .....

00005972 <tm26_guide>:
    5972:	0a010001 01000100                                .....

00005977 <tm77_guide>:
    5977:	21010001 01000100                                ...!.

0000597c <tm50_guide>:
    597c:	2c010001 070e0100                                ...,.

00005981 <rm22_guide>:
    5981:	00070e01                                ....

00005985 <rm80_guide>:
    5985:	00570e01                                ..W.

00005989 <rm56_guide>:
    5989:	00180e01                                ....

0000598d <rm9_guide>:
    598d:	00170e01                                ....

00005991 <tm7_guide>:
    5991:	39010001 01040100                                ...9.

00005996 <rm52_guide>:
    5996:	00010401 01000100                                .....

0000599b <tm28_guide>:
    599b:	07010001 01000100                                .....

000059a0 <tm79_guide>:
    59a0:	1e010001 00000000                       ........

000059a8 <default_tl_0x2A>:
    59a8:	00000001 00000028                       ....(...

000059b0 <default_tl_0x2B>:
    59b0:	00000001 0000002e                       ........

000059b8 <default_tl_0x11>:
    59b8:	00000001 00000013                       ........

000059c0 <default_tl_0x12>:
    59c0:	00000001 0000003e                       ....>...

000059c8 <default_tl_0x13>:
    59c8:	00000001 00000004                       ........

000059d0 <default_tl_0x14>:
    59d0:	00000001 00000009                       ........

000059d8 <default_tl_0x15>:
    59d8:	00000001 00000033                       ....3...

000059e0 <default_tl_0x16>:
    59e0:	00000001 00000038                       ....8...

000059e8 <default_tl_0x17>:
    59e8:	00000001 00000024                       ....$...

000059f0 <default_tl_0x18>:
    59f0:	00000001 00000030                       ....0...

000059f8 <default_tl_0x19>:
    59f8:	00000001 00000035                       ....5...

00005a00 <tm54_guide>:
    5a00:	02010001 430e0100                                .....

00005a05 <rm77_guide>:
    5a05:	00430e01                                ..C.

00005a09 <rm16_guide>:
    5a09:	000d0e01 00000000                                .......

00005a10 <layer1_tl_0x10>:
    5a10:	00000000                                ....

00005a14 <default_tl_0x1B>:
    5a14:	00000001 00000025                       ....%...

00005a1c <layer1_tl_0x12>:
    5a1c:	00000000                                ....

00005a20 <layer1_tl_0x13>:
    5a20:	00000000                                ....

00005a24 <layer1_tl_0x14>:
    5a24:	00000000                                ....

00005a28 <layer1_tl_0x15>:
    5a28:	00000000                                ....

00005a2c <layer1_tl_0x16>:
    5a2c:	00000000                                ....

00005a30 <layer1_tl_0x17>:
    5a30:	00000001 00000056                       ....V...

00005a38 <layer1_tl_0x18>:
    5a38:	00000001 0000005c                       ....\...

00005a40 <layer1_tl_0x19>:
    5a40:	00000001 0000005d                       ....]...

00005a48 <tm80_guide>:
    5a48:	07010001 00000000                       ........

00005a50 <layer1_tl_0x1A>:
    5a50:	00000001 00000054                       ....T...

00005a58 <layer1_tl_0x11>:
    5a58:	00000001 00000048                       ....H...

00005a60 <layer1_tl_0x1C>:
    5a60:	00000000                                ....

00005a64 <layer1_tl_0x1D>:
    5a64:	00000000                                ....

00005a68 <layer1_tl_0x1E>:
    5a68:	00000001 0000004f                       ....O...

00005a70 <layer1_tl_0x1F>:
    5a70:	00000001 00000042                       ....B...

00005a78 <tm58_guide>:
    5a78:	03010001 01000100                                .....

00005a7d <tm21_guide>:
    5a7d:	0e010001 01000100                                .....

00005a82 <tm82_guide>:
    5a82:	0b010001 050e0100                                .....

00005a87 <rm18_guide>:
    5a87:	00050e01                                ....

00005a8b <layerStateCLIDict_DescEntry>:
    5a8b:	69646f4d 73207966 69636570 64656966     Modify specified
    5a9b:	646e6920 64657865 79616c20 73207265      indexed layer s
    5aab:	65746174 616c3c20 3e726579 74733c20     tate <layer> <st
    5abb:	20657461 65747962 0a0d2e3e 5b1b0909     ate byte>......[
    5acb:	4c6d3533 305b1b32 6e49206d 65786564     35mL2.[0m Indexe
    5adb:	614c2064 20726579 32307830 09090a0d     d Layer 0x02....
    5aeb:	664f2030 31202c66 69685320 202c7466     0 Off, 1 Shift, 
    5afb:	614c2032 2c686374 4c203420 206b636f     2 Latch, 4 Lock 
    5b0b:	74617453 01007365                                States.

00005b12 <rm4_guide>:
    5b12:	00150e01                                ....

00005b16 <rm86_guide>:
    5b16:	00410e01                                ..A.

00005b1a <rm33_guide>:
    5b1a:	002f0e01                                ../.

00005b1e <rm94_guide>:
    5b1e:	004f0e01                                ..O.

00005b22 <rm2_guide>:
    5b22:	002b0e01                                ..+.

00005b26 <rm85_guide>:
    5b26:	00460e01                                ..F.

00005b2a <tm33_guide>:
    5b2a:	1a010001 01000100                                .....

00005b2f <tm84_guide>:
    5b2f:	1a010001 e00e0100                                .....

00005b34 <rm24_guide>:
    5b34:	00e00e01                                ....

00005b38 <rm58_guide>:
    5b38:	00200e01                                .. .

00005b3c <default_tl_0x20>:
    5b3c:	00000001 00000016                       ........

00005b44 <default_tl_0x21>:
    5b44:	00000001 00000019                       ........

00005b4c <default_tl_0x22>:
    5b4c:	00000001 00000008                       ........

00005b54 <default_tl_0x23>:
    5b54:	00000001 0000000d                       ........

00005b5c <default_tl_0x24>:
    5b5c:	00000001 00000010                       ........

00005b64 <tm86_guide>:
    5b64:	17010001 00000000                       ........

00005b6c <default_tl_0x26>:
    5b6c:	00000001 00000001                       ........

00005b74 <default_tl_0x27>:
    5b74:	00000001 0000002c                       ....,...

00005b7c <default_tl_0x28>:
    5b7c:	00000001 00000039                       ....9...

00005b84 <default_tl_0x29>:
    5b84:	00000001 0000003d                       ....=...

00005b8c <tm42_guide>:
    5b8c:	05010001 73694c00                                .....

00005b91 <layerListCLIDict_DescEntry>:
    5b91:	7473694c 61766120 62616c69 6c20656c     List available l
    5ba1:	72657961 01002e73                                ayers..

00005ba8 <tm51_guide>:
    5ba8:	15010001 00000000                       ........

00005bb0 <layer1_tl_0x20>:
    5bb0:	00000001 0000004b                       ....K...

00005bb8 <layer1_tl_0x21>:
    5bb8:	00000001 0000004d                       ....M...

00005bc0 <default_tl_0x2C>:
    5bc0:	00000001 00000032                       ....2...

00005bc8 <tm88_guide>:
    5bc8:	05010001 01000100                                .....

00005bcd <tm61_guide>:
    5bcd:	29010001 01000000                                ...)...

00005bd4 <layer1_tl_0x25>:
    5bd4:	00000001 00000061                       ....a...

00005bdc <layer1_tl_0x26>:
    5bdc:	00000001 00000040                       ....@...

00005be4 <layer1_tl_0x27>:
    5be4:	00000001 00000059                       ....Y...

00005bec <layer1_tl_0x28>:
    5bec:	00000001 0000005f                       ...._...

00005bf4 <layer1_tl_0x29>:
    5bf4:	00000000                                ....

00005bf8 <rm90_guide>:
    5bf8:	003f0e01                                ..?.

00005bfc <default_tl_0x31>:
    5bfc:	00000001 00000020                       .... ...

00005c04 <rm63_guide>:
    5c04:	003d0e01                                ..=.

00005c08 <tm9_guide>:
    5c08:	14010001 00000000                       ........

00005c10 <layer1_tl_0x2A>:
    5c10:	00000000                                ....

00005c14 <layer1_tl_0x2B>:
    5c14:	00000000                                ....

00005c18 <layer1_tl_0x1B>:
    5c18:	00000000                                ....

00005c1c <layer1_tl_0x2D>:
    5c1c:	00000000                                ....

00005c20 <layer1_tl_0x2E>:
    5c20:	00000000                                ....

00005c24 <tm63_guide>:
    5c24:	04010001 00000000                       ........

00005c2c <macroCLIDict>:
    5c2c:	00005454 00005e34 0000197d 0000545c     TT..4^..}...\T..
    5c3c:	00005d04 000019fd 00005466 00006258     .]......fT..Xb..
    5c4c:	00002189 0000546e 0000551a 000021b7     .!..nT...U...!..
    5c5c:	00005477 00004de1 000021e5 00005482     wT...M...!...T..
    5c6c:	000055d0 00001afd 0000548d 00005b91     .U.......T...[..
    5c7c:	00001c09 00005497 00005a8b 00001b31     .....T...Z..1...
    5c8c:	000054a2 000062ca 00001ba1 000054ad     .T...b.......T..
    5c9c:	0000637f 00001ce9 000054b7 000054d5     .c.......T...T..
    5cac:	00001bd5 000054c1 00005652 00002a59     .....T..RV..Y*..
    5cbc:	000054cb 00005ec2 000019d5 00000000     .T...^..........
    5ccc:	00000000 00000000                       ........

00005cd4 <rm66_guide>:
    5cd4:	003a0e01                                ..:.

00005cd8 <rm82_guide>:
    5cd8:	00560e01                                ..V.

00005cdc <rm14_guide>:
    5cdc:	00140e01                                ....

00005ce0 <rm65_guide>:
    5ce0:	00e90801 01000100                                .....

00005ce5 <tm40_guide>:
    5ce5:	2a010001 01000000                                ...*...

00005cec <default_tl_0x3D>:
    5cec:	00000001 00000026                       ....&...

00005cf4 <tm65_guide>:
    5cf4:	0f010001 00000000                       ........

00005cfc <default_tl_0x3E>:
    5cfc:	00000001 0000002b                       ....+...

00005d04 <capSelectCLIDict_DescEntry>:
    5d04:	67697254 73726567 65687420 65707320     Triggers the spe
    5d14:	69666963 63206465 62617061 74696c69     cified capabilit
    5d24:	2e736569 72694620 74207473 61206f77     ies. First two a
    5d34:	20736772 20657261 74617473 6e612065     rgs are state an
    5d44:	74732064 54657461 2e657079 09090a0d     d stateType.....
    5d54:	35335b1b 31314b6d 6d305b1b 79654b20     .[35mK11.[0m Key
    5d64:	72616f62 61432064 69626170 7974696c     board Capability
    5d74:	30783020 00010042                                 0x0B.

00005d7a <tm31_guide>:
    5d7a:	2d010001 540e0100                                ...-.

00005d7f <rm69_guide>:
    5d7f:	00540e01 00000100                                ..T..

00005d84 <default_tl_0x3A>:
    5d84:	00000001 00000031                       ....1...

00005d8c <rm40_guide>:
    5d8c:	00e10e01                                ....

00005d90 <default_tl_0x3B>:
    5d90:	00000001 00000037                       ....7...

00005d98 <tm16_guide>:
    5d98:	24010001 00000000                       ...$....

00005da0 <default_tl_0x3C>:
    5da0:	00000001 0000003b                       ....;...

00005da8 <default_tl_0x30>:
    5da8:	00000001 0000001d                       ........

00005db0 <tm91_guide>:
    5db0:	06010001 00000000                       ........

00005db8 <default_tl_0x32>:
    5db8:	00000001 0000000f                       ........

00005dc0 <default_tl_0x33>:
    5dc0:	00000001 00000014                       ........

00005dc8 <default_tl_0x34>:
    5dc8:	00000001 00000017                       ........

00005dd0 <default_tl_0x35>:
    5dd0:	00000001 00000005                       ........

00005dd8 <default_tl_0x36>:
    5dd8:	00000001 0000000a                       ........

00005de0 <default_tl_0x37>:
    5de0:	00000001 00000034                       ....4...

00005de8 <default_tl_0x38>:
    5de8:	00000001 00000003                       ........

00005df0 <default_tl_0x39>:
    5df0:	00000001 00000007                       ........

00005df8 <rm79_guide>:
    5df8:	00400e01                                ..@.

00005dfc <rm42_guide>:
    5dfc:	00220e01                                ..".

00005e00 <rm93_guide>:
    5e00:	003b0e01                                ..;.

00005e04 <tm18_guide>:
    5e04:	2f010001 01000100                                .../.

00005e09 <tm69_guide>:
    5e09:	32010001 01000100                                ...2.

00005e0e <tm93_guide>:
    5e0e:	19010001 00010000                                ......

00005e14 <layer1_tl_0x30>:
    5e14:	00000001 00000051                       ....Q...

00005e1c <layer1_tl_0x31>:
    5e1c:	00000001 00000053                       ....S...

00005e24 <layer1_tl_0x32>:
    5e24:	00000001 00000045                       ....E...

00005e2c <layer1_tl_0x33>:
    5e2c:	00000001 00000049                       ....I...

00005e34 <capListCLIDict_DescEntry>:
    5e34:	6e697250 61207374 6e69206e 65786564     Prints an indexe
    5e44:	696c2064 6f207473 6c612066 6f6e206c     d list of all no
    5e54:	5355206e 656b2042 646f6379 61632065     n USB keycode ca
    5e64:	69626170 6974696c 002e7365              pabilities..

00005e70 <rm12_guide>:
    5e70:	001e0e01                                ....

00005e74 <rm39_guide>:
    5e74:	00250e01                                ..%.

00005e78 <tm44_guide>:
    5e78:	27010001 01000100                                ...'.

00005e7d <tm95_guide>:
    5e7d:	28010001 4a0e0100                                ...(.

00005e82 <rm96_guide>:
    5e82:	004a0e01 00000000                                ..J...

00005e88 <layer1_tl_0x22>:
    5e88:	00000000                                ....

00005e8c <layer1_tl_0x23>:
    5e8c:	00000001 00000044                       ....D...

00005e94 <LayerIndex>:
    5e94:	1fffe9b4 0000500a 00003e00 1fffeab0     .....P...>......
    5ea4:	00005069 00003401                       iP...4..

00005eac <layer1_tl_0x24>:
    5eac:	00000001 00000046                       ....F...

00005eb4 <rm70_guide>:
    5eb4:	00490e01                                ..I.

00005eb8 <tm46_guide>:
    5eb8:	2b010001 01000100                                ...+.

00005ebd <tm70_guide>:
    5ebd:	24010001 206f4400                                ...$.

00005ec2 <macroStepCLIDict_DescEntry>:
    5ec2:	4e206f44 63616d20 70206f72 65636f72     Do N macro proce
    5ed2:	6e697373 74732067 2e737065 66654420     ssing steps. Def
    5ee2:	746c7561 6f742073 002e3120              aults to 1..

00005eee <tm30_guide>:
    5eee:	0b010001 4d0e0100                                .....

00005ef3 <rm68_guide>:
    5ef3:	004d0e01                                ..M.

00005ef7 <rm27_guide>:
    5ef7:	00040e01                                ....

00005efb <rm48_guide>:
    5efb:	00120e01                                ....

00005eff <rm11_guide>:
    5eff:	00160e01                                ....

00005f03 <rm72_guide>:
    5f03:	004e0e01                                ..N.

00005f07 <rm13_guide>:
    5f07:	000b0e01                                ....

00005f0b <tm48_guide>:
    5f0b:	18010001 01000100                                .....

00005f10 <tm11_guide>:
    5f10:	1f010001 01000100                                .....

00005f15 <tm72_guide>:
    5f15:	11010001 00090100                                .....

00005f1a <rm71_guide>:
    5f1a:	01000901                                         ...

00005f1d <tm52_guide>:
    5f1d:	37010001 370e0100                                ...7.

00005f22 <rm20_guide>:
    5f22:	00370e01 64230000                                ..7...

00005f28 <TriggerMacroList>:
    5f28:	00006423 00000000 0000573d 00000001     #d......=W......
    5f38:	0000623c 00000002 000063da 00000003     <b.......c......
    5f48:	000062c5 00000004 00005964 00000005     .b......dY......
    5f58:	0000632e 00000006 00005991 00000007     .c.......Y......
    5f68:	00006364 00000008 00005c08 00000009     dc.......\......
    5f78:	00005738 0000000a 00005f10 0000000b     8W......._......
    5f88:	0000574b 0000000c 00004ccc 0000000d     KW.......L......
    5f98:	00005928 0000000e 000054f4 0000000f     (Y.......T......
    5fa8:	00005d98 00000010 00005506 00000011     .].......U......
    5fb8:	00005e04 00000012 000055b3 00000013     .^.......U......
    5fc8:	000063e8 00000014 00005a7d 00000015     .c......}Z......
    5fd8:	00006419 00000016 00005644 00000017     .d......DV......
    5fe8:	00006253 00000018 0000631b 00000019     Sb.......c......
    5ff8:	00005972 0000001a 00004d90 0000001b     rY.......M......
    6008:	0000599b 0000001c 00006371 0000001d     .Y......qc......
    6018:	00005eee 0000001e 00005d7a 0000001f     .^......z]......
    6028:	00004ddc 00000020 00005b2a 00000021     .M.. ...*[..!...
    6038:	00004ce0 00000022 00004d72 00000023     .L.."...rM..#...
    6048:	00004d77 00000024 000055ae 00000025     wM..$....U..%...
    6058:	00004da6 00000026 0000596d 00000027     .M..&...mY..'...
    6068:	00005ce5 00000028 00005510 00000029     .\..(....U..)...
    6078:	00005b8c 0000002a 000055b8 0000002b     .[..*....U..+...
    6088:	00005e78 0000002c 0000562c 0000002d     x^..,...,V..-...
    6098:	00005eb8 0000002e 000056e0 0000002f     .^.......V../...
    60a8:	00005f0b 00000030 00005746 00000031     ._..0...FW..1...
    60b8:	0000597c 00000032 00005ba8 00000033     |Y..2....[..3...
    60c8:	00005f1d 00000034 0000637a 00000035     ._..4...zc..5...
    60d8:	00005a00 00000036 000063c0 00000037     .Z..6....c..7...
    60e8:	00004db8 00000038 000063e3 00000039     .M..8....c..9...
    60f8:	00005a78 0000003a 00006414 0000003b     xZ..:....d..;...
    6108:	00004d81 0000003c 00005bcd 0000003d     .M..<....[..=...
    6118:	00004dab 0000003e 00005c24 0000003f     .M..>...$\..?...
    6128:	00004dc1 00000040 00005cf4 0000002b     .M..@....\..+...
    6138:	0000593c 00000041 000063ab 00000042     <Y..A....c..B...
    6148:	0000550b 00000043 00005e09 00000044     .U..C....^..D...
    6158:	00005ebd 00000045 000056f0 00000046     .^..E....V..F...
    6168:	00005f15 00000047 00005750 00000048     ._..G...PW..H...
    6178:	00006246 00000049 0000592d 0000004a     Fb..I...-Y..J...
    6188:	00006320 0000004b 00005977 0000004c      c..K...wY..L...
    6198:	00006348 0000004d 000059a0 0000004e     Hc..M....Y..N...
    61a8:	00005a48 0000004f 000063ed 00000050     HZ..O....c..P...
    61b8:	00005a82 00000051 0000641e 00000052     .Z..Q....d..R...
    61c8:	00005b2f 00000053 0000561c 00000054     /[..S....V..T...
    61d8:	00005b64 00000055 00004d7c 00000056     d[..U...|M..V...
    61e8:	00005bc8 00000057 000063cd 00000058     .[..W....c..X...
    61f8:	00004e74 00000059 00005db0 0000005a     tN..Y....]..Z...
    6208:	00005515 0000005b 00005e0e 0000005c     .U..[....^..\...
    6218:	000055bd 0000005d 00005e7d 0000005e     .U..]...}^..^...
    6228:	00004d69 0000005f 00004d60 00000060     iM.._...`M..`...

00006238 <layer1_tl_0x2C>:
    6238:	00000000                                ....

0000623c <tm2_guide>:
    623c:	0f010001 e2080100                                .....

00006241 <rm74_guide>:
    6241:	00e20801 01000100                                .....

00006246 <tm74_guide>:
    6246:	0e010001 290e0100                                .....

0000624b <rm6_guide>:
    624b:	00290e01                                ..).

0000624f <rm28_guide>:
    624f:	00240e01                                ..$.

00006253 <tm24_guide>:
    6253:	1d010001 6e655300                                .....

00006258 <keyHoldCLIDict_DescEntry>:
    6258:	646e6553 79656b20 6c6f682d 76652064     Send key-hold ev
    6268:	73746e65 206f7420 20656874 7263616d     ents to the macr
    6278:	6f6d206f 656c7564 7544202e 63696c70     o module. Duplic
    6288:	73657461 76616820 6e752065 69666564     ates have undefi
    6298:	2064656e 61686562 756f6976 0a0d2e72     ned behaviour...
    62a8:	5b1b0909 536d3533 5b1b3031 53206d30     ...[35mS10.[0m S
    62b8:	636e6163 2065646f 41307830 01000100              cancode 0x0A.

000062c5 <tm4_guide>:
    62c5:	13010001 73694400                                .....

000062ca <macroDebugCLIDict_DescEntry>:
    62ca:	61736944 73656c62 616e452f 73656c62     Disables/Enables
    62da:	6e657320 676e6964 42535520 79656b20      sending USB key
    62ea:	65646f63 6f742073 65687420 74754f20     codes to the Out
    62fa:	20747570 75646f4d 6120656c 7020646e     put Module and p
    630a:	746e6972 2f552073 6f63204b 2e736564     rints U/K codes.
    631a:	01000100                                         .

0000631b <tm25_guide>:
    631b:	21010001 01000100                                ...!.

00006320 <tm76_guide>:
    6320:	34010001 310e0100                                ...4.

00006325 <rm17_guide>:
    6325:	00310e01                                ..1.

00006329 <rm76_guide>:
    6329:	00b80801 01000100                                .....

0000632e <tm6_guide>:
    632e:	00010001 500e0100                                .....

00006333 <rm88_guide>:
    6333:	00500e01 00000100                                ..P..

00006338 <default_tl_0x0B>:
    6338:	00000001 0000001e                       ........

00006340 <default_tl_0x0C>:
    6340:	00000001 00000022                       ...."...

00006348 <tm78_guide>:
    6348:	0a010001 00000000                       ........

00006350 <default_tl_0x0E>:
    6350:	00000001 00000015                       ........

00006358 <default_tl_0x0F>:
    6358:	00000001 00000002                       ........

00006360 <rm31_guide>:
    6360:	00060e01                                ....

00006364 <tm8_guide>:
    6364:	22010001 130e0100                                ...".

00006369 <rm53_guide>:
    6369:	00130e01                                ....

0000636d <rm29_guide>:
    636d:	00110e01                                ....

00006371 <tm29_guide>:
    6371:	30010001 280e0100                                ...0.

00006376 <rm61_guide>:
    6376:	00280e01                                ..(.

0000637a <tm53_guide>:
    637a:	19010001 73694c00                                .....

0000637f <macroListCLIDict_DescEntry>:
    637f:	7473694c 65687420 66656420 64656e69     List the defined
    638f:	69727420 72656767 646e6120 73657220      trigger and res
    639f:	20746c75 7263616d 002e736f              ult macros..

000063ab <tm67_guide>:
    63ab:	01010001 e20e0100                                .....

000063b0 <rm3_guide>:
    63b0:	00e20e01                                ....

000063b4 <rm50_guide>:
    63b4:	001b0e01                                ....

000063b8 <rm55_guide>:
    63b8:	00e70e01                                ....

000063bc <rm84_guide>:
    63bc:	00450e01                                ..E.

000063c0 <tm55_guide>:
    63c0:	3b010001 2d0e0100                                ...;.

000063c5 <rm30_guide>:
    63c5:	002d0e01                                ..-.

000063c9 <rm23_guide>:
    63c9:	00380e01                                ..8.

000063cd <tm89_guide>:
    63cd:	27010001 270e0100                                ...'.

000063d2 <rm26_guide>:
    63d2:	00270e01                                ..'.

000063d6 <rm57_guide>:
    63d6:	00340e01                                ..4.

000063da <tm3_guide>:
    63da:	38010001 440e0100                                ...8.

000063df <rm81_guide>:
    63df:	00440e01                                ..D.

000063e3 <tm57_guide>:
    63e3:	28010001 01000100                                ...(.

000063e8 <tm20_guide>:
    63e8:	33010001 01000100                                ...3.

000063ed <tm81_guide>:
    63ed:	30010001 01000000                                ...0...

000063f4 <layer1_tl_0x09>:
    63f4:	00000001 0000005a                       ....Z...

000063fc <rm21_guide>:
    63fc:	00350e01                                ..5.

00006400 <rm37_guide>:
    6400:	00300e01                                ..0.

00006404 <rm59_guide>:
    6404:	00e60e01                                ....

00006408 <rm32_guide>:
    6408:	00100e01                                ....

0000640c <rm83_guide>:
    640c:	00520e01                                ..R.

00006410 <rm1_guide>:
    6410:	000f0e01                                ....

00006414 <tm59_guide>:
    6414:	3c010001 01000100                                ...<.

00006419 <tm22_guide>:
    6419:	20010001 01000100                                ... .

0000641e <tm83_guide>:
    641e:	31010001 01000100                                ...1.

00006423 <tm0_guide>:
    6423:	04010001 02010000                                .....

00006428 <CSWTCH.65>:
    6428:	03020100 07060504 03020100 07060504     ................
    6438:	03020100 07060504 03020100 07060504     ................
    6448:	03020100 07060504 03020100 07060504     ................

00006458 <kbdProtocolCLIDict_DescEntry>:
    6458:	6279654b 6472616f 6f725020 6f636f74     Keyboard Protoco
    6468:	6f4d206c 203a6564 202d2030 746f6f42     l Mode: 0 - Boot
    6478:	2031202c 534f202d 524b4e2f 6f4d204f     , 1 - OS/NKRO Mo
    6488:	50006564                                         de.

0000648b <setKeysCLIDict_DescEntry>:
    648b:	70657250 20657261 70732061 20656361     Prepare a space 
    649b:	61706573 65746172 696c2064 6f207473     separated list o
    64ab:	53552066 6f632042 20736564 63656428     f USB codes (dec
    64bb:	6c616d69 57202e29 73746961 746e7520     imal). Waits unt
    64cb:	1b206c69 6d35335b 646e6573 7379654b     il .[35msendKeys
    64db:	6d305b1b 5355002e                                .[0m..

000064e1 <outputCLIDictName>:
    64e1:	20425355 75646f4d 4320656c 616d6d6f     USB Module Comma
    64f1:	0073646e                                nds.

000064f5 <CSWTCH.59>:
    64f5:	00000000 01000000 01010101 02010101     ................
    6505:	02020202 03020202 03030303 04030303     ................
    6515:	04040404 05040404 05050505 15050505              ...............

00006524 <CSWTCH.64>:
    6524:	15151515 15151515 16161616 16161616     ................
    6534:	17171717 17171717 18181818 18181818     ................
    6544:	19191919 19191919 1a1a1a1a 1a1a1a1a     ................

00006554 <outputCLIDict>:
    6554:	000068c4 00006458 00002abd 000068d0     .h..Xd...*...h..
    6564:	000068fd 00002b41 000068dc 00006917     .h..A+...h...i..
    6574:	00002ae5 000068e5 000065a8 00002a99     .*...h...e...*..
    6584:	000068ee 0000648b 00002b0d 000068f6     .h...d...+...h..
    6594:	000065df 00002b65 00000000 00000000     .e..e+..........
    65a4:	00000000                                ....

000065a8 <sendKeysCLIDict_DescEntry>:
    65a8:	646e6553 65687420 65727020 65726170     Send the prepare
    65b8:	696c2064 6f207473 53552066 6f632042     d list of USB co
    65c8:	20736564 20646e61 69646f6d 72656966     des and modifier
    65d8:	74796220 53002e65                                 byte..

000065df <setModCLIDict_DescEntry>:
    65df:	20746553 20656874 66646f6d 20726569     Set the modfier 
    65ef:	65747962 090a0d3a 4c203109 6c727443     byte:....1 LCtrl
    65ff:	2032202c 6668534c 34202c74 6c414c20     , 2 LShft, 4 LAl
    660f:	38202c74 55474c20 31202c49 43522036     t, 8 LGUI, 16 RC
    661f:	2c6c7274 20323320 66685352 36202c74     trl, 32 RShft, 6
    662f:	41522034 202c746c 20383231 49554752     4 RAlt, 128 RGUI
    663f:	315b1b00 6d32333b 4f464e49 6d305b1b     ..[1;32mINFO.[0m
    664f:	4b202d20 6f627965 20647261 746f7250      - Keyboard Prot
    665f:	6c6f636f 1b00203a 333b315b 4e496d32     ocol: ..[1;32mIN
    666f:	5b1b4f46 2d206d30 44454c20 61745320     FO.[0m - LED Sta
    667f:	203a6574 74754f00 5f747570 736e6f63     te: .Output_cons
    668f:	6c727443 646e6553 6e6f6328 646f4373     CtrlSend(consCod
    669f:	1b002965 333b315b 41576d33 4e494e52     e)..[1;33mWARNIN
    66af:	305b1b47 202d206d 736e6f43 72656d75     G.[0m - Consumer
    66bf:	6e6f4320 6c6f7274 20736920 20746f6e      Control is not 
    66cf:	6c706d69 6e656d65 20646574 20726f66     implemented for 
    66df:	746f6f42 646f4d20 000a0d65 7074754f     Boot Mode...Outp
    66ef:	6e5f7475 53656e6f 28646e65 754f0029     ut_noneSend().Ou
    66ff:	74757074 7379735f 6c727443 646e6553     tput_sysCtrlSend
    670f:	73797328 65646f43 5b1b0029 33333b31     (sysCode)..[1;33
    671f:	5241576d 474e494e 6d305b1b 53202d20     mWARNING.[0m - S
    672f:	65747379 6f43206d 6f72746e 7369206c     ystem Control is
    673f:	746f6e20 706d6920 656d656c 6465746e      not implemented
    674f:	726f6620 6f6f4220 6f4d2074 0a0d6564      for Boot Mode..
    675f:	74754f00 5f747570 73616c66 646f4d68     .Output_flashMod
    676f:	00292865 7074754f 6b5f7475 72506462     e().Output_kbdPr
    677f:	636f746f 6f426c6f 2928746f 74754f00     otocolBoot().Out
    678f:	5f747570 5064626b 6f746f72 4e6c6f63     put_kbdProtocolN
    679f:	284f524b 754f0029 74757074 6273755f     KRO().Output_usb
    67af:	65646f43 646e6553 62737528 65646f43     CodeSend(usbCode
    67bf:	5b1b0029 33333b31 5241576d 474e494e     )..[1;33mWARNING
    67cf:	6d305b1b 55202d20 4b204253 6c207965     .[0m - USB Key l
    67df:	74696d69 61657220 64656863 1b000a0d     imit reached....
    67ef:	333b315b 41576d33 4e494e52 305b1b47     [1;33mWARNING.[0
    67ff:	202d206d 20425355 65646f43 6f626120     m - USB Code abo
    680f:	31206576 302f3430 20383678 42206e69     ve 104/0x68 in B
    681f:	20746f6f 65646f4d 1b00203a 333b315b     oot Mode: ..[1;3
    682f:	41576d33 4e494e52 305b1b47 202d206d     3mWARNING.[0m - 
    683f:	20425355 65646f43 746f6e20 74697720     USB Code not wit
    684f:	206e6968 39342d34 78302820 78302d34     hin 4-49 (0x4-0x
    685f:	2c293133 2d313520 20353531 33783028     31), 51-155 (0x3
    686f:	78302d33 2c294239 37353120 3436312d     3-0x9B), 157-164
    687f:	78302820 302d4439 29344178 3731202c      (0x9D-0xA4), 17
    688f:	32322d36 30282031 2d304278 44447830     6-221 (0xB0-0xDD
    689f:	726f2029 34323220 3133322d 78302820     ) or 224-231 (0x
    68af:	302d3045 29374578 524b4e20 6f4d204f     E0-0xE7) NKRO Mo
    68bf:	203a6564 64626b00 746f7250 6c6f636f     de: .kbdProtocol
    68cf:	74756f00 44747570 67756265 61657200     .outputDebug.rea
    68df:	44454c64 65730073 654b646e 73007379     dLEDs.sendKeys.s
    68ef:	654b7465 73007379 6f4d7465 6f540064              etKeys.setMod.

000068fd <outputDebugCLIDict_DescEntry>:
    68fd:	67676f54 4f20656c 75707475 65442074     Toggle Output De
    690d:	20677562 65646f6d 6552002e                       bug mode..

00006917 <readLEDsCLIDict_DescEntry>:
    6917:	64616552 44454c20 74796220 0a0d3a65     Read LED byte:..
    6927:	20310909 4c6d754e 202c6b63 61432032     ..1 NumLck, 2 Ca
    6937:	634c7370 34202c6b 72635320 6b634c6c     psLck, 4 ScrlLck
    6947:	3631202c 6e614b20 65202c61 002e6374     , 16 Kana, etc..

00006957 <CSWTCH.60>:
    6957:	04030201 00070605 04030201 00070605     ................
    6967:	04030201 00070605 04030201 00070605     ................
    6977:	04030201 00070605 04030201 06070605              ...............

00006986 <CSWTCH.61>:
    6986:	06060606 06060606 07070707 07070707     ................
    6996:	08080808 08080808 09090909 09090909     ................
    69a6:	0a0a0a0a 0a0a0a0a 0b0b0b0b 0b0b0b0b     ................
    69b6:	0c0c0c0c 0c0c0c0c 0d0d0d0d 0d0d0d0d     ................
    69c6:	0e0e0e0e 0e0e0e0e 0f0f0f0f 0f0f0f0f     ................
    69d6:	10101010 10101010 11111111 11111111     ................
    69e6:	12121212 12121212 13131313 13131313     ................

000069f6 <CSWTCH.62>:
    69f6:	03020100 07060504 03020100 07060504     ................
    6a06:	03020100 07060504 03020100 07060504     ................
    6a16:	03020100 07060504 03020100 07060504     ................
    6a26:	03020100 07060504 03020100 07060504     ................
    6a36:	03020100 07060504 03020100 07060504     ................
    6a46:	03020100 07060504 03020100 07060504     ................
    6a56:	03020100 07060504 03020100 07060504     ................

00006a66 <CSWTCH.63>:
    6a66:	03020100 07060504                       ........

00006a6e <usb_endpoint_config_table>:
    6a6e:	19151515 15151515 01000000                       ..........

00006a78 <usb_descriptor_list>:
    6a78:	00000100 1fffee76 00000012 00000200     ....v...........
    6a88:	1fffece4 000000c8 00000600 1ffff181     ................
    6a98:	00000001 00000a00 1ffff180 00000001     ................
    6aa8:	00002200 1fffef26 0000003f 00002100     ."..&...?....!..
    6ab8:	1fffecf6 00000009 00012200 1fffeb82     ........."......
    6ac8:	0000007d 00012100 1fffed0f 00000009     }....!..........
    6ad8:	00042200 1fffedac 00000076 00042100     ."......v....!..
    6ae8:	1fffed6a 00000009 00052200 1fffebff     j........"......
    6af8:	00000055 00052100 1fffed83 00000009     U....!..........
    6b08:	00062200 1fffee22 00000035 00062100     .".."...5....!..
    6b18:	1fffed9c 00000009 00000300 1fffef66     ............f...
    6b28:	00000000 04090301 1fffeec4 00000000     ................
    6b38:	04090302 1fffeed6 00000000 04090303     ................
    6b48:	1fffef6a 00000000 04090304 1fffee58     j...........X...
    6b58:	00000000 04090305 1fffecc6 00000000     ................
    6b68:	04090306 1fffee88 00000000 04090307     ................
    6b78:	1fffec54 00000000 04090308 1fffeca0     T...............
    6b88:	00000000 04090309 1fffec8c 00000000     ................
    6b98:	0409030a 1fffecae 00000000 00000000     ................
    6ba8:	00000000 00000000 3b315b1b 576d3333     .........[1;33mW
    6bb8:	494e5241 5b1b474e 2d206d30 454c4320     ARNING.[0m - CLE
    6bc8:	465f5241 55544145 2d204552 76654420     AR_FEATURE - Dev
    6bd8:	2f656369 65746e49 63616672 000a0d65     ice/Interface...
    6be8:	3b315b1b 576d3333 494e5241 5b1b474e     .[1;33mWARNING.[
    6bf8:	2d206d30 54455320 4145465f 45525554     0m - SET_FEATURE
    6c08:	44202d20 63697665 6e492f65 66726574      - Device/Interf
    6c18:	0d656361 5b1b000a 33333b31 5241576d     ace....[1;33mWAR
    6c28:	474e494e 6d305b1b 55202d20 6f6e6b6e     NING.[0m - Unkno
    6c38:	69206e77 7265746e 65636166 00202d20     wn interface - .
    6c48:	3b315b1b 31333b35 5252456d 5b1b524f     .[1;5;31mERROR.[
    6c58:	2d206d30 42535520 746f6e20 6e6f6320     0m - USB not con
    6c68:	75676966 2e646572 0a0d2e2e 315b1b00     figured.......[1
    6c78:	6d33333b 4e524157 1b474e49 206d305b     ;33mWARNING.[0m 
    6c88:	5355202d 72542042 6d736e61 54207469     - USB Transmit T
    6c98:	6f656d69 2e2e7475 000a0d2e 43737953     imeout......SysC
    6ca8:	5b6c7274 0d205d00 6f43000a 7443736e     trl[.] ...ConsCt
    6cb8:	005b6c72 3b315b1b 446d3533 47554245     rl[..[1;35mDEBUG
    6cc8:	6d305b1b 42202d20 20746f6f 3a425355     .[0m - Boot USB:
    6cd8:	5b1b0020 35333b31 4245446d 5b1b4755      ..[1;35mDEBUG.[
    6ce8:	2d206d30 524b4e20 5355204f 00203a42     0m - NKRO USB: .
    6cf8:	00000000                                ....

00006cfc <helpCLIDict_DescEntry>:
    6cfc:	27756f59 6c206572 696b6f6f 6120676e     You're looking a
    6d0c:	74692074 00503a20                       t it :P.

00006d14 <restartCLIDict_DescEntry>:
    6d14:	646e6553 20612073 74666f73 65726177     Sends a software
    6d24:	73657220 74726174 6873202c 646c756f      restart, should
    6d34:	20656220 696d6973 2072616c 70206f74      be similar to p
    6d44:	7265776f 20676e69 74206e6f 64206568     owering on the d
    6d54:	63697665 43002e65                                evice..

00006d5b <clearCLIDict_DescEntry>:
    6d5b:	61656c43 68742072 63732065 6e656572     Clear the screen
    6d6b:	6953002e                                         ..

00006d6d <reloadCLIDict_DescEntry>:
    6d6d:	6e676953 20736c61 7263696d 6e6f636f     Signals microcon
    6d7d:	6c6f7274 2072656c 72206f74 616c6665     troller to refla
    6d8d:	722f6873 616f6c65 56002e64                       sh/reload..

00006d98 <versionCLIDict_DescEntry>:
    6d98:	73726556 206e6f69 6f666e69 74616d72     Version informat
    6da8:	206e6f69 756f6261 68742074 66207369     ion about this f
    6db8:	776d7269 2e657261 325b1b00 485b1b4a     irmware...[2J.[H
    6dc8:	631b000d 1b0a0d00 333b315b 1b006d32     ...c....[1;32m..
    6dd8:	0d6d305b 1b20000a 6d35335b 5b1b2000     [0m... .[35m. .[
    6de8:	65526d31 69736976 1b3a6e6f 206d305b     1mRevision:.[0m 
    6df8:	20202020 31363220 65663436 37346537          26164fe7e47
    6e08:	37313864 63333732 31396639 64623731     d817273c9f9117bd
    6e18:	35303736 38333365 64623532 000a0d62     6705e33825bdb...
    6e28:	315b1b20 6172426d 3a68636e 6d305b1b      .[1mBranch:.[0m
    6e38:	20202020 20202020 7473616d 0a0d7265             master..
    6e48:	5b1b2000 72546d31 53206565 75746174     . .[1mTree Statu
    6e58:	5b1b3a73 20206d30 72694420 0a0d7974     s:.[0m   Dirty..
    6e68:	79654b09 72616f62 6a2f7364 6d797266     .Keyboards/jfrym
    6e78:	622e6e61 0d687361 6c6b090a 000a0d6c     an.bash...kll...
    6e88:	315b1b20 7065526d 724f206f 6e696769      .[1mRepo Origin
    6e98:	305b1b3a 2020206d 40746967 68746967     :.[0m   git@gith
    6ea8:	632e6275 4d3a6d6f 75637261 6c754673     ub.com:MarcusFul
    6eb8:	67697262 652f7468 646f6772 662d786f     bright/ergodox-f
    6ec8:	776d7269 2e657261 0d746967 1b20000a     irmware.git... .
    6ed8:	436d315b 696d6d6f 61442074 1b3a6574     [1mCommit Date:.
    6ee8:	206d305b 30322020 302d3631 39312d31     [0m   2016-01-19
    6ef8:	3a363120 343a3830 302d2034 0d303036      16:08:44 -0600.
    6f08:	1b20000a 436d315b 696d6d6f 75412074     .. .[1mCommit Au
    6f18:	726f6874 305b1b3a 614d206d 73756372     thor:.[0m Marcus
    6f28:	6c754620 67697262 3c207468 626c7566      Fulbright <fulb
    6f38:	68676972 616d2e74 73756372 616d6740     right.marcus@gma
    6f48:	632e6c69 0d3e6d6f 1b20000a 426d315b     il.com>... .[1mB
    6f58:	646c6975 74614420 5b1b3a65 20206d30     uild Date:.[0m  
    6f68:	30322020 302d3631 39312d31 3a363120       2016-01-19 16:
    6f78:	333a3934 302d2036 0d303036 1b20000a     49:36 -0600... .
    6f88:	426d315b 646c6975 3a534f20 6d305b1b     [1mBuild OS:.[0m
    6f98:	20202020 694c2020 2d78756e 39312e33           Linux-3.19
    6fa8:	322d302e 65672d38 6972656e 000a0d63     .0-28-generic...
    6fb8:	315b1b20 6372416d 65746968 72757463      .[1mArchitectur
    6fc8:	5b1b3a65 20206d30 0d6d7261 1b20000a     e:.[0m  arm... .
    6fd8:	436d315b 3a706968 6d305b1b 20202020     [1mChip:.[0m    
    6fe8:	20202020 6b6d2020 78643032 76383231           mk20dx128v
    6ff8:	0d35666c 1b20000a 436d315b 1b3a5550     lf5... .[1mCPU:.
    7008:	206d305b 20202020 20202020 6f632020     [0m           co
    7018:	78657472 0d346d2d 1b20000a 446d315b     rtex-m4... .[1mD
    7028:	63697665 5b1b3a65 20206d30 20202020     evice:.[0m      
    7038:	654b2020 616f6279 0a0d6472 5b1b2000       Keyboard... .[
    7048:	6f4d6d31 656c7564 5b1b3a73 20206d30     1mModules:.[0m  
    7058:	20202020 61635320 444d286e 4d202931          Scan(MD1) M
    7068:	6f726361 72615028 6c616974 2970614d     acro(PartialMap)
    7078:	74754f20 28747570 63726a70 29425355      Output(pjrcUSB)
    7088:	62654420 66286775 296c6c75 20000a0d      Debug(full)... 
    7098:	6d315b1b 71696e55 49206575 5b1b3a64     .[1mUnique Id:.[
    70a8:	20206d30 00202020 3b315b1b 496d3233     0m     ..[1;32mI
    70b8:	1b4f464e 206d305b 6548202d 65642078     NFO.[0m - Hex de
    70c8:	20677562 65646f6d 73696420 656c6261     bug mode disable
    70d8:	2e2e2e64 1b000a0d 333b315b 4e496d32     d.......[1;32mIN
    70e8:	5b1b4f46 2d206d30 78654820 62656420     FO.[0m - Hex deb
    70f8:	6d206775 2065646f 62616e65 2e64656c     ug mode enabled.
    7108:	0a0d2e2e 005b1b00 3b353b31 45003133     ......[.1;5;31.E
    7118:	524f5252 305b1b00 202d206d 22002200     RROR..[0m - ."."
    7128:	20736920 20746f6e 61762061 2064696c      is not a valid 
    7138:	6d6d6f63 2e646e61 79742e2e 1b206570     command...type .
    7148:	6d35335b 706c6568 6d305b1b 315b1b00     [35mhelp.[0m..[1
    7158:	333b353b 52456d31 1b524f52 206d305b     ;5;31mERROR.[0m 
    7168:	614d202d 756e2078 7265626d 20666f20     - Max number of 
    7178:	74636964 616e6f69 73656972 66656420     dictionaries def
    7188:	64656e69 726c6120 79646165 0d2e2e2e     ined already....
    7198:	5b1b000a 000d4b32 3b315b1b 3a6d3433     ...[2K...[1;34m:
    71a8:	6d305b1b 5b1b0020 3b353b31 456d3133     .[0m ..[1;5;31mE
    71b8:	524f5252 6d305b1b 53202d20 61697265     RROR.[0m - Seria
    71c8:	696c206c 6220656e 65666675 73692072     l line buffer is
    71d8:	6c756620 64202c6c 70706f72 20676e69      full, dropping 
    71e8:	72616863 65746361 6e612072 65722064     character and re
    71f8:	74746573 2e676e69 0a0d2e2e 735b1b00     setting.......[s
    7208:	1b000a0d 004b325b 00755b1b 00082008     ....[2K..[u.. ..
    7218:	61656c63 6c630072 62654469 68006775     clear.cliDebug.h
    7228:	00706c65 0064656c 6f6c6572 72006461     elp.led.reload.r
    7238:	74657365 73657200 74726174 72657600     eset.restart.ver
    7248:	6e6f6973 73655200                                sion.

0000724d <resetCLIDict_DescEntry>:
    724d:	65736552 74207374 74206568 696d7265     Resets the termi
    725d:	206c616e 6b636162 206f7420 74696e69     nal back to init
    726d:	206c6169 74746573 73676e69 1800002e              ial settings...

0000727c <basicCLIDict>:
    727c:	00007218 00006d5b 00003dc9 0000721e     .r..[m...=...r..
    728c:	0000738f 00003fa9 00007227 00006cfc     .s...?..'r...l..
    729c:	00003e05 0000722c 000072e8 00003ebd     .>..,r...r...>..
    72ac:	00007230 00006d6d 00003dd5 00007237     0r..mm...=..7r..
    72bc:	0000724d 00003df9 0000723d 00006d14     Mr...=..=r...m..
    72cc:	00003ed1 00007245 00006d98 00003ed5     .>..Er...m...>..
    72dc:	00000000 00000000 00000000              ............

000072e8 <ledCLIDict_DescEntry>:
    72e8:	62616e45 2f73656c 61736944 73656c62     Enables/Disables
    72f8:	646e6920 74616369 4c20726f 202e4445      indicator LED. 
    7308:	20797254 6f632061 656c7075 6d697420     Try a couple tim
    7318:	6a207365 20747375 63206e69 20657361     es just in case 
    7328:	20656874 2044454c 69207369 6e61206e     the LED is in an
    7338:	64646f20 61747320 0d2e6574 1b09090a      odd state......
    7348:	6d33335b 6e726157 1b676e69 3a6d305b     [33mWarning.[0m:
    7358:	79614d20 76646120 65737265 6120796c      May adversely a
    7368:	63656666 6f732074 6d20656d 6c75646f     ffect some modul
    7378:	2e2e7365 6547002e                                es....

0000737e <basicCLIDictName>:
    737e:	656e6547 206c6172 6d6d6f43 73646e61     General Commands
    738e:	616e4500                                         .

0000738f <cliDebugCLIDict_DescEntry>:
    738f:	62616e45 2f73656c 61736944 73656c62     Enables/Disables
    739f:	78656820 74756f20 20747570 7420666f      hex output of t
    73af:	6d206568 2074736f 65636572 6320746e     he most recent c
    73bf:	6920696c 7475706e 0000002e 00000100              li input.....
